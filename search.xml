<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>栈实现队列</title>
      <link href="/posts/18433.html"/>
      <url>/posts/18433.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​<a href="https://leetcode.cn/problems/implement-queue-using-stacks/"></a></p><p><img src="/posts/18433/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126225518.png"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>栈是先进后出，并且进出只能从一端进行</p><p>队列是先进先出，一端进一段出，如果要用栈去模拟队列，创建两个开口方向不同的栈来实现，一个负责进一个负责出</p><p>进栈的时候</p><p><img src="/posts/18433/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126225911.png"></p><p>出栈的时候先把元素全部转移到出栈里</p><p><img src="/posts/18433/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126230028.png"></p><p>然后通过出栈实现pop</p><p><img src="/posts/18433/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126230123.png"></p><p><strong>必须保证出栈为空才可转移进栈中的元素，否则会导致元素错位从而出栈顺序混乱</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">class MyQueue &#123;</span><br><span class="line">    //队列是先进先出，栈是先进后出</span><br><span class="line"></span><br><span class="line">    //进栈，只负责进</span><br><span class="line">    Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    //出栈，只负责出</span><br><span class="line">    Stack&lt;Integer&gt; stackOut;</span><br><span class="line"></span><br><span class="line">    public MyQueue() &#123;</span><br><span class="line">        stackIn = new Stack&lt;&gt;();</span><br><span class="line">        stackOut = new Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        //正常压入即可</span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        //出栈的时候如果出栈不为空，则出栈继续出，如果出栈为空，把进栈里的东西全部转移到出栈里</span><br><span class="line">        pd();</span><br><span class="line">        return stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int peek() &#123;</span><br><span class="line">        //获取队头的元素</span><br><span class="line">        pd();</span><br><span class="line">        return stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        //空的情况为两个队列都空才算空</span><br><span class="line">        return stackOut.isEmpty() &amp;&amp; stackIn.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void pd() &#123;</span><br><span class="line">        //如果出栈为空，把进栈的东西全部装到出栈里</span><br><span class="line">        if (!stackOut.isEmpty()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            while (!stackIn.isEmpty()) &#123;</span><br><span class="line">                stackOut.push(stackIn.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>KMP</title>
      <link href="/posts/31301.html"/>
      <url>/posts/31301.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="KMP匹配模式算法"><a href="#KMP匹配模式算法" class="headerlink" title="KMP匹配模式算法"></a>KMP匹配模式算法</h1><p>本来以为串的知识点应该很简单，没想到，在最后两页栽了大跟头！！</p><p>克努特——莫里斯——普拉斯算法</p><p>串是由零个或多个字符组成的有序序列。对与串的基本操作有一部分与线性表十分相似，但是线性表更关注单个元素的操作，比如查找一个元素，插入或者删除一个元素，但是串中更多的是查找子串的位置，得到指定位置的字串，替换字串等。其中查询指定位置的子串相对而言比较重要，而KMP算法就是对一般查询字串位置的一种改进。</p><h2 id="朴素的匹配模式算法"><a href="#朴素的匹配模式算法" class="headerlink" title="朴素的匹配模式算法"></a>朴素的匹配模式算法</h2><p>查询子串位置的一般暴力解法——对主串做大循环，对每个字符开头做T的长度的小循环，直到匹配成功或者全部遍历完成为止</p><p>时间复杂度为O(（n-m+1）*m)</p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126212543.png"></p><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>这个算法。。。。。。我讲不明白。。。。。把我理解的图画一下吧，有时间再回炉重造。。。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>如果在子串中存在一部分相等的字符串，我们可通过修改短循环的起始位置来达到减少回溯次数作用，从而减少匹配所需的时间消耗</p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126213334.png"></p><p>如上图，在5位置匹配失败（这代表前面部分全部相等），果我们用暴力算法，那么下一步主串将会重新从子串的第一个开始继续匹配，但是我们研究子串中的前面部分，存在着两个完全相等的前后缀（ab），那么我们下一次匹配的时候完全可以从与后缀相等的前缀之后开始匹配从而达到减少操作次数的目的</p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126213834.png"></p><p>那么，我们在匹配失败的时候应该怎样知道应该回溯到什么地方呢？——构造next[], 最长相等前缀表</p><h3 id="前缀表"><a href="#前缀表" class="headerlink" title="前缀表"></a>前缀表</h3><p>图</p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126215218.png"></p><p>怎么理解j &#x3D; next[j]</p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126220704.png"></p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126220850.png"></p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126221114.png"></p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126221632.png"></p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126221646.png"></p><p>改进版本该怎么理解（右端空格里的东西应该也是A）</p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126221702.png"></p><p>一图值千言！！！！</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p>这个怎么说呢。。。。。这个思路，我理解了这么久，但是，最后就只有这几行代码，确实非常震撼</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int kmp(String s, String t) &#123;</span><br><span class="line">    //细节，多次使用的数据先获取</span><br><span class="line">    int sl = s.length();</span><br><span class="line">    int tl = t.length();</span><br><span class="line">    //特判</span><br><span class="line">    if (sl &lt; tl) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取next数组</span><br><span class="line">    int[] next = kmpNext(t);</span><br><span class="line"></span><br><span class="line">    //开始匹配</span><br><span class="line">    int i = 0, j = 0;</span><br><span class="line">    while(i &lt; sl &amp;&amp; j &lt; tl) &#123;</span><br><span class="line">        //这里的位置不能换，要么在j为-1的时候可能会出错</span><br><span class="line">        if (j == -1 || s.charAt(i) == t.charAt(j)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (j == tl) &#123;</span><br><span class="line">        return i - j;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return  -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int[] kmpNext(String t) &#123;</span><br><span class="line">    int len = t.length();</span><br><span class="line">    int[] next = new int[len];</span><br><span class="line">    //这里必须初始化数组</span><br><span class="line">    next[0] = -1;</span><br><span class="line">    int i = 0, j = -1;</span><br><span class="line">    while (i &lt; len - 1) &#123;</span><br><span class="line">        if (j == -1 || t.charAt(j) == t.charAt(i)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            i++;</span><br><span class="line">            //此处为改进版本</span><br><span class="line">            if (t.charAt(j) == t.charAt(i)) &#123;</span><br><span class="line">                next[i] = next[j];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                next[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>拼图游戏知识点整理</title>
      <link href="/posts/63503.html"/>
      <url>/posts/63503.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一个简单的拼图游戏"><a href="#一个简单的拼图游戏" class="headerlink" title="一个简单的拼图游戏"></a>一个简单的拼图游戏</h1><p>最近看网课跟着网课老师写了一个简单的拼图游戏，感觉自己对平时常用的这些软件有了全新的认识，原来图片的移动不是移动，原来关闭窗口不用真的关闭。。。。。总之有点。。。难受。</p><p>学到的东西也很多，但还是自己整理一遍比较好，纸上得来终觉浅，深知此事要躬行。</p><p>对对象，跟方法的使用和程序设计有了更深的理解</p><h3 id="一些知识点"><a href="#一些知识点" class="headerlink" title="一些知识点"></a>一些知识点</h3><p>（初步认识）</p><p><strong>JFrame</strong>-Java的GUI程序的基本思路是以JFrame为基础，它是屏幕上window的对象，通过这个对象我们能给程序设计各种窗口，通过一些方法我们可以实现窗口的最大化，最小化，选择关闭模式等基础功能</p><p><em><strong>这是一个容器，允许程序员把其他组件添加到它里面，把他们组织起来并把他们呈现给用户。</strong></em></p><p>包含方法</p><p><img src="/posts/63503/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230121013051.png"></p><p><img src="/posts/63503/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230121013134.png"></p><p><img src="/posts/63503/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230121013148.png"></p><p><strong>JPanel</strong>-Java图形用户界面工具包swing中的面板容器类，包含在javax.swing包中可以进行嵌套，功能是<em><strong>对窗体中具有相同逻辑功能的组件进行组合</strong></em>，是一种轻量级容器，可以加到JFrame窗体中。</p><p>是一种面板容器类，是一种轻量级容器，可以加到JFrame窗体中，自身可以嵌套组合，在不同子容器中可以包含其他组件如JButton、JTextArea、JTextField 等，功能是对窗体上的这些控件进行组合</p><p><strong>JLabel</strong>-该对象可以显示文本、图像，或同时显示二者。可以通过设置垂直和水平对齐方式，制定标签显示区中标签内容在何处对其。默认情况下，标签在其显示区域内居中对齐。默认情况下，只显示文本的标签是开始边对齐；而只显示图像的标签则水平居中对齐（需要注意的是，添加对象的顺序会导致我们设置的一些东西失效，比如文字位置，先加的在上面，后加的在下面，如果出现设置失效的情况可以试着改变添加的顺序）</p><p>用于管理显示图片或文本</p><p><strong>JMenuBar</strong>菜单栏JMenuBar，菜单JMenu，菜单项JMenuItem,一旦A有子菜单项，则A为菜单JMenu，而不是菜单项JMenuItem,菜单可以互相包含</p><p><strong>JDialog</strong>-对话框（<em>Jdialog</em>）与框架（JFrame）有一些相似，但它一般是一个临时的窗口，主要用于显示提示信息或接受用户输入。</p><p><strong>JTextField</strong>-一个轻量级组件，它允许编辑单行文本。</p><p><strong>JPasswordField</strong>-允许我们输入一行字像输入框，大师隐藏星号或点创建密码</p><p><strong>JButton</strong>-JButton类的实例。用于创建按钮</p><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>先说游戏的实现思路，初始化一个二维数组，根据数组中的值显示对应图片，此时记录空白图片的位置，根据用户的输入与记录的空白图片位置去对数组中的值进行改变，然后根据新数组中的值再去打印对应的图片实现移动图片的操作，如果每次移动对数组中的值进行判断，符合一定规律结束程序</p><p>游戏主要针对三个窗口进行设计，登录界面，注册界面，游戏界面，所以需要设计三个窗口类，我们直接新建class文件继承Java中原有的窗口类JFrame即可，通过添加新的方法或者对父类中的方法进行修改来设计我们自己的窗口，并且我们还需要通过键盘或者鼠标来对这些窗口中的组件进行操作所以还要实现鼠标监听接口或者键盘监听接口，然后在重写的方法中实现我们希望它实现的逻辑</p><h3 id="游戏界面"><a href="#游戏界面" class="headerlink" title="游戏界面"></a>游戏界面</h3><p>成员变量</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//图片位置</span><br><span class="line">int data[][] = new int[4][4];</span><br><span class="line"></span><br><span class="line">int win[][] =  new int[][]&#123;</span><br><span class="line">        &#123;1,2,3,4&#125;,</span><br><span class="line">        &#123;5,6,7,8&#125;,</span><br><span class="line">        &#123;9,10,11,12&#125;,</span><br><span class="line">        &#123;13,14,15,0&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">//记录空白方块在二维数组中的位置</span><br><span class="line">int x = 0,y = 0;</span><br><span class="line">//记录步数</span><br><span class="line">int count = 0;</span><br><span class="line">//隐藏功能</span><br><span class="line">public int flag;</span><br><span class="line"></span><br><span class="line">//考验字符串操作，通过修稿字符串中的特定内容我们可以让软件显示不同的图片</span><br><span class="line">String path = &quot;image/animal/animal2/&quot;;</span><br><span class="line"></span><br><span class="line">//因为actionlistener需要获取这些对象（用于判断该实现什么逻辑），所以不把他们单独写在菜单初始化方法中</span><br><span class="line">//创建菜单下条目的对象</span><br><span class="line">JMenuItem replayItem = new JMenuItem(&quot;重新游戏&quot;);</span><br><span class="line">JMenuItem reLoginItem = new JMenuItem(&quot;重新登录&quot;);</span><br><span class="line">JMenuItem closeItem = new JMenuItem(&quot;关闭游戏&quot;);</span><br><span class="line">JMenuItem girlItem = new JMenuItem(&quot;美女&quot;);</span><br><span class="line">JMenuItem animalItem = new JMenuItem(&quot;动物&quot;);</span><br><span class="line">JMenuItem sportItem = new JMenuItem(&quot;运动&quot;);</span><br><span class="line">JMenuItem textItem = new JMenuItem(&quot;游戏说明&quot;);</span><br><span class="line"></span><br><span class="line">JMenuItem accountItem = new JMenuItem(&quot;微信&quot;);</span><br></pre></td></tr></table></figure><p>初始化容器</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public GameJFrame(int flag) &#123;</span><br><span class="line">    //在创建界面的时候顺带创建了一个隐藏的管理容器（根容器），我们可以把图片，按钮，菜单这些东西交给他，但要使用getContentPane方法</span><br><span class="line"></span><br><span class="line">//这里下面的一些步骤，比如初始化图片需要在其他方法中多次使用，所以直接写成方法，逻辑不可改变</span><br><span class="line">    //初始化界面</span><br><span class="line">    initJFrame();</span><br><span class="line">    //初始化菜单</span><br><span class="line">    initJMenuBur();</span><br><span class="line">    //初始化数据</span><br><span class="line">    initData();</span><br><span class="line">    //初始化,添加图片（根据初始化后的数据打印图片）</span><br><span class="line">    initImage();</span><br><span class="line">    this.flag = flag;</span><br><span class="line"></span><br><span class="line">    //界面默认隐藏，设置是否可见（放最后）</span><br><span class="line">    this.setVisible(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化游戏数据</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void initData() &#123;</span><br><span class="line">    int num[] = &#123;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15&#125;;</span><br><span class="line">    Random r = new Random();</span><br><span class="line">    for (int i = 0; i &lt; num.length; i++) &#123;</span><br><span class="line">        int index = r.nextInt(num.length);</span><br><span class="line">        int temp = num[i];</span><br><span class="line">        num[i] = num[index];</span><br><span class="line">        num[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; 4; j++) &#123;</span><br><span class="line">            if (num[count] == 0) &#123;</span><br><span class="line">                x = i;</span><br><span class="line">                y = j;</span><br><span class="line">            &#125;</span><br><span class="line">            data[i][j] = num[count++];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化图像</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void initImage() &#123;</span><br><span class="line"></span><br><span class="line">    //因为我们会多次调用这个方法，所以每次调用这个方法前都先清空所有组件</span><br><span class="line">    //容器中的内容是是先添加的在上面，后添加的在下面，每次都先清空这些组件然后再添加内容保证新内容不被覆盖</span><br><span class="line">    this.getContentPane().removeAll();</span><br><span class="line">//添加顺序比较重要</span><br><span class="line">//如果胜利，显示胜利的图片</span><br><span class="line">    if (victory()) &#123;</span><br><span class="line">        JLabel win = new JLabel(new ImageIcon(&quot;image/win.png&quot;));</span><br><span class="line">        win.setBounds(203,283,197,73);//设置边界</span><br><span class="line">        通过这个对象，获取他的默认容器，添加窗口</span><br><span class="line">        this.getContentPane().add(win);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//添加步数窗口</span><br><span class="line">    JLabel stepCount = new JLabel(&quot;步数：&quot;+count);</span><br><span class="line">    stepCount.setBounds(50,30,100,20);</span><br><span class="line">    this.getContentPane().add(stepCount);</span><br><span class="line"></span><br><span class="line">    //添加背景图片（先加载的图片在上方,后加载的图片在下方）</span><br><span class="line">    //所以背景图片最后加</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; 4; j++) &#123;</span><br><span class="line">            //创建一个管理容器</span><br><span class="line">            JLabel jLabel = new JLabel(new ImageIcon(path+data[i][j]+&quot;.jpg&quot;));</span><br><span class="line">            //指定图片位置</span><br><span class="line">            jLabel.setBounds(105*j+83,105*i+134,105,105);</span><br><span class="line">            //给图片添加边框</span><br><span class="line">            //参数为斜面方向</span><br><span class="line">            jLabel.setBorder(new BevelBorder(0));</span><br><span class="line">            //把管理容器添加到界面中</span><br><span class="line">            this.getContentPane().add(jLabel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ImageIcon bg = new ImageIcon(&quot;image/background.png&quot;);</span><br><span class="line">    JLabel backGround = new JLabel(bg);</span><br><span class="line">    backGround.setBounds(40,40,508,560);</span><br><span class="line">    //把图片添加到控制容器中</span><br><span class="line">    this.getContentPane().add(backGround);</span><br><span class="line"></span><br><span class="line">    //刷新界面（显示新的界面）</span><br><span class="line">    this.getContentPane().repaint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化游戏菜单</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void initJMenuBur() &#123;</span><br><span class="line">    //初始化菜单</span><br><span class="line">    //创建整个菜单的对象</span><br><span class="line">    JMenuBar jMenuBar = new JMenuBar();</span><br><span class="line">    //创建菜单上两个选项的对象（功能  关于我们）</span><br><span class="line">    JMenu functionJMenu = new JMenu(&quot;功能&quot;);</span><br><span class="line">    JMenu aboutJMenu = new JMenu(&quot;关于我们&quot;);</span><br><span class="line">    JMenu changeImage = new JMenu(&quot;更换图片&quot;);</span><br><span class="line">    changeImage.add(girlItem);</span><br><span class="line">    changeImage.add(animalItem);</span><br><span class="line">    changeImage.add(sportItem);</span><br><span class="line"></span><br><span class="line">    //将选项组合,添加条目</span><br><span class="line">    //一级整合</span><br><span class="line">    functionJMenu.add(replayItem);</span><br><span class="line">    functionJMenu.add(reLoginItem);</span><br><span class="line">    functionJMenu.add(closeItem);</span><br><span class="line">    functionJMenu.add(changeImage);</span><br><span class="line"></span><br><span class="line">    aboutJMenu.add(accountItem);</span><br><span class="line"></span><br><span class="line">    //给条目绑定事件</span><br><span class="line">    replayItem.addActionListener(this);</span><br><span class="line">    reLoginItem.addActionListener(this);</span><br><span class="line">    closeItem.addActionListener(this);</span><br><span class="line">    accountItem.addActionListener(this);</span><br><span class="line">    girlItem.addActionListener(this);</span><br><span class="line">    animalItem.addActionListener(this);</span><br><span class="line">    sportItem.addActionListener(this);</span><br><span class="line">    textItem.addActionListener(this);</span><br><span class="line"></span><br><span class="line">    //二级整合</span><br><span class="line">    jMenuBar.add(functionJMenu);</span><br><span class="line">    jMenuBar.add(aboutJMenu);</span><br><span class="line">    jMenuBar.add(textItem);</span><br><span class="line"></span><br><span class="line">    //给整个界面设置菜单</span><br><span class="line">    this.setJMenuBar(jMenuBar);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化主界面</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void initJFrame() &#123;</span><br><span class="line">    //设置窗口</span><br><span class="line">    //设置界面宽高</span><br><span class="line">    this.setSize(603,680);</span><br><span class="line">    //设置界面标题</span><br><span class="line">    this.setTitle(&quot;拼图单机版 v1.0&quot;);</span><br><span class="line">    //设置界面置顶</span><br><span class="line">    this.setAlwaysOnTop(true);</span><br><span class="line">    //设置界面居中</span><br><span class="line">    this.setLocationRelativeTo(null);</span><br><span class="line">    //设置关闭模式</span><br><span class="line">    //关闭模式0，啥都不干 1，默认 2，多个界面，只有关掉最后一个界面才会关闭虚拟机（所有界面都要这样设置） 3，关掉一个，虚拟机结束</span><br><span class="line">    this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">    //取消默认居中放置，取消之后才能按照我的想法(xy轴形式)放置图片</span><br><span class="line">    this.setLayout(null);</span><br><span class="line">    //给整个界面添加监听事件</span><br><span class="line">    //这样this.getContentPane().addKeyListener(this);为什么错了，中间那一段到底是什么意思</span><br><span class="line">    //这个窗口的管理容器中添加了一个监听对象？</span><br><span class="line">    </span><br><span class="line">    //在当前对象上添加键盘监听</span><br><span class="line">    this.addKeyListener(this);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>游戏说明，这里添加顺序比较重要</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void showJDialog() &#123;</span><br><span class="line">    //创建一个弹框对象</span><br><span class="line">    JDialog dialog = new JDialog();</span><br><span class="line">    //设置弹框大小</span><br><span class="line">    dialog.setSize(600, 500);</span><br><span class="line">    //让弹框制定</span><br><span class="line">    dialog.setAlwaysOnTop(true);</span><br><span class="line">    //让弹框居中</span><br><span class="line">    dialog.setLocationRelativeTo(null);</span><br><span class="line">    //弹框不关闭无法操作下面界面</span><br><span class="line">    dialog.setModal(true);</span><br><span class="line"></span><br><span class="line">    //创建管理文字对象并添加到弹框中</span><br><span class="line">    JLabel text = new JLabel(new ImageIcon(&quot;image/img.png&quot;));</span><br><span class="line">    text.setBounds(0,0,500,400);</span><br><span class="line">    dialog.getContentPane().add(text);</span><br><span class="line">    //显示弹框</span><br><span class="line">    dialog.setVisible(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否胜利（可优化，节省储存正确答案的空间）</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean victory() &#123;</span><br><span class="line">    for (int i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; data[i].length; j++) &#123;</span><br><span class="line">            if (data[i][j] != win[i][j]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写的监听方法</p><p>这里的思路是监听到对应事件后，判断监听源，想写啥写啥，这个时候上面写的方法就十分重要了</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override检测单击</span><br><span class="line">public void actionPerformed(ActionEvent e) &#123;</span><br><span class="line">    Object obj = e.getSource();</span><br><span class="line">    if (obj == replayItem) &#123;//重新开始</span><br><span class="line">        //计步器清零</span><br><span class="line">        count = 0;</span><br><span class="line">        //打乱数据</span><br><span class="line">        initData();</span><br><span class="line">        //加载图片</span><br><span class="line">        initImage();</span><br><span class="line"></span><br><span class="line">    &#125; else if (obj == reLoginItem) &#123;//重新登录，匿名对象知识点</span><br><span class="line">        //返回登录界面</span><br><span class="line">        //关闭界面</span><br><span class="line">        this.setVisible(false);</span><br><span class="line">        //打开登录界面</span><br><span class="line">        new LoginJFrame();</span><br><span class="line"></span><br><span class="line">    &#125; else if (obj == closeItem) &#123;//关闭</span><br><span class="line">        System.exit(0);</span><br><span class="line"></span><br><span class="line">    &#125; else if (obj == accountItem) &#123;//关于我。。。。。。看半天才看出来是啥，直到我看了一眼图片</span><br><span class="line">        //创建一个弹框对象</span><br><span class="line">        JDialog jDialog = new JDialog();</span><br><span class="line">        //创建一个管理图片的容器对象</span><br><span class="line">        JLabel jLabel = new JLabel(new ImageIcon(&quot;image/1673683779539.jpg&quot;));</span><br><span class="line">        //设置位置和宽高</span><br><span class="line">        jLabel.setBounds(0,0,355,431);</span><br><span class="line">        //把图片添加到弹框中</span><br><span class="line">        //弹框只是一个框架，</span><br><span class="line">        jDialog.getContentPane().add(jLabel);</span><br><span class="line">        //给弹框设置大小</span><br><span class="line">        jDialog.setSize(405,481);</span><br><span class="line">        //让弹框指定</span><br><span class="line">        jDialog.setAlwaysOnTop(true);</span><br><span class="line">        //让弹框居中</span><br><span class="line">        jDialog.setLocationRelativeTo(null);</span><br><span class="line">        //弹框不关闭，无法操作下面的界面</span><br><span class="line">        jDialog.setModal(true);</span><br><span class="line">        //让弹框显示出来</span><br><span class="line">        jDialog.setVisible(true);</span><br><span class="line"></span><br><span class="line">    &#125; else if (obj == girlItem) &#123;//改变成员变量path中的内容，考察字符串操作</span><br><span class="line">        System.out.println(&quot;切换美女&quot;);</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        int pictureNumb;</span><br><span class="line">        if (flag == 0) &#123;</span><br><span class="line">            pictureNumb = r.nextInt(11) + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pictureNumb = r.nextInt(2) + 12;</span><br><span class="line">        &#125;</span><br><span class="line">        path = &quot;image/girl/girl&quot;+pictureNumb+&quot;/&quot;;</span><br><span class="line">        count = 0;</span><br><span class="line">        initData();</span><br><span class="line">        initImage();</span><br><span class="line">    &#125; else if (obj == animalItem) &#123;</span><br><span class="line">        System.out.println(&quot;切换动物&quot;);</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        int pictureNumb = r.nextInt(8)+1;</span><br><span class="line">        path = &quot;image/animal/animal&quot;+pictureNumb+&quot;/&quot;;</span><br><span class="line">        count = 0;</span><br><span class="line">        initData();</span><br><span class="line">        initImage();</span><br><span class="line">    &#125; else if (obj == sportItem) &#123;</span><br><span class="line">        System.out.println(&quot;切换运动&quot;);</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        int pictureNumb = r.nextInt(10)+1;</span><br><span class="line">        path = &quot;image/sport/sport&quot;+pictureNumb+&quot;/&quot;;</span><br><span class="line">        count = 0;</span><br><span class="line">        initData();</span><br><span class="line">        initImage();</span><br><span class="line">    &#125; else if (obj == textItem) &#123;</span><br><span class="line">        showJDialog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测键盘输入</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void keyTyped(KeyEvent e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//按下调用</span><br><span class="line">@Override//显示原图</span><br><span class="line">public void keyPressed(KeyEvent e) &#123;</span><br><span class="line">    int code = e.getKeyCode();</span><br><span class="line">    if (code == 65) &#123;</span><br><span class="line">        this.getContentPane().removeAll();</span><br><span class="line">        JLabel all = new JLabel(new ImageIcon(path+&quot;all.jpg&quot;));</span><br><span class="line">        all.setBounds(83,134,420,420);</span><br><span class="line">        this.getContentPane().add(all);</span><br><span class="line"></span><br><span class="line">        ImageIcon bg = new ImageIcon(&quot;image/background.png&quot;);</span><br><span class="line">        JLabel backGround = new JLabel(bg);</span><br><span class="line">        backGround.setBounds(40,40,508,560);</span><br><span class="line">        //把图片添加到根界面中</span><br><span class="line">        this.getContentPane().add(backGround);</span><br><span class="line">        this.getContentPane().repaint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void keyReleased(KeyEvent e) &#123;</span><br><span class="line">    //如果胜利，此方法直接结束,就不能再移动了</span><br><span class="line">    if (victory()) &#123;//胜利之后图片就不应该动了</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果还没胜利</span><br><span class="line">    //左37 右39 上38 下40</span><br><span class="line">    //这里应该是错的，猜测不管按啥都会导致步数++</span><br><span class="line">    count++;</span><br><span class="line">    //获取按键值</span><br><span class="line">    int code = e.getKeyCode();</span><br><span class="line">    if (code == 37) &#123;</span><br><span class="line">        if (y == 3) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;向左移动&quot;);</span><br><span class="line">        data[x][y] = data[x][y + 1];</span><br><span class="line">        data[x][y + 1] = 0;</span><br><span class="line">        y++;</span><br><span class="line">        initImage();</span><br><span class="line">    &#125; else if (code == 38) &#123;</span><br><span class="line">        if (x == 3) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;向上移动&quot;);</span><br><span class="line">        data[x][y] = data[x + 1][y];</span><br><span class="line">        data[x + 1][y] = 0;</span><br><span class="line">        x++;</span><br><span class="line">        initImage();</span><br><span class="line">    &#125; else if (code == 39) &#123;</span><br><span class="line">        if (y == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;向右移动&quot;);</span><br><span class="line">        data[x][y] = data[x][y - 1];</span><br><span class="line">        data[x][y - 1] = 0;</span><br><span class="line">        y--;</span><br><span class="line">        initImage();</span><br><span class="line">    &#125; else if (code == 40) &#123;</span><br><span class="line">        if (x == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;向下移动&quot;);</span><br><span class="line">        data[x][y] = data[x - 1][y];</span><br><span class="line">        data[x - 1][y] = 0;</span><br><span class="line">        x--;</span><br><span class="line">        initImage();</span><br><span class="line">    &#125; else if (code == 65) &#123;//重新开始</span><br><span class="line">        initImage();</span><br><span class="line">    &#125; else if (code == 87) &#123;//作弊代码</span><br><span class="line">        data = new int[][]&#123;</span><br><span class="line">                &#123;1,2,3,4&#125;,</span><br><span class="line">                &#123;5,6,7,8&#125;,</span><br><span class="line">                &#123;9,10,11,12&#125;,</span><br><span class="line">                &#123;13,14,15,0&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        initImage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>跟着网课老师写了大部分，自己补了隐藏功能及更换图片，游戏说明的部分，还有登录部分（最后还是改成老师的代码），首先游戏一开始就创建的登录部分，登录部分包含一个集合，里面包含的初始化的用户信息，如果信息对的上，那么窗口隐身，实现游戏窗口，需要注意的是先判断用户名或密码是否为空，然后判断验证码，最后判断正误，整体还是比较简单，用户注册的功能猜测可以用数据库，主要逻辑是隐藏登录界面，新建注册界面，初始化注册界面，加载组件，判断输入内容，如果合法，添加到数据库中 ，返回登录界面，注册界面隐藏，然而单机版的化估计可以用文件输入输出，可以总结出一些固定操作</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java自带的栈与队列 类</title>
      <link href="/posts/49362.html"/>
      <url>/posts/49362.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作为高级语言，Java肯定是自带了Stack类跟Queue类，学习使用现成的还是有必要的</p><h1 id="Stack-类"><a href="#Stack-类" class="headerlink" title="Stack 类"></a>Stack 类</h1><p>栈是Vector的一个子类，它实现类一个标准的后进先出栈</p><p><strong>构造函数</strong></p><p>Stack()</p><p><strong>包含方法</strong></p><p>除了Vector中定义的所有方法外，自己的方法有</p><p><img src="/posts/49362/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230113162000.jpg"></p><p><strong>实例</strong></p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package stack;</span><br><span class="line"></span><br><span class="line">import java.util.EmptyStackException;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class StackDemo &#123;</span><br><span class="line"></span><br><span class="line">    static void showpush(Stack&lt;Integer&gt; st, int a) &#123;</span><br><span class="line">        st.push(new Integer(a));</span><br><span class="line">        System.out.println(&quot;push(&quot; + a + &quot;)&quot;);</span><br><span class="line">        System.out.println(&quot;stack: &quot; + st);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void showpop(Stack&lt;Integer&gt; st) &#123;</span><br><span class="line">        System.out.print(&quot;pop -&gt; &quot;);</span><br><span class="line">        Integer a = (Integer) st.pop();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(&quot;stack: &quot; + st);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; st = new Stack&lt;Integer&gt;();</span><br><span class="line">        System.out.println(&quot;stack: &quot; + st);</span><br><span class="line">        showpush(st, 42);</span><br><span class="line">        showpush(st, 66);</span><br><span class="line">        showpush(st, 99);</span><br><span class="line">        showpop(st);</span><br><span class="line">        showpop(st);</span><br><span class="line">        showpop(st);</span><br><span class="line">        try &#123;</span><br><span class="line">            showpop(st);</span><br><span class="line">        &#125; catch (EmptyStackException e) &#123;</span><br><span class="line">            System.out.println(&quot;empty stack&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/49362/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230113163206.png" alt="运行结果"></p>]]></content>
      
      
      <categories>
          
          <category> 栈与队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>队列——java</title>
      <link href="/posts/49269.html"/>
      <url>/posts/49269.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>这里是我比较不确定的，感觉不太稳，但是不想测试了，如果真的有错。。。。。。日后再改</p><h2 id="静态队列"><a href="#静态队列" class="headerlink" title="静态队列"></a>静态队列</h2><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Queue;</span><br><span class="line">//现在有两种思路，一种是动态的，一种是静态的，为了巩固静态链表，我在这里只写静态的</span><br><span class="line">//队列各元素之前也具有前驱后继关系</span><br><span class="line">//采用一种取巧的方法，如果后面排满了，前面有位置，那么整体前移</span><br><span class="line">//我上面说的屁话，还是直接用循环队列的好，循环队列多香啊！</span><br><span class="line">class SqQueue&#123;</span><br><span class="line">    int maxSize = 100;</span><br><span class="line">    int data[];</span><br><span class="line">    int front;</span><br><span class="line">    int rear;</span><br><span class="line">    int count;</span><br><span class="line"></span><br><span class="line">    public SqQueue() &#123;</span><br><span class="line">        this.data = new int[maxSize];</span><br><span class="line">        front = 0;</span><br><span class="line">        rear = 1;</span><br><span class="line">        count = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int QueueLength() &#123;</span><br><span class="line">        return count;</span><br><span class="line">        //return (rear - front + maxSize) % maxSize</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void EnQueue(int x) &#123;</span><br><span class="line">        if(rear == maxSize - 1 &amp;&amp; front != 0) &#123;</span><br><span class="line">            data[rear] = x;</span><br><span class="line">            count++;</span><br><span class="line">            rear = 0;</span><br><span class="line">        &#125; else if ((rear + 1) != front) &#123;</span><br><span class="line">            data[rear] = x;</span><br><span class="line">            count++;</span><br><span class="line">            rear++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //感觉比较不太稳的地方</span><br><span class="line">    public int DeQueue() &#123;</span><br><span class="line">        int pos = -1;</span><br><span class="line">        if(front == maxSize - 1 &amp;&amp; count != 0)&#123;</span><br><span class="line">            pos = data[front];</span><br><span class="line">            front = 0;</span><br><span class="line">            count--;</span><br><span class="line">        &#125; else if (count != 0) &#123;</span><br><span class="line">            pos = data[front];</span><br><span class="line">            front++;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        return pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyQueue &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h2><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Queue;</span><br><span class="line"></span><br><span class="line">class QueueNode &#123;</span><br><span class="line">    int data;</span><br><span class="line">    QueueNode next;</span><br><span class="line"></span><br><span class="line">    public QueueNode() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public QueueNode(int data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LinkQueue &#123;</span><br><span class="line">    QueueNode front ;</span><br><span class="line">    QueueNode rear ;</span><br><span class="line">    int count;</span><br><span class="line"></span><br><span class="line">    public LinkQueue() &#123;</span><br><span class="line">        front = new QueueNode();</span><br><span class="line">        rear = front;</span><br><span class="line">        count = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void EnQueue(int x) &#123;</span><br><span class="line">        QueueNode node = new QueueNode(x);</span><br><span class="line">        rear.next = node;</span><br><span class="line">        rear = node;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void DeQueue() &#123;</span><br><span class="line">        if (front.next.next != null) &#123;</span><br><span class="line">            front.next = front.next.next;</span><br><span class="line">            count--;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            rear = front;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 栈与队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈——java</title>
      <link href="/posts/40188.html"/>
      <url>/posts/40188.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>直接上我写的栈的代码，栈其实只是一种特殊的线性表，以下的栈几乎都没有经过测试，如有错误，之后再改吧</p><h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><p>普通的顺序栈</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package stack.SXstack;</span><br><span class="line"></span><br><span class="line">class SElem &#123;</span><br><span class="line">    final int maxSize = 100;</span><br><span class="line">    //储存数据</span><br><span class="line">    public int data[];</span><br><span class="line">    //储存栈顶位置</span><br><span class="line">    int top;</span><br><span class="line"></span><br><span class="line">    public SElem() &#123;</span><br><span class="line">        this.data = new int[maxSize];</span><br><span class="line">        this.top = -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //入栈，返回入栈是否成功</span><br><span class="line">    boolean Push(int x) &#123;</span><br><span class="line">        if (top == maxSize - 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            data[++top] = x;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出栈，返回出栈的元素</span><br><span class="line">    int Pop() &#123;</span><br><span class="line">        if (top == -1) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return data[top--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//栈的操作让我们不必担心数组下标这些多余操作，更加直面问题的本质</span><br><span class="line">public class SXstack &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SElem a = new SElem();</span><br><span class="line">        a.Push(1);</span><br><span class="line">        a.Push(2);</span><br><span class="line">        a.Push(3);</span><br><span class="line">        a.Push(4);</span><br><span class="line">        a.Push(5);</span><br><span class="line">        System.out.println(a.Pop());</span><br><span class="line">        System.out.println(a.Pop());</span><br><span class="line">        System.out.println(a.Pop());</span><br><span class="line">        System.out.println(a.Pop());</span><br><span class="line">        System.out.println(a.Pop());</span><br><span class="line">        System.out.println(a.Pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两栈共用空间</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package stack.SXstack;</span><br><span class="line">/*虽然是两栈共享空间，但是我们不用真的创建两个栈，两个栈一起操作还是会带来很多麻烦的，临界情况不太好考虑</span><br><span class="line">我们只需要用一个栈，来模拟两个栈对接在一起的情况即可，有点类似双向链表</span><br><span class="line">这种结构主要用于解决两个栈的空间需求有相反关系</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class SqDoubleStack &#123;</span><br><span class="line">    int maxSize = 100;</span><br><span class="line">    int data[] = new int[maxSize];</span><br><span class="line">    int top1;</span><br><span class="line">    int top2;</span><br><span class="line"></span><br><span class="line">    public SqDoubleStack() &#123;</span><br><span class="line">        top1 = -1;</span><br><span class="line">        top2 = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean Push(int x, int w) &#123;</span><br><span class="line">        if (top2 + top1 + 1== maxSize) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (w == 1) &#123;</span><br><span class="line">                data[++top1] = x;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                data[--top2] = x;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int Pop(int x, int w) &#123;</span><br><span class="line">        if(w == 1) &#123;</span><br><span class="line">            if(top1 == -1)&#123;</span><br><span class="line">                return -1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return data[top1--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (w == 2) &#123;</span><br><span class="line">            if (top2 == maxSize) &#123;</span><br><span class="line">                return -1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return data[top2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DoubleStack &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;肯定没问题 ，我就不测试了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h2><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package stack.LSstack;</span><br><span class="line"></span><br><span class="line">class StackNode&#123;</span><br><span class="line">    int data;</span><br><span class="line">    StackNode next;</span><br><span class="line"></span><br><span class="line">    public StackNode(int data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LinkStack &#123;</span><br><span class="line">    StackNode top;</span><br><span class="line">    int count;</span><br><span class="line"></span><br><span class="line">    public LinkStack() &#123;</span><br><span class="line">        count = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        if (top == null) &#123;</span><br><span class="line">            top = new StackNode(x);</span><br><span class="line">            count++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            StackNode pos = new StackNode(x);</span><br><span class="line">            pos.next = top;</span><br><span class="line">            top = pos;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        if (top == null) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int pos = top.data;</span><br><span class="line">            top = top.next;</span><br><span class="line">            count--;</span><br><span class="line">            return pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 栈与队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>静态链表</title>
      <link href="/posts/50363.html"/>
      <url>/posts/50363.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><h2 id="静态单链表"><a href="#静态单链表" class="headerlink" title="静态单链表"></a>静态单链表</h2><p>静态单链表是使用数组来模拟链表，静态链表本身是为了让那些没有指针的语言也能使用链表结构，但是对于其他有指针的语言而言，在算法比赛中，静态链表的使用要多得多，因为他用数组模拟，会更快，学长的说法是你不断的去new一个什么东西是很慢的，我的静态链表采用的思路跟动态链表基本相同，两个数组，一个e代表数据域，一个ne代表指针域，相同数组下标为一个结点，通过对应结点的指针域中所储存的值去寻找下一个结点，虽然储存的形式类似于顺序结构，但是因为有额外的空间用于储存该数据的逻辑结构，所以依然是链表。。。感觉好绕。。。。。。。不过重要的是，指针域中储存的是逻辑结构，<strong>只要能通过结点的指针域中的数值去找到下一个结点就可以</strong>，指针域中的数值可能是无序且不连续的，储存的只是相对位置，具体思路见下图，该图演示了一个静态链表在经历头插，插入，删除操作时其中数据的变化情况，我们可以很清楚的看到，静态链表的使用会造成空间的碎片，经过删除操作之后结点的顺序并不连续，所以指针域中所储存的数值根本就没有啥意义，只是相对位置罢了，理解透这一点剩下的操作就跟动态链表的操作完全一样</p><p><img src="/posts/50363/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230112012057.jpg"></p><p>此静态单链表的问题还是相当严重的，完全没有考虑输入错误的情况，默认所有操作完全合法，但是啊。。。。。如果真的要考虑用户输入这些东西的话我更宁愿用动态链表，如果只是比赛的话默认所有操作完全合法应该还是没问题的</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package leetcote;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    static int N = 1000;</span><br><span class="line">    static int e[] = new int[N];</span><br><span class="line">    static int ne[] = new int[N];</span><br><span class="line">    static int head = -1;</span><br><span class="line">    static int idx = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">            addToHead(i);</span><br><span class="line">        &#125;</span><br><span class="line">        print();</span><br><span class="line">        remove(2);</span><br><span class="line">        print();</span><br><span class="line">        addAtIndex(6,3);</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //头插法</span><br><span class="line">    //链表的逻辑顺序是不会变的，就是说永远能根据当前元素找到下一个元素，所以尾插法只是头指针的数值变不变而已</span><br><span class="line">    //绝对不要把idx当成判断链表大小的条件</span><br><span class="line">    static void addToHead(int x) &#123;</span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = head;</span><br><span class="line">        head = idx;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据下标返回数据</span><br><span class="line">    static int searchNum(int k) &#123;</span><br><span class="line">        int pos = head;</span><br><span class="line">        for (int i = 1; i &lt; k; i++)&#123;</span><br><span class="line">            pos = ne[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        return e[pos];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找数据返回下标（直接遍历？？？，不行，就算遍历你也不知道这到底是第几个元素，指针域的数据不能当作判断的标准）</span><br><span class="line">    static int searchIdx(int x) &#123;</span><br><span class="line">        int pos = head;</span><br><span class="line">        int num = -1;</span><br><span class="line">        do&#123;</span><br><span class="line">            num++;</span><br><span class="line">            if(e[pos] == x) &#123;</span><br><span class="line">                return num;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                pos = ne[pos];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;while(pos != -1);</span><br><span class="line"></span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //插入，先找前驱，再进行插入，可以直接使用上面的查找方法</span><br><span class="line">    //现在我更加怀疑学长的代码是有问题的</span><br><span class="line">    //现在可以十分确定我已经完全理解了静态链表，还是得靠自己实操画图~~~~~~，虽然过程真TM头疼</span><br><span class="line"></span><br><span class="line">    static void addAtIndex(int x, int k) &#123;</span><br><span class="line">        if (k == 0) &#123;</span><br><span class="line">            addToHead(x);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int pos = head;</span><br><span class="line">        for (int i = 0; i &lt; k - 1; i++) &#123;</span><br><span class="line">            pos = ne[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = ne[pos];</span><br><span class="line">        ne[pos] = idx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void remove(int k) &#123;</span><br><span class="line">        if (k == 0) &#123;</span><br><span class="line">            head = ne[head];</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int pos = head;</span><br><span class="line">            for (int i = 0; i &lt; k - 1; i++) &#123;</span><br><span class="line">                pos = ne[pos];</span><br><span class="line">            &#125;</span><br><span class="line">            ne[pos] = ne[ne[pos]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //打印数组中元素</span><br><span class="line">    static void print() &#123;</span><br><span class="line">        int pos = head;</span><br><span class="line">        while (pos != -1) &#123;</span><br><span class="line">            System.out.println(e[pos]);</span><br><span class="line">            pos = ne[pos];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ps:学长的代码是头插法，然后头插完之后的数据是5 4 3 2 1，插完之后再remove一个2，移除第二个元素，移除完之后的数据是5 4 3 1，感觉不对，如果是如果是移除第二个元素那么结构应该要么是5 3 2 1 要么是5 4 2 1 </p><p>这里附上学长的代码以供参考，万一是我错了嘞？？？</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">        using namespace std;</span><br><span class="line">        int n;</span><br><span class="line">        const int N = 1e5+10;</span><br><span class="line">        int head,e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line">        void init()</span><br><span class="line">        &#123;</span><br><span class="line">        head = -1;</span><br><span class="line">        idx = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void add_to_head(int x)</span><br><span class="line">        &#123;</span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = head;</span><br><span class="line">        head = idx;</span><br><span class="line">        idx++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void add(int k, int x)</span><br><span class="line">        &#123;</span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = ne[k];</span><br><span class="line">        ne[k] = idx;</span><br><span class="line">        idx++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void remove(int k)</span><br><span class="line">        &#123;</span><br><span class="line">        ne[k] = ne[ne[k]];</span><br><span class="line">        &#125;</span><br><span class="line">        int main()</span><br><span class="line">        &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        init();</span><br><span class="line">        for(int i = 1; i &lt;= n ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">        int x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        add_to_head(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = head ; i != -1; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">        cout &lt;&lt; e[i] &lt;&lt; &#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        puts(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">        remove(2);</span><br><span class="line"></span><br><span class="line">        for(int i = head ; i != -1; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">        cout &lt;&lt; e[i] &lt;&lt; &#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="静态双链表"><a href="#静态双链表" class="headerlink" title="静态双链表"></a>静态双链表</h2><p>这里我不再重新写一个静态双链表，用一个题目说明一切</p><p>[题目连接](<a href="https://www.luogu.com.cn/record/99490970">记录详情 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a>)</p><p><img src="/posts/50363/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230112161708.jpg"></p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class P1160 &#123;</span><br><span class="line">    static final int N = 101100;</span><br><span class="line">    static int e[] = new int[N];</span><br><span class="line">    static int l[] = new int[N];</span><br><span class="line">    static int r[] = new int[N];</span><br><span class="line">    static int head, tail, size, idx;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        inIt();</span><br><span class="line">        int n = sc.nextInt();</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            int k = sc.nextInt();</span><br><span class="line">            int p = sc.nextInt();</span><br><span class="line">            cr(i,k,p);</span><br><span class="line">        &#125;</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            int k = sc.nextInt();</span><br><span class="line">            remove(k);</span><br><span class="line">        &#125;</span><br><span class="line">        int s = 2;</span><br><span class="line">        int pos = r[head];</span><br><span class="line">        for (int i = 0; pos != 1; i++) &#123;</span><br><span class="line">            System.out.print(e[pos]+&quot; &quot;);</span><br><span class="line">            pos = r[pos];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static void inIt() &#123;</span><br><span class="line">        l[0] = -1;</span><br><span class="line">        r[0] = 2;</span><br><span class="line">        l[1] = 2;</span><br><span class="line">        r[2] = -1;</span><br><span class="line">        e[2] = 1;</span><br><span class="line">        l[2] = 0;</span><br><span class="line">        r[2] = 1;</span><br><span class="line">        head = 0;</span><br><span class="line">        tail = 1;</span><br><span class="line">        size = 1;</span><br><span class="line">        idx = 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void cr(int num, int x, int w) &#123;</span><br><span class="line">        //num = 2, x = 1, w = 1</span><br><span class="line">        e[idx] = num;</span><br><span class="line">        if (w == 1) &#123;</span><br><span class="line">            l[idx] = x+1;</span><br><span class="line">            r[idx] = r[x+1];</span><br><span class="line">            l[r[x+1]] = idx;</span><br><span class="line">            r[x+1] = idx;</span><br><span class="line">            size++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            r[idx] = x+1;</span><br><span class="line">            l[idx] = l[x+1];</span><br><span class="line">            r[l[x+1]] = idx;</span><br><span class="line">            l[x+1] = idx;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void remove(int x) &#123;</span><br><span class="line">        if((l[x + 1] == -1 &amp;&amp; r[x + 1] == -1) || x &lt;= 0 || x &gt; size) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            r[l[x+1]] = r[x+1];</span><br><span class="line">            l[r[x+1]] = l[x+1];</span><br><span class="line">            l[x+1] = -1;</span><br><span class="line">            r[x+1] = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及到链表，最好画图，除非熟练度够，这个题目特殊的地方在于元素与地址是一一对应的，我们将元素1<del>n,依次储存在数组的2</del>n+1,而且我们是添加完所有元素之后才对数组进行删除操作，也就是说，只要知道元素的值我们可以马上知到它位于链表的什么位置，一般对链表元素进行操作的时候都要找到他的前驱，通过前驱对元素进行操作，这个题目特殊就在于，我们只要知道元素的值，就能直接推出他在链表中的位置，所以删除操作是非常简单的，这应该也算是一种特殊情况，元素的值竟然跟他所处的位置一一对应，话说这个题目感觉也不太像真正的双链表。。。。。。。。总之，这是一种特殊情况，不需要找前驱的特殊情况</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>环形链表</title>
      <link href="/posts/51245.html"/>
      <url>/posts/51245.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h1><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/"></a></p><p><img src="/posts/51245/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102210240.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>我们定义一个快指针，定义一个慢指针，快指针走两步，慢指针走一步，如果链表中存在环，那么这两个指针一定会相遇，这时候我们再让快指针跟慢指针开始一步一步走，那么相遇的地方就是进入循环的地方（需要数学证明）</p><p>当两个指针相遇后，让快指针从头开始跟慢指针一起一步一步走，那么相遇的点一定是入口</p><p><img src="/posts/51245/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102212216.png"></p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode detectCycle(ListNode head) &#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            if (slow == fast) &#123;</span><br><span class="line">                ListNode index1 = fast;</span><br><span class="line">                ListNode index2 = head;</span><br><span class="line">                while (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                return index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希集合"><a href="#哈希集合" class="headerlink" title="哈希集合"></a>哈希集合</h3><p>施工中</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表相交</title>
      <link href="/posts/31522.html"/>
      <url>/posts/31522.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/"></a></p><p><img src="/posts/31522/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102204219.png" alt="微信截图_20230102204219"></p><p><img src="/posts/31522/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102204240.png"></p><p><img src="/posts/31522/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102204248.png"></p><p><img src="/posts/31522/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102204256.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>关键还是要明确这个相交链表的形状，如果相交，那么形状只有可能是一个y形，并且开口只能朝左，如果方向不一样我就要怀疑他是二叉树了，所以如果两个相交链表不一样长，那么只有可能是开头的部分不一样长，从相交点到尾部的长度一定一样（感觉自己在说一堆废话但是道理就是这个道理）</p><p>按照这个道理，我们可以先确定两个链表的长度，然后让长的链表先走，直到长链表剩下的长度跟短链表一样长，然后让长链表跟短链表一起走，（相交点只可能出现于这个部分），如果有交点，返回，如果没有交点，结束</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">        ListNode cur1 = headA;</span><br><span class="line">        int a = 0;</span><br><span class="line">        ListNode cur2 = headB;</span><br><span class="line">        int b = 0;</span><br><span class="line">        //确定a长度</span><br><span class="line">        while (cur1 != null) &#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">        //确定b长度</span><br><span class="line">        while (cur2 != null) &#123;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">            b++;</span><br><span class="line">        &#125;</span><br><span class="line">        //为了不改变链表结构</span><br><span class="line">        cur1 = headA;</span><br><span class="line">        cur2 = headB;</span><br><span class="line">        //确定差值</span><br><span class="line">        int cz = Math.abs(a-b);</span><br><span class="line">        //让长链表先走</span><br><span class="line">        if (a &gt; b) &#123;</span><br><span class="line">            for (int i = 0; i &lt; cz; i++) &#123;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (a &lt; b) &#123;</span><br><span class="line">            for (int i = 0; i &lt; cz; i++) &#123;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">//一起走，找交点</span><br><span class="line">        while (cur1 !=  cur2 &amp;&amp; cur2 != null &amp;&amp; cur1 != null) &#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">            if (cur1 == cur2 &amp;&amp; cur1 != null) &#123;</span><br><span class="line">                return cur1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur1;</span><br><span class="line">        //这个地方不可以改成null你可能会想，上面负责找交点的部分都没找到，为什么不可以返还null嘞？</span><br><span class="line">        //关键在于上面找焦点的部分工作的前提条件是第一个点，不是交点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希集合"><a href="#哈希集合" class="headerlink" title="哈希集合"></a>哈希集合</h3><p>施工中</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除链表的倒数第N个节点</title>
      <link href="/posts/52002.html"/>
      <url>/posts/52002.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="删除倒数第N个结点"><a href="#删除倒数第N个结点" class="headerlink" title="删除倒数第N个结点"></a>删除倒数第N个结点</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/"></a></p><p><img src="/posts/52002/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102202508.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="一般"><a href="#一般" class="headerlink" title="一般"></a>一般</h3><p>先确定链表长度，然后根据n的值在从前往后遍历，只不过这样就进行了两次扫描</p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><blockquote><p>&#96;&#96;</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummyhead = new ListNode();</span><br><span class="line">        dummyhead.next = head;</span><br><span class="line">        ListNode fast = dummyhead.next;</span><br><span class="line">        ListNode slow = dummyhead;</span><br><span class="line">        for (int i = 0; i &lt; n; i++ ) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(fast != null) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        return dummyhead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义两个指针一个fast，一个slow</p><p><img src="/posts/52002/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102203334.png"></p><p>先让快指针走n+1步</p><p><img src="/posts/52002/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102203342.png"></p><p>再让两个指针一起走直到快指针为null</p><p><img src="/posts/52002/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102203349.png"></p><p>这时满指针就是倒数第n个元素的前驱，进行标准操作即可</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>施工中ing</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两两交换链表中的结点</title>
      <link href="/posts/45642.html"/>
      <url>/posts/45642.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/"></a></p><p><img src="/posts/45642/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102190556.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>为啥我要先写递归法嘞，因为我自己最先写的就是递归法，渐渐发现递归的一些规律</p><p>首先现在发现的递归有两种，循环到最后一次就结束，还有一种是循环到最后一次后还要再往回走一遍，其实应该是都要往回走一遍的，毕竟函数进栈之后还要出栈对吧，但是我说的最后一次就结束是指往回的过程中没有操作，只是出栈，但是第二种的主要操作是在出栈的时候再执行，两种的区别是，一种在压栈的时候进行主要操作，一种是在出栈的时候进行主要操作，我写的是第一种</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">    //特判空链表和只有一个元素的链表</span><br><span class="line">        if (head == null || head.next == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建虚拟头节点，使用虚拟头节点对链表进行操作</span><br><span class="line">        ListNode dummyhead = new ListNode();</span><br><span class="line">        dummyhead.next = head;</span><br><span class="line">        swap(dummyhead, head);</span><br><span class="line">        return dummyhead.next;</span><br><span class="line">        //不能返回head，head已经被修改返回虚拟头节点的下一个节点也就是链表第一个节点</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ListNode swap(ListNode pre, ListNode now) &#123;</span><br><span class="line">    //如果当前节点为空，或者当前节点的下一个节点为空，返回前一个节点</span><br><span class="line">    //当前节点的下一个节点为空则说明该链表为奇数链表</span><br><span class="line">        if (now == null || now.next == null) &#123;</span><br><span class="line">            return pre;</span><br><span class="line">        &#125;</span><br><span class="line">        //关键，防止断链</span><br><span class="line">        ListNode temp = now.next.next;</span><br><span class="line">        //保证pre节点连接正确</span><br><span class="line">        ListNode cur = pre;</span><br><span class="line">        pre = pre.next.next;</span><br><span class="line">        pre.next = now;</span><br><span class="line">        now.next = temp;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        return swap(now, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉我的递归更像是循环，把整个操作看成许多个小节，每个小节的操作相同，关键是控制进入下一个循环的变量是啥谁是pre，谁是now。循环到最后一个小结修改完成，出栈<img src="/posts/45642/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102193133.png"></p><p>这个就是明显的主要操作在出栈时候的</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">//这里的head是头节点不是头指针</span><br><span class="line">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">    //特判空链表和单元素链表</span><br><span class="line">        if (head == null || head.next == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        //用new节点来记录当前节点处理完之后要连接的结点。</span><br><span class="line">        ListNode newNode = swapPairs(next.next);</span><br><span class="line">        next.next = head;</span><br><span class="line">        head.next = newNode;</span><br><span class="line"></span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/45642/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102201650.png"></p><p>用new来记录当前节点要连接的节点</p><h3 id="指针法"><a href="#指针法" class="headerlink" title="指针法"></a>指针法</h3><p>&#96;&#96;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虚拟头结点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummyNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (prev.next != <span class="literal">null</span> &amp;&amp; prev.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next.next; <span class="comment">// 缓存 next</span></span><br><span class="line">      prev.next = head.next;          <span class="comment">// 将 prev 的 next 改为 head 的 next</span></span><br><span class="line">      head.next.next = head;          <span class="comment">// 将 head.next(prev.next) 的next，指向 head</span></span><br><span class="line">      head.next = temp;               <span class="comment">// 将head 的 next 接上缓存的temp</span></span><br><span class="line">      prev = head;                    <span class="comment">// 步进1位</span></span><br><span class="line">      head = head.next;               <span class="comment">// 步进1位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/45642/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102202128.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻转链表</title>
      <link href="/posts/9249.html"/>
      <url>/posts/9249.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h1><p><a href="https://leetcode.cn/problems/reverse-linked-list/"></a></p><p><img src="/posts/9249/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102175824.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="指针法"><a href="#指针法" class="headerlink" title="指针法"></a>指针法</h3><p>​这个题目总体来说还是不难的，使用双指针法进行操作，但是不知道其他语言是咋样的，Java要使用三指针，要不然会断链。</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        if (head == null) &#123;//特判头节点为空的情况</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        ListNode now = head;</span><br><span class="line">        ListNode pre = null;</span><br><span class="line">        while (next != null) &#123;</span><br><span class="line">            now.next = pre;</span><br><span class="line">            pre = now;</span><br><span class="line">            now = next;</span><br><span class="line">            next = next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //循环完之后的情况见下图，还要对now进行一次操作之后再返回，因为执行循环结束之后now是独立的</span><br><span class="line">        now.next = pre;</span><br><span class="line">        head = now;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/9249/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102180554.png"></p><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>第一种递归，分小段进行类似循环的处理，在没有到最后一个的时候继续压栈，到最后一个的时候全部释放，链表在压栈的时候就已经修改完毕</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        return reverse(null, head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ListNode reverse(ListNode now, ListNode next) &#123;</span><br><span class="line">        if(next == null) &#123;</span><br><span class="line">            return now;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode temp = next.next;</span><br><span class="line">        next.next = now;</span><br><span class="line">        return reverse(next, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/9249/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102182630.png"></p><p>第二种递归</p><p>这种递归的方式给我的感觉像是子弹上膛，我们先从前往后把子弹一颗一颗的塞到弹匣里，塞满之后再从后往前的一颗一颗的对子弹进行操作，直到打完所有弹匣，</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        //递归终止条件是当前为空，或者下一个节点为空</span><br><span class="line">        //如果链表为空或者链表只有一个元素不会递归</span><br><span class="line">        if(head==null || head.next==null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = reverseList(head.next);</span><br><span class="line">        //cur永远是最后一个节点</span><br><span class="line">        //一次递归就对一个节点进行操作</span><br><span class="line">        //跟上一个递归解法不同的是，上个递归在到最后一个元素时链表便已经完成修改</span><br><span class="line">        //让当前节点下一个节点的下一个节点为当前节点，当前节点的下一个节点改为空节点</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = null;</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/9249/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102184955.png"></p><p><img src="/posts/9249/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102190324.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>707.设计链表</title>
      <link href="/posts/61137.html"/>
      <url>/posts/61137.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h1><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>[设计链表](<a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表 - 力扣（LeetCode）</a>)</p><p><img src="/posts/61137/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221222193145.jpg"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>经常用到的操作，<strong>设置中间变量</strong>，<strong>找前驱</strong>，<strong>标准操作</strong>（使用虚拟节点也是为了方便找前驱）</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//节点类</span><br><span class="line">class ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode()&#123;&#125;</span><br><span class="line">    ListNode(int val)&#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//单向链表</span><br><span class="line">//链表元素下标为[0-index)</span><br><span class="line">//链表大小为（0-index]  [1-index]</span><br><span class="line">class MyLinkedList &#123;</span><br><span class="line">    int size;</span><br><span class="line">    ListNode head;</span><br><span class="line">//构造方法</span><br><span class="line">    public MyLinkedList() &#123;</span><br><span class="line">        int size = 0;</span><br><span class="line">        head = new ListNode();</span><br><span class="line">    &#125;</span><br><span class="line">//获取节点元素</span><br><span class="line">    public int get(int index) &#123;//获取数值</span><br><span class="line">    //判断下标是否合法</span><br><span class="line">        if(index &lt; 0 || index &gt;= size)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        //设置中间变量</span><br><span class="line">            ListNode cur = head;</span><br><span class="line">            //寻找该节点</span><br><span class="line">//头节点——头指针，指向的下一个元素才是第一个节点，我们要找下标为0的节点其实就是头节点的下一个节点</span><br><span class="line">//时刻记住我们是在对头节点进行操作</span><br><span class="line">//这里的head节点相当于dummyhead,如果要查看n位置的节点，就移动n+1次</span><br><span class="line">            for(int i = 0; i &lt;= index; i++)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            return cur.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addAtHead(int val) &#123;//头插</span><br><span class="line">        addAtIndex(0,val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addAtTail(int val) &#123;//尾插</span><br><span class="line">        addAtIndex(size,val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addAtIndex(int index, int val) &#123;//根据下标插入</span><br><span class="line">        if(index &gt; size)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(index &lt; 0)&#123;//我觉得这里可以return</span><br><span class="line">            index = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        //只要下标合法，size++,所以链表大小为（0-index]  [1-index]</span><br><span class="line">        size++;</span><br><span class="line">        ListNode pred = head;</span><br><span class="line">//找前驱</span><br><span class="line">//这里的head节点相当于虚拟头节点，在第n个位置插入就移动n次</span><br><span class="line">        for(int i = 0; i &lt; index; i++)&#123;//细节，只要找到前一个就可以</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //需要插入的节点</span><br><span class="line">        ListNode toAdd = new ListNode(val);</span><br><span class="line">        //对前驱进行标准操作</span><br><span class="line">        toAdd.next = pred.next;</span><br><span class="line">        pred.next = toAdd;</span><br><span class="line">    &#125;</span><br><span class="line">//删除某位置的节点</span><br><span class="line">    public void deleteAtIndex(int index) &#123;</span><br><span class="line">    //判断是否合法</span><br><span class="line">        if(index &lt; 0 || index &gt;= size)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果合法，链表大小--；</span><br><span class="line">        size--;</span><br><span class="line">        //如果为0，则让头节点向前移动一位</span><br><span class="line">        //如果是循环链表，直接让头节点向前移动估计不行</span><br><span class="line">        if(index == 0)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果是头节点之外的其他节点，找前驱，进行标准操作</span><br><span class="line">        ListNode pred = head;</span><br><span class="line">        for(int i = 0; i &lt; index; i++)&#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pred.next = pred.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//节点类</span><br><span class="line">class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next,prev;//下一个上一个</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//双向链表（双向链表！=循环链表）</span><br><span class="line">class MyLinkedList &#123;</span><br><span class="line">    ListNode head,tail;//前驱，后继，相当于dummyhead</span><br><span class="line">    int size;//链表长度</span><br><span class="line"></span><br><span class="line">//构造方法</span><br><span class="line">    public MyLinkedList() &#123;</span><br><span class="line">        this.size = 0;</span><br><span class="line">        this.head = new ListNode(0);</span><br><span class="line">        this.tail = new ListNode(0);</span><br><span class="line">        //这一步非常关键，否则在加入头结点的操作中会出现null.next的错误！！！</span><br><span class="line">        //让头的后继，尾的前驱不为空，让两个节点相连形成一个双向链</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">//获取某位置的元素</span><br><span class="line">    public int get(int index) &#123;</span><br><span class="line">    //不合法返回-1</span><br><span class="line">        if(index &lt; 0 || index &gt;= size) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    //设置中间变量，对中间变量进行操作，毕竟头节点不能变对吧</span><br><span class="line">        ListNode cur = this.head;</span><br><span class="line">    //优化，如果离头近就从头往前找，如果离尾近就从头往后找</span><br><span class="line">        if (index &gt;= size / 2) &#123;</span><br><span class="line">            cur = tail;</span><br><span class="line">            for (int i = 0; i &lt; size - index; i++) &#123;</span><br><span class="line">                cur = cur.prev;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt;= index; i++) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">//头插法</span><br><span class="line">    public void addAtHead(int val) &#123;</span><br><span class="line">        addAtIndex(0,val);</span><br><span class="line">    &#125;</span><br><span class="line">//尾插法</span><br><span class="line">    public void addAtTail(int val) &#123;</span><br><span class="line">        addAtIndex(size,val);</span><br><span class="line">    &#125;</span><br><span class="line">//在对应位置插入节点</span><br><span class="line">    public void addAtIndex(int index, int val) &#123;</span><br><span class="line">    //判断下标是否合法</span><br><span class="line">        if (index &gt; size) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (index &lt; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    //如果下标合法</span><br><span class="line">        size++;</span><br><span class="line">    //设置中间变量</span><br><span class="line">        ListNode pre = this.head;</span><br><span class="line">    //寻找index的前驱，第一个节点的前驱就是头节点</span><br><span class="line">        for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">    //需要插入的节点</span><br><span class="line">        ListNode node = new ListNode(val);</span><br><span class="line">    //标准操作</span><br><span class="line">    //先让当前节点与两边节点产生联系</span><br><span class="line">        node.prev = pre;</span><br><span class="line">        node.next = pre.next;</span><br><span class="line">    //前驱下一个节点的前驱设置为当前节点</span><br><span class="line">        pre.next.prev = node;</span><br><span class="line">    //前驱的下一个节点设置为当前节点</span><br><span class="line">        pre.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">//删除指定位置的元素</span><br><span class="line">    public void deleteAtIndex(int index) &#123;</span><br><span class="line">    //判断下标是否合法</span><br><span class="line">        if (index &lt; 0 || index &gt;= size) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果下标合法</span><br><span class="line">        size--;</span><br><span class="line">        //设置中间变量</span><br><span class="line">        ListNode pre = this.head;</span><br><span class="line">        //寻找该位置前驱</span><br><span class="line">        for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">            pre =pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //标准操作</span><br><span class="line">        pre.next.next.prev = pre;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="line"> * MyLinkedList obj = new MyLinkedList();</span><br><span class="line"> * int param_1 = obj.get(index);</span><br><span class="line"> * obj.addAtHead(val);</span><br><span class="line"> * obj.addAtTail(val);</span><br><span class="line"> * obj.addAtIndex(index,val);</span><br><span class="line"> * obj.deleteAtIndex(index);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>收获还是挺大，事实再次证明只有真正动手实操才能真正掌握一门技术，光懂原理不实操是完全不行的</p><p>在对链表的操作中有很多都要涉及到对范围的判断，所以以后统一链表长度为[1-index]，链表元素的下标为[0-index)</p><p>重点理解，头指针跟头节点的区别，因为Java没有指针，只有引用数据类型，而且head还是用节点类进行创建的，但head并不是头节点，里面是没有数据的，他的的下一个节点才是头节点，而head相当于dummyhead或者头指针</p><p>而且我们的操作几乎都是建立在头指针上的，所以用了许多创建中间变量的方法保证头指针始终指向头节点</p><p>双向链表不等于循环链表，只要一直保证头指针指向第一个节点，尾指针指向最后一个节点就行，关于查找的优化操作需要注意范围的限制</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>203.移除链表元素</title>
      <link href="/posts/10614.html"/>
      <url>/posts/10614.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/posts/10614/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221222175350.png"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeElements(ListNode head, int val) &#123;</span><br><span class="line">        ListNode mid = new ListNode();</span><br><span class="line">        if(head == null)&#123;//似乎多余？？？</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        while(head.val == val &amp;&amp; head != null)&#123;</span><br><span class="line">            head = head.next;//转移头节点</span><br><span class="line">            if(head == null)&#123;</span><br><span class="line">                return head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = head;</span><br><span class="line">        while(mid.next != null)&#123;</span><br><span class="line">            if(mid.next.val == val)&#123;</span><br><span class="line">                mid.next = mid.next.next;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = mid.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缝缝补补做出</p><p>关键在第一个节点的操作上，因为我们删除一个节点是对这个节点的上一个节点进行操作</p><p>ps</p><p>1.如果节点头为空，直接返回</p><p>2.在第一节点特判时，如果为空，直接返回</p><p>3.创建中间变量对中间变量进行操作保证头节点一直是头节点</p><p>4.中间变量只是引用数据类型，会改变实际的值，但是head不变就可以</p><h2 id="大佬的思路——虚拟头节点"><a href="#大佬的思路——虚拟头节点" class="headerlink" title="大佬的思路——虚拟头节点"></a>大佬的思路——虚拟头节点</h2><p><strong>优势</strong>：在一般操作的情况下，我们删除或者增添节点的时候对头节点和其他节点的操作不同，如果使用头节点，那么我们可以使增删头节点的方式与其他节点相同，起到统一操作的作用</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeElements(ListNode head, int val) &#123;</span><br><span class="line">    //重要操作</span><br><span class="line">        ListNode dummyHead = new ListNode();</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode cur = dummyHead;</span><br><span class="line">        while(cur.next != null)&#123;</span><br><span class="line">            if(cur.next.val == val)&#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps:</p><p>不能返回原来的头节点，因为可能已经被删除（这里应该具体研究一下），<strong>返回cur.next</strong></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>让所有值不等于val的节点连接成一个新的节点</p><p>有点考逻辑，但是如果用一句话来形容的话——我来组成下一个节点，感觉像拼火车？？？</p><p>这个程序给我的感觉是先全部展开，再依次收拢</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeElements(ListNode head, int val) &#123;</span><br><span class="line">        if(head==null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next=removeElements(head.next,val);//</span><br><span class="line">        if(head.val==val)&#123;//特判头节点，返回的值一定为head,只不过主体部分已经修改完毕，不对</span><br><span class="line">        //判断当前节点的值是否等于val，如果是返回下一个节点，否则返回当前节点</span><br><span class="line">            return head.next;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/posts/54862.html"/>
      <url>/posts/54862.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="线性表的顺序储存结构"><a href="#线性表的顺序储存结构" class="headerlink" title="线性表的顺序储存结构"></a>线性表的顺序储存结构</h2><h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><p>​<img src="/posts/54862/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221222165127.png"></p><p>元素之间有序，不存在空位，第一个元素无前驱，最后一个元素无后继，其他每个元素有且只有一个前驱和后记，并且有限</p><h3 id="关键操作"><a href="#关键操作" class="headerlink" title="关键操作"></a>关键操作</h3><p><strong>赋值&amp;&amp;扩容</strong></p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void InitList(int data) &#123;//给线性表从0开始依次赋值</span><br><span class="line">    if(size==L.length)&#123;//如果满容，进行扩容</span><br><span class="line">        this.L= Arrays.copyOf(this.L,this.L.length*2);</span><br><span class="line">    &#125;</span><br><span class="line">    L[size++]=data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入元素，删除元素</strong></p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void remove(int key) &#123;//删除链表中的某个值</span><br><span class="line">    int index=this.search(key);</span><br><span class="line">    if(index==-1)&#123;</span><br><span class="line">        System.out.println(&quot;没找到要删除的数字&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=index;i&lt;size-1;i++)&#123;//将pos之后的元素集体左移</span><br><span class="line">        this.L[i]=this.L[i+1];</span><br><span class="line">    &#125;</span><br><span class="line">    this.size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void add(int pos, int data) &#123;//插入元素</span><br><span class="line">    if(pos&lt;0||pos&gt;=size)&#123;//如果插入坐标不在线性表坐标之内，抛出异常</span><br><span class="line">        System.out.println(&quot;坐标不合法&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        for(int i=size-1;i&gt;pos;i--)&#123;//坐标合法，将pos之后的（包括pos）元素右移，然后给pos位置的元素赋值</span><br><span class="line">            L[i]=L[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        L[pos]=data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优</strong></p><p>无需为元素之间的逻辑关系额外增加储存空间</p><p>科快速存取任意位置的表中元素</p><p><strong>缺</strong></p><p>插入和删除操作需要移动大量元素</p><p>容易造成储存空间的”碎片“</p><h3 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package List.shunxulist;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class MyArrylist implements SeqList&#123;</span><br><span class="line">    public int L[];</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    public MyArrylist()&#123;//构造函数，先构造一个长度为10的数组，如果长度不够，可以扩容</span><br><span class="line">        this.L=new int[10];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;//打印线性表中的所有元素</span><br><span class="line">        for(int i=0;i&lt;size;i++)&#123;</span><br><span class="line">            System.out.print(L[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void InitList(int data) &#123;//给线性表从0开始依次赋值</span><br><span class="line">        if(size==L.length)&#123;//如果满容，进行扩容</span><br><span class="line">            this.L= Arrays.copyOf(this.L,this.L.length*2);</span><br><span class="line">        &#125;</span><br><span class="line">        L[size++]=data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void add(int pos, int data) &#123;//插入元素</span><br><span class="line">        if(pos&lt;0||pos&gt;=size)&#123;//如果插入坐标不在线性表坐标之内，抛出异常</span><br><span class="line">            System.out.println(&quot;坐标不合法&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            for(int i=size-1;i&gt;pos;i--)&#123;//坐标合法，将pos之后的（包括pos）元素右移，然后给pos位置的元素赋值</span><br><span class="line">                L[i]=L[i-1];</span><br><span class="line">            &#125;</span><br><span class="line">            L[pos]=data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean contains(int toFind) &#123;//查找是否含有某个元素</span><br><span class="line">        for(int i=0;i&lt;this.size;i++)&#123;</span><br><span class="line">            if(toFind==L[i])&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int search(int toFind) &#123;//查找某个对应元素的坐标</span><br><span class="line">        for(int i=0;i&lt;this.size;i++)&#123;</span><br><span class="line">            if(toFind==L[i])&#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getPos(int pos) &#123;//查找某个坐标上的值</span><br><span class="line">        if(pos&lt;0||pos&gt;=size)&#123;</span><br><span class="line">            System.out.println(&quot;数组下标错误&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return this.L[pos];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stePos(int pos, int value) &#123;//将某个位置的值替换为某个值</span><br><span class="line">        if(pos&lt;0||pos&gt;=size)&#123;</span><br><span class="line">            System.out.println(&quot;数组下标错误&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        this.L[pos] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void remove(int key) &#123;//删除链表中的某个值</span><br><span class="line">        int index=this.search(key);</span><br><span class="line">        if(index==-1)&#123;</span><br><span class="line">            System.out.println(&quot;没找到要删除的数字&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=index;i&lt;size-1;i++)&#123;//将pos之后的元素集体左移</span><br><span class="line">            this.L[i]=this.L[i+1];</span><br><span class="line">        &#125;</span><br><span class="line">        this.size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int size() &#123;//获取链表长度</span><br><span class="line">        return this.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void clear() &#123;//重置链表</span><br><span class="line">        this.size=0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性表的链式储存结构"><a href="#线性表的链式储存结构" class="headerlink" title="线性表的链式储存结构"></a>线性表的链式储存结构</h2><p><img src="/posts/54862/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221222170215.png"></p><p>在链式储存中，每个元素除了储存该元素本身的信息之外，还需储存下一个元素的地址</p><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><p>头指针：链表中第一个节点的存储位置</p><p>头结点：单链表的第一个节点前附设一个结点，可不储存任何信息，头节点的指针域指向第一个节点的指针</p><p>ps:</p><p>1.头指针</p><p>头指针是指向链表的第一个节点的指针，若链表有头节点，则是指向头节点的指针</p><p>头指针具有表示作用，常用链表的名字作为头指针的名字</p><p>无论链表是否为空，头指针均不为空，头指针是链表的必要元素</p><p>2.头节点</p><p>存在头节点时，对第一元素节点前插入节点和删除第一节点与其他操作就统一了</p><p>头节点不一定是链表的必要元素</p><h3 id="关键操作-1"><a href="#关键操作-1" class="headerlink" title="关键操作"></a>关键操作</h3><p>&#96;&#96;</p><p>添加</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//头插法</span><br><span class="line">public void addFirst(int data)&#123;</span><br><span class="line">    Node node = new Node(data);//创建新节点</span><br><span class="line">    //注意理解我们这里是在什么对象的角度去进行操作的</span><br><span class="line">    if(this.head==null)&#123;//如果第一个节点是空的，复制给第一个节点</span><br><span class="line">        this.head = node;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //如果第一个节点不空，执行标准化操作</span><br><span class="line">        node.next = this.head;//新节点的指针域指向旧节点</span><br><span class="line">        this.head = node;//现在我们是下一个操作对象的新节点</span><br><span class="line">    &#125;</span><br><span class="line">    //跟C的思路好像有点不同</span><br><span class="line">    //开始回忆，C是创建新节点，把新节点的指针域赋值为旧节点的指针域（换屁股），然后把就节点的指针域赋值为当前节点（头插进屁股里）</span><br><span class="line">    this.usedSize++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>//为了节约时间直接把尾插法写在这里//这个尾插法不存粹，不够快，好处是可以跟这个头插法的代码一起用//原理是从第一个遍历到最后一个，然后再插入，比起存粹的尾插速度要慢很多，在数据大的时候public void addLast(int data)&#123;    //创建新节点    Node node = new Node(data);    if(this.head == null)&#123;        this.head = node;    &#125;else&#123;        Node cur = this.head;        while(cur.next!=null)&#123;            cur = cur.next;        &#125;        cur.next = node;    &#125;    this.usedSize++;&#125;`</code></pre><p>&#96;&#96;</p><p>插入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void addLast(int data)&#123;</span><br><span class="line">    //创建新节点</span><br><span class="line">    Node node = new Node(data);</span><br><span class="line">    if(this.head == null)&#123;</span><br><span class="line">        this.head = node;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        Node cur = this.head;</span><br><span class="line">        while(cur.next!=null)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    this.usedSize++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package List.lianshilist;</span><br><span class="line"></span><br><span class="line">public class Node &#123;</span><br><span class="line">    public int value;//储存数据</span><br><span class="line">    public Node next;//-&gt;next，储存下一个节点的地址</span><br><span class="line"></span><br><span class="line">    public Node (int value)&#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package List.lianshilist;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* 这个对象只用创建一次，为链表中的第一个元素，头指针为这个对象的对象名</span><br><span class="line">* 之后不断往里面添加节点类就可以，头节点不变（头插法的话）</span><br><span class="line">* 所以获取其他值很难，只能从第一个开始往后循环去找，时间复杂度为O（n）</span><br><span class="line">* 但是插入跟删除异常方便，而且不用担心内存问题</span><br><span class="line">* */</span><br><span class="line"></span><br><span class="line">import java.nio.channels.Pipe;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedList &#123;</span><br><span class="line">    public Node head;//head永远是第一个</span><br><span class="line">    public int usedSize;</span><br><span class="line"></span><br><span class="line">    //头插法</span><br><span class="line">    public void addFirst(int data)&#123;</span><br><span class="line">        Node node = new Node(data);//创建新节点</span><br><span class="line">        //注意理解我们这里是在什么对象的角度去进行操作的</span><br><span class="line">        if(this.head==null)&#123;//如果第一个节点是空的，复制给第一个节点</span><br><span class="line">            this.head = node;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //如果第一个节点不空，执行标准化操作</span><br><span class="line">            node.next = this.head;//新节点的指针域指向旧节点</span><br><span class="line">            this.head = node;//现在我们是下一个操作对象的新节点</span><br><span class="line">        &#125;</span><br><span class="line">        //跟C的思路好像有点不同</span><br><span class="line">        //开始回忆，C是创建新节点，把新节点的指针域赋值为旧节点的指针域（换屁股），然后把就节点的指针域赋值为当前节点（头插进屁股里）</span><br><span class="line">        this.usedSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //为了节约时间直接把尾插法写在这里</span><br><span class="line">    //这个尾插法不存粹，不够快，好处是可以跟这个头插法的代码一起用</span><br><span class="line">    //原理是从第一个遍历到最后一个，然后再插入，比起存粹的尾插速度要慢很多，在数据大的时候</span><br><span class="line">    public void addLast(int data)&#123;</span><br><span class="line">        //创建新节点</span><br><span class="line">        Node node = new Node(data);</span><br><span class="line">        if(this.head == null)&#123;</span><br><span class="line">            this.head = node;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            Node cur = this.head;</span><br><span class="line">            while(cur.next!=null)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        this.usedSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //打印单链表</span><br><span class="line">    public void myToString()&#123;</span><br><span class="line">        Node cur = this.head;//从第一个开始遍历</span><br><span class="line">        while(cur != null)&#123;</span><br><span class="line">            System.out.print(cur.value+&quot; &quot;);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //单链表的查找</span><br><span class="line">    public boolean contains(int key)&#123;</span><br><span class="line">        Node cur = this.head;</span><br><span class="line">        while(cur!=null)&#123;</span><br><span class="line">            if(cur.value == key)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取单链表的长度</span><br><span class="line">    public int length()&#123;</span><br><span class="line">        return this.usedSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获得插入位置的前区节点</span><br><span class="line">    //为什么要获取前驱节点，因为我们只有通过前驱节点的指针域才能访问我们要的那个节点</span><br><span class="line">    public Node getIndex(int pos)&#123;</span><br><span class="line">        Node cur = this.head;</span><br><span class="line">        int index = 0;</span><br><span class="line">        while(index++ != pos-1)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //插入节点任意位置插入，第一个数据节点为0号下标</span><br><span class="line">    public void insert(int pos,int data)&#123;</span><br><span class="line">        if(pos&lt;0||pos&gt;this.usedSize)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;插入位置不合法&quot;);</span><br><span class="line">            //这是一条我没学过的代码，异常抛出？为啥不用return勒</span><br><span class="line">            //猜测，如果return，那么会接着执行主程序的吓一条代码，这里是直接结束程序</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(pos == 0)&#123;</span><br><span class="line">            addFirst(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(pos == this.usedSize)&#123;</span><br><span class="line">            addLast(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node node = new Node(data);</span><br><span class="line">        Node prev = getIndex(pos);//获得插入位置的前驱节点</span><br><span class="line">        node.next = prev.next;</span><br><span class="line">        prev.next = node;</span><br><span class="line">        this.usedSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //清空链表</span><br><span class="line">    public void clear()&#123;</span><br><span class="line">        this.head = null;</span><br><span class="line">        //当head设置为null后，之后的节点对象都变成未被引用的对象，垃圾回收器会自动回收这些未被引用的对象</span><br><span class="line">        //C要创建两个指针，一个一个的释放内存一个储存当前位置，一个储存下一位置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>单链表机构在有频繁插入跟删除元素的条件下表现非常优秀，时间复杂度仅为O(1)，但查找比较费时，而且用了多余的储存空间去储存了元素之间的逻辑结构，但是不用担心储存空间的分配，元素个数不被限制</p><p>需要理解的是，<strong>单链表结构的操作对象是当前的元素</strong>，类比和尚滚佛珠，还有插入删除操作的顺序一定不可以错</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>剪刀石头布</title>
      <link href="/posts/18553.html"/>
      <url>/posts/18553.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剪刀石头布"><a href="#剪刀石头布" class="headerlink" title="剪刀石头布"></a>剪刀石头布</h1><p>​跟我这种垃圾想出来的代码完全不一样，我的思路是用循环链表存储人类输入的数据然后根据根据人类前几次输入的结果去进行输出，如果前面出的布多，就增加出现剪刀的可能性，如果出现的石头多，就增加出现布的可能性</p><p>​不得不说，我的可能太低级了，只不过这确实是我的第一思路，但是老师的思路显然也有缺陷，太过死板，如果知道背后逻辑肯定可以100%取胜，不过对不知道的人的赢面还是不错的，<strong>他的代码，是通过判断人类下一步更可能出什么</strong>，就是人出了剪刀之后更可能会出什么，人出了石头之后更可能会出什么，人出了布之后更可能会出什么，虽然我们只需要统计数据计算然后让计算机去执行计算就可以，我们可以用九个变量去储存计算机的逻辑部分，分别统计人出拳之后再出拳的概率即可，但是老师的代码在数据结构的安排上显然“更有意思”</p><p>​<img src="/posts/18553/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221222005836.jpg"></p><p>​但是在知道数据库时，人在不出错并且知道底层逻辑的情况下依然可以完胜计算机（没错，就是我）</p><p>​我想，如果让我改进这个算法我会保留随机性，如果出剪刀之后出石头的可能性大，就增加出布的可能性，把二维数组换成由结构体组成的二维数组，一个储存次数（int），一个储存可能性（double），需要解决的问题是，如何根据可能性去生成计算机要出的结果（这个属于实现方面比较简单），还有一个是怎么去计算每次人出拳后计算机出拳的可能性，这个是数学问题，不太好想（人出拳的可能性是多少，那我下一局出布的可能性是多少？人出拳的概率对我下一回合出拳胜率的影响，似乎涉及到统计学跟概率学。。。。。。cao）</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package computer;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class text &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        int memory[][] = new int[3][3];</span><br><span class="line">        int counter=0;//记录猜拳的回合数</span><br><span class="line">        int human;//记录人类本次出拳</span><br><span class="line">        int computer;//记录计算机出拳</span><br><span class="line">        int id;//记录人类上次出拳后，出拳次数最多的是那种</span><br><span class="line">        int max;//记录根据id推出的计算机出拳</span><br><span class="line">        int prev=0;//记录人类上一次出拳</span><br><span class="line"></span><br><span class="line">        while(true)&#123;</span><br><span class="line">            counter++;</span><br><span class="line">            System.out.printf(&quot;该你出拳了！请输入:0-石头；1-剪刀；2-布\n&quot;);</span><br><span class="line">            human= sc.nextInt();</span><br><span class="line">            if(human!=0&amp;&amp;human!=1&amp;&amp;human!=2)&#123;</span><br><span class="line">                System.out.println(&quot;输入不合法，请重新输入&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;//输入012以外的数据退出循环</span><br><span class="line">            //此处代码可让学生优化，若非合理输入，用户循环实现合理输入为止</span><br><span class="line">            if(counter&lt;=12) &#123;//前十回合，计算机随机出拳，统计数据</span><br><span class="line">                computer = (int)(Math.random()*3);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                id=0;//我出剪刀的几率高</span><br><span class="line">                if(memory[prev][id]&lt;memory[prev][1])id=1;//我出石头的几率高</span><br><span class="line">                if(memory[prev][id]&lt;memory[prev][2])id=2;//我出布的几率高</span><br><span class="line">                if(id==0)max=2;//出布</span><br><span class="line">                else if(id==1)max=0;//出剪刀</span><br><span class="line">                else max=1;//出石头</span><br><span class="line">                computer=max;</span><br><span class="line">            &#125;</span><br><span class="line">            output(human,computer);//输出出拳信息和胜负信息</span><br><span class="line">            memory[prev][human]++;</span><br><span class="line">            for(int i=0;i&lt;3;i++)&#123;</span><br><span class="line">                for(int j=0;j&lt;3;j++)&#123;</span><br><span class="line">                    System.out.print(memory[i][j]+&quot; &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">            prev=human;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void output(int human,int computer)&#123;</span><br><span class="line">        if(human==computer)&#123;</span><br><span class="line">            System.out.println(&quot;你和计算机本局打平啦！&quot;);</span><br><span class="line">            switch(human)&#123;</span><br><span class="line">                case 0:</span><br><span class="line">                System.out.println(&quot;你和计算机都出了石头！&quot;);break;</span><br><span class="line">                case 1:</span><br><span class="line">                System.out.println(&quot;你和计算机都出了剪刀！&quot;);break;</span><br><span class="line">                case 2:</span><br><span class="line">                System.out.println(&quot;你和计算机都出了布！&quot;);break;</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(human==0)//你出了石头，计算机不是石头</span><br><span class="line">        &#123;</span><br><span class="line">            if(computer==1)</span><br><span class="line">                System.out.printf(&quot;你赢啦!你的出拳是石头，计算机出拳是剪刀！\n&quot;);</span><br><span class="line">            else</span><br><span class="line">                System.out.printf(&quot;计算机赢啦！你的出拳是石头，计算机出拳是布！\n&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(human==1)//你出了剪刀，计算机不是剪刀</span><br><span class="line">        &#123;</span><br><span class="line">            if(computer==2)</span><br><span class="line">                System.out.printf(&quot;你赢啦!你的出拳是剪刀，计算机出拳是布！\n&quot;);</span><br><span class="line">            else</span><br><span class="line">                System.out.printf(&quot;计算机赢啦！你的出拳是剪刀，计算机出拳是石头！\n&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(human==2)//你出了布，计算机不是布</span><br><span class="line">        &#123;</span><br><span class="line">            if(computer==0)</span><br><span class="line">                System.out.printf(&quot;你赢啦!你的出拳是布，计算机出拳是石头！\n&quot;);</span><br><span class="line">            else</span><br><span class="line">                System.out.printf(&quot;计算机赢啦！你的出拳是布，计算机出拳是剪刀！\n&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 有趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/posts/46132.html"/>
      <url>/posts/46132.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式，是一种类型的<strong>设计模式</strong>，是一种<strong>创建型模式</strong>，提供了一种创建对象的方式</p><p>这种模式涉及到一个单一的类，<strong>该类负责创建自己的对象</strong>，同时<strong>确保只有单个对象被创建</strong>，这个类<strong>提供了一种访问其唯一对象的方式</strong>，可以直接访问，<strong>不需要实例化该类的对象</strong></p><p>注意</p><p>单例类只能有一个实例</p><p>单例类必须自己创建自己的唯一实例</p><p>单例类必须给其他所有对象提供这一实例</p><p>要保证一个类仅有一个实例，并提供一个访问它的全局访问点</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><strong>主要解决</strong>：一个全局使用的类频繁的创建与销毁</p><p><strong>何时使用</strong>：当你想控制实例数目，节省系统资源的时候</p><p><strong>主要方法</strong>：判断系统是否已经有这个单例，如果有则返回，如果没有则创建</p><p><strong>关键代码</strong>：构造函数是私有的</p><p><strong>应用实例</strong>：</p><p>一个班级只有一个班主任</p><p>多线程程序操作一个文件的时候会不可避免的出现多个进程或者线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行</p><p>一些设备管理器常常设计为单例模式，比如一个电脑的两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件</p><p><strong>使用场景</strong>：</p><p>要求生产唯一的序列号</p><p>WEB中的技术器，不用每次刷新都在数据库里加一次，先用单例缓存起来</p><p>创建的一个对象需要消耗的资源过多，比如I&#x2F;O与数据库的连接</p><p><strong>优点</strong>：</p><p>内存里只有一个实例，减少内存的开销</p><p>避免对资源的多重占用</p><p>缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们创建一个a类，a类有它的私有构造函数和本身的一个静态实例，a类提供了一个静态方法，供外界获取它的静态实例</p><p>&#96;&#96;&#x2F;&#x2F;创建一个Singleton类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SingleObject &#123;</span><br><span class="line">    //创建 SingleObject 的一个对象</span><br><span class="line">    private static SingleObject instance = new SingleObject();</span><br><span class="line">    //让构造函数为 private，这样该类就不会被实例化</span><br><span class="line">    private SingleObject()&#123;&#125;</span><br><span class="line">    //获取唯一可用的对象</span><br><span class="line">    public static SingleObject getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    public void showMessage()&#123;</span><br><span class="line">        System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SingletonPatternDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //不合法的构造函数</span><br><span class="line">        //编译时错误：构造函数 SingleObject() 是不可见的</span><br><span class="line">        //SingleObject object = new SingleObject();</span><br><span class="line">        //获取唯一可用的对象</span><br><span class="line">        SingleObject object = SingleObject.getInstance();            //显示消息</span><br><span class="line">        object.showMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过类中公有的静态方法调用该类的私有构造函数并返回该类从而达成只生成唯一可用对象的目的，并可通过该对象调用该类中的方法</p><h2 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h2><p>1.懒汉式，线程不安全</p><p><strong>是否lazy初始化</strong>：是</p><p><strong>是否多线程安全</strong>：否</p><p><strong>实现难度</strong>：易</p><p>描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁synchronized所以严格意义上它并不算单例模式</p><p>这种方式lazy loading很明显，不要求多线程安全，在多线程不能正常工作</p><p>实例</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance;//私有静态属性</span><br><span class="line">    private Singleton ()&#123;&#125;//私有构造方法</span><br><span class="line">    public static Singleton getInstance() &#123;//共有静态方法</span><br><span class="line">        if (instance == null) &#123;//如果没有就创建一个对象并返回</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;//返回现有对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.懒汉式，线程安全</p><p><strong>是否lazy初始化</strong>：是</p><p><strong>是否多线程安全</strong>：是</p><p><strong>实现难度</strong>：易</p><p>描述：这种方式具备很好的lazy loading，能够在多线程中很好的工作，但是效率很低，99%情况下不需要同步，优点，第一次调用才初始化，避免内存浪费，缺点，必须加锁synchronized才能保证单例，但是加锁会影响效率，getlnstance()的性能对应用程序不是很关键（该方法使用不太频繁）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance;//静态私有属性</span><br><span class="line">    private Singleton ()&#123;&#125;//私有构造方法</span><br><span class="line">    public static synchronized Singleton getInstance() &#123;//这一行的那个关键字我不懂</span><br><span class="line">        if (instance == null) &#123;//如果没有对象就创建一个并返回</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;//直接返回现有对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.饿汉式</p><p><strong>是否lazy初始化</strong>：否</p><p><strong>是否多线程安全</strong>：是</p><p><strong>实现难度</strong>：易</p><p>描述：这种方式比较常用，但容易产生垃圾对象。</p><p>优点：没有加锁，执行效率会提高。</p><p>缺点：类加载时就初始化，浪费内存</p><p>它基于class loader机制避免了多线程的同步问题，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式种大多时调用getlnstance方法，但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到lazy loading的效果</p><p>实例</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = new Singleton();//加载类是就进行初始化</span><br><span class="line">    private Singleton ()&#123;&#125;//私有构造方法</span><br><span class="line">    public static Singleton getInstance() &#123;静态共有方法，返回创建的对象</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…………………………………………这一段跟后面的一大段看不懂，不抄了，感觉够用了——目前</p><p>4.双检锁&#x2F;双重校验锁（DLC,即double-checked locking）</p><p><strong>JDK 版本：</strong>JDK1.5 起</p><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>较复杂</p><p><strong>描述：</strong>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance() 的性能对应用程序很关键。</p><p>………………………………………</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象工厂模式</title>
      <link href="/posts/56455.html"/>
      <url>/posts/56455.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式，是<strong>围绕一个超级工厂创建其他工厂</strong>，该超级工厂又称为其他工厂的工厂，属于创建型模式</p><p>在抽象工厂模式中，<strong>接口是负责创建一个相关对象的工厂</strong>，不需要显示指定他们的类，每个工厂都能按照工厂模式提供对象</p><p>个人理解：抽象工厂模式可以使用一个工厂创造器根据传递的信息创造出实现了超级工厂的子类工厂，子类工厂再根据传递的信息生成具体的类</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图</strong>：提供一个<strong>创建一系列相关或互相依赖对象的接口，而无需指定他们具体的类</strong></p><p><strong>主要解决</strong>：主要解决接口选择问题</p><p><strong>何时使用</strong>：在一个产品族里面，定义多个产品</p><p><strong>关键代码</strong>：在一个工厂里聚合多个同类产品</p><p><strong>优点</strong>：当一个产品族中的多个对象被设计成一起工作时，他能保证客户端始终只使用同一个产品族中的对象</p><p><strong>缺点</strong>：产品族扩展非常困难，要增加一个系列的某一产品时，既要在抽象的creator中加代码，又要在具体的类里加代码</p><p><img src="/posts/56455/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221220170600.jpg"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>1.为形状创建一个接口</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Shape &#123;</span><br><span class="line">    //为形状创建的接口</span><br><span class="line">    void draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.创建实现接口的实体类</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Circle implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;circle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Square implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;square&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Rectangle implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;retangle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.为颜色创建一个接口</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Color &#123;</span><br><span class="line">    public abstract void fill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.创建实现接口的实体类</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Blue implements Color&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fill() &#123;</span><br><span class="line">        System.out.println(&quot;blue&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Red implements Color &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void fill() &#123;</span><br><span class="line">        System.out.println(&quot;red&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Green implements Color&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void fill() &#123;</span><br><span class="line">        System.out.println(&quot;green&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.为两个颜色和对象创建抽象类来获取工厂</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractFactory &#123;</span><br><span class="line">//其实这里是否抽象无所谓，但是你不希望别人直接创建超级工厂吧，没意义对不对</span><br><span class="line">    //为Color和Shape对象创建抽象类来获取工厂</span><br><span class="line">    public abstract Color getColor(String color);</span><br><span class="line">    public abstract Shape getShape(String shape);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.创建抽象工厂类，急于给定信息生成实体类的对象</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ColorFactory extends AbstractFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Color getColor(String color) &#123;</span><br><span class="line">        if(color == null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if(color.equalsIgnoreCase(&quot;RED&quot;))&#123;</span><br><span class="line">            return new Red();</span><br><span class="line">        &#125; else if(color.equalsIgnoreCase(&quot;GREEN&quot;))&#123;</span><br><span class="line">            return new Green();</span><br><span class="line">        &#125; else if(color.equalsIgnoreCase(&quot;BLUE&quot;))&#123;</span><br><span class="line">            return new Blue();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Shape getShape(String shape) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ShpeFactory extends AbstractFactory&#123;</span><br><span class="line">    //创建扩展超级工厂类的工厂类，基于给定信息生成实体类的对象</span><br><span class="line">    @Override</span><br><span class="line">    public Color getColor(String color) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Shape getShape(String shape) &#123;</span><br><span class="line">        if(shape == null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;if(shape.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123;</span><br><span class="line">            return new Circle();</span><br><span class="line">        &#125; else if(shape.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123;</span><br><span class="line">            return new Rectangle();</span><br><span class="line">        &#125; else if(shape.equalsIgnoreCase(&quot;SQUARE&quot;))&#123;</span><br><span class="line">            return new Square();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.创建一个工厂创造器&#x2F;生成器类，通过传递形状或颜色信息来获取工厂</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FactoryProducer &#123;</span><br><span class="line">    //根据传递的信息去生产超级工厂的子类</span><br><span class="line">    public static AbstractFactory getFactory(String choice)&#123;</span><br><span class="line">        if(choice.equalsIgnoreCase(&quot;SHAPE&quot;))&#123;</span><br><span class="line">            return new ShpeFactory();</span><br><span class="line">        &#125; else if(choice.equalsIgnoreCase(&quot;COLOR&quot;))&#123;</span><br><span class="line">            return new ColorFactory();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8.使用工厂创造器来获取抽象工厂，通过传递类型信息来获取实体类的对象</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class text &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //获取形状工厂</span><br><span class="line">        AbstractFactory shapeFactory = FactoryProducer.getFactory(&quot;SHAPE&quot;);</span><br><span class="line">        //超级工厂类型可以接收所有实现他的子类，这里使用FactoryProducer，根据传递的信息返回实现了超级工厂的子类，用超级工厂接收由工厂制造器返回的子类工厂</span><br><span class="line">        //获取形状为 Circle 的对象</span><br><span class="line">        Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);</span><br><span class="line">//传递信息给子类工厂，获取相应对象</span><br><span class="line">        //调用 Circle 的 draw 方法</span><br><span class="line">        shape1.draw();</span><br><span class="line"></span><br><span class="line">        //获取形状为 Rectangle 的对象</span><br><span class="line">        Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);</span><br><span class="line"></span><br><span class="line">        //调用 Rectangle 的 draw 方法</span><br><span class="line">        shape2.draw();</span><br><span class="line"></span><br><span class="line">        //获取形状为 Square 的对象</span><br><span class="line">        Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);</span><br><span class="line"></span><br><span class="line">        //调用 Square 的 draw 方法</span><br><span class="line">        shape3.draw();</span><br><span class="line"></span><br><span class="line">        //获取颜色工厂</span><br><span class="line">        AbstractFactory colorFactory = FactoryProducer.getFactory(&quot;COLOR&quot;);</span><br><span class="line"></span><br><span class="line">        //获取颜色为 Red 的对象</span><br><span class="line">        Color color1 = colorFactory.getColor(&quot;RED&quot;);</span><br><span class="line"></span><br><span class="line">        //调用 Red 的 fill 方法</span><br><span class="line">        color1.fill();</span><br><span class="line"></span><br><span class="line">        //获取颜色为 Green 的对象</span><br><span class="line">        Color color2 = colorFactory.getColor(&quot;GREEN&quot;);</span><br><span class="line"></span><br><span class="line">        //调用 Green 的 fill 方法</span><br><span class="line">        color2.fill();</span><br><span class="line"></span><br><span class="line">        //获取颜色为 Blue 的对象</span><br><span class="line">        Color color3 = colorFactory.getColor(&quot;BLUE&quot;);</span><br><span class="line"></span><br><span class="line">        //调用 Blue 的 fill 方法</span><br><span class="line">        color3.fill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9.输出结果</p><p><img src="/posts/56455/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221220170447.jpg"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>光看还是不行，要自己实际操作才能掌握其中细节</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/posts/6013.html"/>
      <url>/posts/6013.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式，属于创建型模式，提供了一种创建对象的方式</p><p>在工厂模式中，我们在创建对象是不会对客户端暴露创建模式逻辑，并且通过<strong>使用一个共同接口来指向新创建的对象</strong></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图</strong>：定义一个创建对象的接口，<strong>让其子类自己决定实例化哪一个工厂类</strong>，工厂模式使其创建过程延迟到子类进行</p><p><strong>主要解决</strong>：接口的选择问题</p><p><strong>如何解决</strong>：让其子类实现工厂接口，返回的也是一个抽象的产品</p><p><strong>关键代码</strong>：创建过程在其子类执行</p><p><strong>优点</strong>：1.知道名字就可以创建对象2.扩展性高，向增加一个产品，只要增加一个工厂类就可以3.屏蔽产品的具体实现，调用者只关心产品的接口</p><p><strong>缺点</strong>：1.每次增加产品，都需要增加一个具体类和对象的实现工厂，使系统中的类成倍增加，一定程度上增加了系统的复杂度，同时也增加了系统对具体类的依赖</p><p><strong>注意事项</strong>：作为一种创建类的模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式，负载的对象适合使用工厂模式，而简单的对象只需要使用new即可，会增加系统的复杂度</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>将创建一个pizz接口，和实现pizz接口的实体类，下一步是定义工厂类pizzafactory ，text类使用该工厂来获取pizza对象，text将向工厂传递信息，以便获取它所需对象的类型</p><p><img src="/posts/6013/image-20221214144758004.png" alt="类图"></p><p>1.创建一个接口</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Pizza &#123;</span><br><span class="line">    public abstract void prepare();</span><br><span class="line">    public abstract void bake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.创建实现接口的实体类</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ChessePizza implements Pizza&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void prepare() &#123;</span><br><span class="line">        System.out.println(&quot;准备面饼\n准备奶酪&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void bake() &#123;</span><br><span class="line">        System.out.println(&quot;烤奶酪披萨\n20分钟后可以使用 奶酪披萨&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FruitPizza implements Pizza&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void prepare() &#123;</span><br><span class="line">        System.out.println(&quot;准备面饼\n准备水果&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void bake() &#123;</span><br><span class="line">        System.out.println(&quot;烤水果披萨\n20分钟后可以使用 水果披萨&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.创建一个工厂，生成基于给定信息的实体类的对象</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PizzaFactory &#123;</span><br><span class="line">    public Pizza creat(String type)&#123;</span><br><span class="line">        if(type.equals(&quot;水果披萨&quot;))&#123;</span><br><span class="line">            return new ChessePizza();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return new FruitPizza();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.使用该工厂，通过传递类型信息来获取实体类的对象</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PizzaFactory &#123;</span><br><span class="line">    public Pizza creat(String type)&#123;</span><br><span class="line">        if(type.equals(&quot;水果披萨&quot;))&#123;</span><br><span class="line">            return new ChessePizza();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return new FruitPizza();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子数组和</title>
      <link href="/posts/60313.html"/>
      <url>/posts/60313.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/posts/60313/20221219131354.jpg"></p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>施工中</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>施工中</p>]]></content>
      
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deemo</title>
      <link href="/posts/42771.html"/>
      <url>/posts/42771.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>top_img: <img src="/posts/42771/deemo.jpg"></p><h1 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h1><p><img src="/posts/42771/deemo.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java static 关键字</title>
      <link href="/posts/36808.html"/>
      <url>/posts/36808.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>static关键字</p><p>​写作业的时候出错了，原因是对static的理解有问题（或者说是根本没有理解），今天就来整理一下static的作用跟用法</p><p>​static作用，修饰类的成员变量，成员方法以及代码块，被修饰的成员被成为静态成员</p><p>​<strong>静态变量</strong>：<strong>使用static修饰的成员变量</strong>，成为静态变量或类变量，<strong>他被类的所有对象共享</strong>（类似全局变量，不被某个对象所独有，每个对象都可对其进行修改）</p><p>​<strong>静态方法</strong>：使用static修饰的在某个类中的方法可以被<strong>直接调用而不需要创建某个具体的对象</strong>（不需依附实例即可使用）。作用，不需要创建对象就可以使用的方法</p><p>​在静态方法中不能访问类的非静态成员变量和非静态类成员方法，但在非静态成员方法中是可以访问静态成员方法和变量</p><p>​<strong>静态代码块</strong>（优化程序性能）：代码块可分为普通代码块，构造代码块，和同步代码块（在多线程部分）执行的优先级高于非静态的初始代码块，他会在<strong>类的初始化时执行一次，执行完成便销毁</strong>，仅能初始化类变量，static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来依次执行每个static块，并且只会执行一次。无论类的对象被创建多少次，由于Java虚拟机只加载一次类，所以静态代码只会执行一次</p><p>我的误区：java中的变量不会影响到被修饰的东西的作用域，在Java中能影响访问权限的只有private，public，protect。虽然对于静态方法来说没有this，但是我们在非静态方法中能够通过this访问静态方法成员变量。</p><p>​this 关键字（指向调用对象本身）</p><p>​作用，解决成员变量和局部变量名称相同的问题</p><p>1.通过this关键字调用成员变量解决与局部变量名称冲突的问题</p><p>2.通过this关键字调用成员方法，方法用static修饰则不能用this（静态方法没有this，可随处调用，并不依附与某个对象）</p><p>3.this关键字调用的构造方法可以在一个构造方法中使用”this（[参数]，[参数],……）“的形式来调用构造方法S</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
