<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>多线程</title>
      <link href="/posts/24227.html"/>
      <url>/posts/24227.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623124242.png"></p><h1 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h1><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623124409.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623124504.png"></p><h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><ul><li><p>继承Thread类，重写 run方法</p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623125323.png"></p></li><li><p>实现Runnable接口</p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623130314.png"></p></li><li><p>Callable 和 Future</p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623130541.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623130738.png"></p></li></ul><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623130801.png"></p><h1 id="线程常见成员方法"><a href="#线程常见成员方法" class="headerlink" title="线程常见成员方法"></a>线程常见成员方法</h1><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623130917.png"></p><h1 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h1><p>线程的调度</p><ul><li>抢占式调度：随机</li><li>非抢占式调度：一条线程一次</li></ul><p>Java为抢占式调度，线程优先级越大，执行的次数越大，默认优先级为 5 </p><h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><p>当其他的非守护线程执行完毕之后，守护线程会陆续结束</p><h1 id="出让线程和插入线程"><a href="#出让线程和插入线程" class="headerlink" title="出让线程和插入线程"></a>出让线程和插入线程</h1><p>yield出让当前CPU的执行权，但是依然会再次抢夺</p><p>join将某个线程插入到某个线程之前</p><h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623133152.png"></p><h1 id="线程的安全问题"><a href="#线程的安全问题" class="headerlink" title="线程的安全问题"></a>线程的安全问题</h1><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623133512.png"></p><p>相同票出现多次</p><p>出现超出范围的票</p><p>线程在执行代码的时候随时有可能被抢走执行权</p><h1 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h1><p>把操作共享数据的代码锁起来</p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623133912.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623134054.png"></p><p>要注意锁的位置，锁对象唯一，可以用奔类的字节码对象</p><h1 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h1><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623134440.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623134843.png"></p><p>StringBulider线程不安全</p><p>StringBuffer线程安全</p><h1 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h1><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623135939.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623140250.png"></p><p>程序没有正常结束被锁未被打开剩余线程都被挡在外面</p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623140350.png"></p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623140541.png"></p><h1 id="生产者和消费者（等待唤醒机制）"><a href="#生产者和消费者（等待唤醒机制）" class="headerlink" title="生产者和消费者（等待唤醒机制）"></a>生产者和消费者（等待唤醒机制）</h1><p>消费者等待 -&gt; 唤醒</p><p>生产者等待 -&gt; 唤醒</p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623141143.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623141201.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623141700.png"></p><p>消费者代码实现</p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623141858.png"></p><p>生产者代码实现</p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623142115.png"></p><h1 id="阻塞队列实现等待唤醒机制"><a href="#阻塞队列实现等待唤醒机制" class="headerlink" title="阻塞队列实现等待唤醒机制"></a>阻塞队列实现等待唤醒机制</h1><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623142255.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623142337.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623142750.png"></p><h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623143044.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623143210.png"></p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623145215.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623145400.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623145440.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623145501.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623145625.png"></p><p>创建自定义线程池</p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623153747.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623153943.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623154259.png"></p><p><strong>最大并行数</strong></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623154856.png" alt="16"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>I/O</title>
      <link href="/posts/4748.html"/>
      <url>/posts/4748.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="I-x2F-O流"><a href="#I-x2F-O流" class="headerlink" title="I&#x2F;O流"></a>I&#x2F;O流</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>读取和存储数据的解决方案</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620181736.png"></p><h2 id="IO流的体系结构"><a href="#IO流的体系结构" class="headerlink" title="IO流的体系结构"></a>IO流的体系结构</h2><img src="/posts/4748/微信截图_20230620181845.png" style="zoom:50%;"><h4 id="底层输入输出流"><a href="#底层输入输出流" class="headerlink" title="底层输入输出流"></a>底层输入输出流</h4><p>在 Java 中，底层输入流（即直接从 I&#x2F;O 源读取数据的流）主要有以下几种：</p><ol><li><strong>FileInputStream</strong>：这是用于从文件中读取数据的输入流。它是一种字节流，可以用于读取任何类型的文件，包括二进制文件和文本文件。</li><li><strong>ByteArrayInputStream</strong>：这是用于从字节数组中读取数据的输入流。</li><li><strong>PipedInputStream</strong>：这是用于从与之相关联的 <code>PipedOutputStream</code> 中读取数据的输入流。</li><li><strong>ObjectInputStream</strong>：这是用于从输入流中读取对象的输入流。这个输入流必须连接到一个 <code>ObjectOutputStream</code>。</li><li><strong>SequenceInputStream</strong>：这是一种组合多个 <code>InputStreams</code> 的输入流，可以将两个或多个输入流串联起来，就像它们是一个单一的输入流一样。</li></ol><p>对应的，底层输出流（即直接写入到 I&#x2F;O 目标的流）主要有以下几种：</p><ol><li><strong>FileOutputStream</strong>：这是用于向文件中写入数据的输出流。它是一种字节流，可以用于写入任何类型的文件，包括二进制文件和文本文件。</li><li><strong>ByteArrayOutputStream</strong>：这是用于向字节数组中写入数据的输出流。</li><li><strong>PipedOutputStream</strong>：这是用于向与之相关联的 <code>PipedInputStream</code> 中写入数据的输出流。</li><li><strong>ObjectOutputStream</strong>：这是用于向输出流中写入对象的输出流。这个输出流必须连接到一个 <code>ObjectInputStream</code>。</li><li><strong>PrintStream</strong>：这是一种方便的输出流，用于写入表示各种数据值的方法。例如，它是 <code>System.out</code> 和 <code>System.err</code> 输出流的类型。</li></ol><p>每种输入流都有一种或多种对应的输出流，它们通常能处理相同类型的数据和相同的数据源或数据目标。例如，<code>FileInputStream</code> 和 <code>FileOutputStream</code> 都是用于处理文件的，而 <code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code> 都是用于处理对象的。</p><h4 id="高级流"><a href="#高级流" class="headerlink" title="高级流"></a>高级流</h4><p>与底层输入&#x2F;输出流对应的高级流是什么。高级流也被称为<strong>处理流</strong>，它的作用是对底层的输入&#x2F;输出流进行处理，提供更高级的读写功能。</p><ol><li><strong>BufferedInputStream</strong> 和 <strong>BufferedOutputStream</strong>：这两种流提供了缓冲区，可以减少实际的磁盘操作次数，从而提高读写的效率。</li><li><strong>DataInputStream</strong> 和 <strong>DataOutputStream</strong>：这两种流提供了可以读写基本数据类型（如 int、double、boolean 等）和 UTF 字符串的方法。</li><li><strong>ObjectInputStream</strong> 和 <strong>ObjectOutputStream</strong>：这两种流提供了可以读写序列化对象的方法。请注意，尽管 <code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code> 也可以看作是底层流，但它们同时也是高级流，因为它们处理的是对象而不是原始字节。</li><li><strong>InputStreamReader</strong> 和 <strong>OutputStreamWriter</strong>：这两种流提供了字节和字符之间的转换。<code>InputStreamReader</code> 是从字节输入流到字符输入流的桥梁，而 <code>OutputStreamWriter</code> 是从字符输出流到字节输出流的桥梁。它们允许程序以字符为单位读写数据，而不仅仅是字节。</li><li><strong>BufferedReader</strong> 和 <strong>BufferedWriter</strong>：这两种流也提供了缓冲区，和 <code>BufferedInputStream</code> 及 <code>BufferedOutputStream</code> 类似。但它们处理的是字符数据而不是字节数据。此外，<code>BufferedReader</code> 还提供了一种方便的方法 <code>readLine()</code>，用于读取一行数据。</li><li><strong>PrintWriter</strong>：这是一种方便的字符输出流，提供了各种 print 和 println 方法，用于写入各种数据值。</li></ol><p>以上就是一些常见的高级输入&#x2F;输出流。这些流通常包装一个底层流，对其进行处理，提供更高级的读写功能。</p><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><h4 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h4><p>这是所有字节输入流的父类，定义了字节输入流的基本共性功能方法，是一个抽象类</p><h5 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h5><p>从文件中读取字节</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620184032.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620184137.png"></p><p><strong>细节</strong></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620184932.png"></p><ul><li>读不到文件中的 -1</li></ul><p> <strong>循环读取</strong></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620185131.png"></p><p><strong>一次读取多个字节</strong></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620185857.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620190540.png"></p><p>改进版本</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620190700.png"></p><p>用来装饰其他的输入流，他可以从字节流中读取基本的数据类型</p><p>异常处理</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620191203.png"></p><p>防止资源没有被及时释放</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620191712.png"></p><h5 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h5><p><code>BufferedInputStream</code> 是一种具有缓冲功能的字节输入流，它的设计主要目的是为了提高读取数据的效率。在读取数据时，<code>BufferedInputStream</code> 会一次性读取较大的数据块（即填充其内部的缓冲区），然后我们可以逐个字节地从缓冲区中读取数据，避免频繁的物理磁盘操作。</p><ul><li><code>public BufferedInputStream(InputStream in)</code>：创建一个新的缓冲输入流，以从指定的底层输入流中读取数据。</li><li><code>public BufferedInputStream(InputStream in, int size)</code>：创建一个新的缓冲输入流，以从指定的底层输入流中读取数据，并具有指定的缓冲区大小。</li><li><code>public synchronized int read()</code>：从输入流中读取数据的下一个字节。</li><li><code>public synchronized int read(byte[] b, int off, int len)</code>：从输入流中读取一定数量的字节，并将其存储在缓冲区数组 <code>b</code> 中。</li></ul><p>使用 <code>BufferedInputStream</code> 时的注意事项：</p><ul><li>在进行大量的读取操作时，使用 <code>BufferedInputStream</code> 比使用非缓冲的 <code>InputStream</code> 更有效率，因为它可以减少实际的磁盘操作次数。</li><li>读取完数据后，应该及时关闭 <code>BufferedInputStream</code>。虽然垃圾回收器最终会关闭这些流，但是为了更好的资源管理和避免文件锁定等问题，我们应该在代码中显式关闭这些流。</li></ul><h5 id="DataInputStream"><a href="#DataInputStream" class="headerlink" title="DataInputStream"></a>DataInputStream</h5><p>用来装饰其它输入流，它可以从流中读取基本数据类型的数据。</p><h4 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h4><p>所有输出流的父类是抽象类</p><h5 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h5><p>向文件中写入字节</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620181955.png"></p><p><strong>使用</strong></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620182141.png"></p><p><strong>细节</strong></p><ul><li><p>参数可为文件路径或者File对象</p></li><li><p>如果文件不存在会创建新文件，必须保证父级路径存在</p></li><li><p>如果文件已经存在，构造方法会清空文件</p></li><li><p>write的方法参数为整数，实际上是写他ASCII码对应的字符</p></li><li><p>每次使用完之后都要释放资源</p></li></ul><p><strong>写出数据的</strong>3种方式</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620182921.png"></p><ul><li><p>如何换行</p><p>系统不同，换行符不同</p><p>windows \r\n</p><p>linux \n</p><p>mac \r</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620183608.png"></p></li><li><p>如何续写</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620183829.png"></p></li></ul><h5 id="BufferedOutputStream"><a href="#BufferedOutputStream" class="headerlink" title="BufferedOutputStream"></a>BufferedOutputStream</h5><p><code>BufferedOutputStream</code> 是一种具有缓冲功能的字节输出流。在写入数据时，<code>BufferedOutputStream</code> 不会每写入一个字节就直接写入到磁盘，而是首先将这些字节写入到内部的缓冲区。只有当缓冲区满，或者调用了 <code>flush()</code> 方法，或者关闭了流时，才会将缓冲区中的数据一次性写入到磁盘。这可以减少实际的磁盘操作次数，从而提高写入数据的效率。</p><p>一些常见的方法包括：</p><ul><li><code>public BufferedOutputStream(OutputStream out)</code>：创建一个新的缓冲输出流，以将数据写入指定的底层输出流。</li><li><code>public BufferedOutputStream(OutputStream out, int size)</code>：创建一个具有指定缓冲区大小的新缓冲输出流，以将数据写入特定的底层输出流。</li><li><code>public synchronized void write(int b)</code>：将指定的字节写入此缓冲的输出流。</li><li><code>public synchronized void write(byte[] b, int off, int len)</code>：将指定的字节从偏移量 <code>off</code> 开始的 <code>len</code> 字节写入此缓冲的输出流。</li><li><code>public synchronized void flush()</code>：清空此缓冲的输出流，确保所有缓冲的输出字节被写出到目标。</li></ul><p>使用 <code>BufferedOutputStream</code> 时的注意事项：</p><ul><li>在进行大量的写入操作时，使用 <code>BufferedOutputStream</code> 比使用非缓冲的 <code>OutputStream</code> 更有效率，因为它可以减少实际的磁盘操作次数。</li><li>在写入数据后，应该调用 <code>flush()</code> 方法，以确保所有的数据都被写入到磁盘。否则，如果缓冲区未满，那么缓冲区中的数据可能不会被写入到磁盘。</li><li>写入完数据后，应该及时关闭 <code>BufferedOutputStream</code>。虽然垃圾回收器最终会关闭这些流，但是为了更好的资源管理和避免文件锁定等问题，我们应该在代码中显式关闭这些流。</li></ul><h5 id="DataOutputStream"><a href="#DataOutputStream" class="headerlink" title="DataOutputStream"></a>DataOutputStream</h5><p>用来装饰其它输出流，它可以向流中写入基本数据类型的数据。</p><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>某种程度上来说，字符流跟字节流及其相似，包括他们的使用事项和包含的方法，不同的是字符流主要只针对字符</p><h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620191713.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622181610.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622181804.png"></p><p>以一开头，与英文区分开</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622182026.png"></p><p><strong>小结</strong></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622182101.png"></p><p><strong>Unicode</strong></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622182304.png"></p><p>空间浪费太过严重，所以使用UTF-8</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622182449.png"></p><p>UTF-8不是字符集，是Unicode字符集的一种编码方式</p><p><strong>为什么会有乱码</strong></p><p>读取数据时未读取完整个汉字</p><p>编码和解码的方式不统一</p><p><strong>避免乱码</strong>，不要使用字节流读取文本文件，解码编码使用同一个码表，同一个编码方式</p><p><strong>Java编码和解码的实现</strong></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622183217.png"></p><p>根据字符集的编码方式进行操作，主要针对纯文本文件</p><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><h5 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h5><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622205058.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622205115.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622205148.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622205540.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622205319.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622205453.png"></p><p>强转为Char</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622205659.png" alt="带参read"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622205940.png"></p><h5 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h5><p><code>BufferedReader</code> 是一种具有缓冲功能的字符输入流，它的工作原理和 <code>BufferedInputStream</code> 非常相似，不同的是 <code>BufferedReader</code> 是处理字符数据的。</p><p>一些常见的方法包括：</p><ul><li><code>public BufferedReader(Reader in)</code>：创建一个新的缓冲阅读器，以从指定的底层阅读器中读取数据。</li><li><code>public BufferedReader(Reader in, int size)</code>：创建一个新的缓冲阅读器，以从指定的底层阅读器中读取数据，并具有指定的缓冲区大小。</li><li><code>public String readLine()</code>：读取一个文本行。如果到达流末尾而没有更多的数据，则返回 null。</li><li><code>public int read(char[] cbuf, int off, int len)</code>：从输入流中读取一定数量的字符，并将其存储在缓冲区数组 <code>cbuf</code> 中。</li></ul><p>使用 <code>BufferedReader</code> 时的注意事项：</p><ul><li>在读取字符数据时，使用 <code>BufferedReader</code> 比使用非缓冲的 <code>Reader</code> 更有效率，特别是在读取大文件时。</li><li><code>BufferedReader</code> 提供了 <code>readLine()</code> 方法，这对于读取文本文件非常有用，因为这个方法可以一次读取一整行的数据。</li><li>读取完数据后，应该及时关闭 <code>BufferedReader</code>。虽然垃圾回收器最终会关闭这些流，但是为了更好的资源管理和避免文件锁定等问题，我们应该在代码中显式关闭这些流。</li></ul><h5 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h5><p>是从字节流到字符流的桥梁，它读取字节，并使用指定的字符集将其解码为字符。</p><p><code>InputStreamReader</code> 是字节流通向字符流的桥梁。它使用指定的字符集读取字节并将其解码为字符。它的字符集可以由名称指定，也可以明确地给定，或者可以接受平台默认的字符集。</p><p>底层原理：<code>InputStreamReader</code> 在内部使用了一个字节输入流和一个字符解码器。当我们读取字符时，<code>InputStreamReader</code> 首先使用字节输入流从磁盘读取字节，然后再使用字符解码器将这些字节解码为字符。</p><p>一些常见的方法包括：</p><ul><li><code>public InputStreamReader(InputStream in)</code>：创建一个使用默认字符集的 InputStreamReader。</li><li><code>public InputStreamReader(InputStream in, String charsetName)</code>：创建使用指定字符集的 InputStreamReader。</li><li><code>public int read()</code>：读取单个字符。</li><li><code>public int read(char[] cbuf, int off, int len)</code>：将字符读入数组的一部分。</li><li><code>public void close()</code>：关闭流。</li></ul><p>使用 <code>InputStreamReader</code> 时的注意事项：</p><ul><li>在创建 <code>InputStreamReader</code> 时，应明确指定字符集。如果不指定字符集，那么 <code>InputStreamReader</code> 将使用平台默认的字符集，这可能会导致在不同平台或者不同地区的计算机上出现不一致的行为。</li><li>读取完数据后，应该及时关闭 <code>InputStreamReader</code>。虽然垃圾回收器最终会关闭这些流，但是为了更好的资源管理和避免文件锁定等问题，我们应该在代码中显式关闭这些流。</li></ul><h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><h5 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h5><p>构造方法</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622210021.png"></p><p>成员方法</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622210046.png"></p><p>细节</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622210125.png"></p><p>底层原理</p><p>缓冲区：加速读取效率，不用每次都从原位置获取</p><p>虽然存在缓冲机制，但是并不是缓冲流</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622210849.png"></p><p>每次读取的时候，都先判断缓冲区中是否有数据可以读取，如果有，直接读取，如果没有从数据源中传输数据尽可能填满缓冲区，再从缓冲区读取</p><p><strong>字节流没有缓冲区</strong></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622211219.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622212215.png" alt="相当细节"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622212523.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622212553.png"></p><p>只有在缓冲区满的时候才能把数据送往目的地，但是flush可以直接把数据送往目的地，无论缓冲区是否为满</p><h5 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h5><p><code>BufferedWriter</code> 是一种具有缓冲功能的字符输出流，它的工作原理和 <code>BufferedOutputStream</code> 类似，不同的是 <code>BufferedWriter</code> 是处理字符数据的。</p><p>一些常见的方法包括：</p><ul><li><code>public BufferedWriter(Writer out)</code>：创建一个使用默认大小输出缓冲区的缓冲字符输出流。</li><li><code>public BufferedWriter(Writer out, int sz)</code>：创建一个新的缓冲字符输出流，使用给定大小的输出缓冲区。</li><li><code>public void write(int c)</code>：写入单个字符。</li><li><code>public void write(char[] cbuf, int off, int len)</code>：写入字符数组的一部分。</li><li><code>public void write(String s, int off, int len)</code>：写入字符串的一部分。</li><li><code>public void newLine()</code>：写入一个行分隔符。行分隔符字符串由系统属性 <code>line.separator</code> 定义，并且不一定是单个新行字符 (‘\n’)。</li><li><code>public void flush()</code>：刷新流。</li><li><code>public void close()</code>：关闭流，先刷新它。</li></ul><p>使用 <code>BufferedWriter</code> 时的注意事项：</p><ul><li>在写入字符数据时，使用 <code>BufferedWriter</code> 比使用非缓冲的 <code>Writer</code> 更有效率，特别是在写入大量数据时。</li><li>在写入数据后，应该调用 <code>flush()</code> 方法，以确保所有的数据都被写入到磁盘。否则，如果缓冲区未满，那么缓冲区中的数据可能不会被写入到磁盘。</li><li>写入完数据后，应该及时关闭 <code>BufferedWriter</code>。虽然垃圾回收器最终会关闭这些流，但是为了更好的资源管理和避免文件锁定等问题，我们应该在代码中显式关闭这些流。</li></ul><h5 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h5><p>是从字符流到字节流的桥梁，它使用指定的字符集将字符编码为字节。</p><p><code>OutputStreamWriter</code> 是一个字符流到字节流的桥梁。它使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以明确地给定，或者可以接受平台默认的字符集。</p><p>底层原理：<code>OutputStreamWriter</code> 在内部使用了一个字节输出流和一个字符编码器。当我们写入字符时，<code>OutputStreamWriter</code> 首先使用字符编码器将字符转换为字节，然后再使用字节输出流将这些字节写入到磁盘。</p><p>一些常见的方法包括：</p><ul><li><code>public OutputStreamWriter(OutputStream out)</code>：创建使用默认字符编码的 OutputStreamWriter。</li><li><code>public OutputStreamWriter(OutputStream out, String charsetName)</code>：创建使用指定字符集的 OutputStreamWriter。</li><li><code>public void write(int c)</code>：写入单个字符。</li><li><code>public void write(char[] cbuf, int off, int len)</code>：写入字符数组的一部分。</li><li><code>public void write(String str, int off, int len)</code>：写入字符串的一部分。</li><li><code>public void flush()</code>：刷新流。</li><li><code>public void close()</code>：关闭流。</li></ul><p>使用 <code>OutputStreamWriter</code> 时的注意事项：</p><ul><li>在创建 <code>OutputStreamWriter</code> 时，应明确指定字符集。如果不指定字符集，那么 <code>OutputStreamWriter</code> 将使用平台默认的字符集，这可能会导致在不同平台或者不同地区的计算机上出现不一致的行为。</li><li>在写入数据后，应该调用 <code>flush()</code> 方法，以确保所有的数据都被写入到磁盘。</li><li>写入完数据后，应该及时关闭 <code>OutputStreamWriter</code>。虽然垃圾回收器最终会关闭这些流，但是为了更好的资源管理和避免文件锁定等问题，我们应该在代码中显式关闭这些流。</li></ul><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622221034.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622221129.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622221235.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622221302.png"></p><h4 id="InputStreamReader-1"><a href="#InputStreamReader-1" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h4><h4 id="OutputStreamReader"><a href="#OutputStreamReader" class="headerlink" title="OutputStreamReader"></a>OutputStreamReader</h4><h3 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h3><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622222950.png"></p><p>序列化流，可以把Java对象写到本地文件当中，反序列化流，从本地文件中读取J序列化ava对象</p><h4 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h4><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622223712.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622223800.png"></p><h4 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h4><p>不能直接写出，要实现Serializable接口，此接口中没有抽象方法，为标记型接口，一旦实现这个接口，则表示当前对象可以被序列化</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622223226.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622223642.png"></p><p>细节</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622225814.png"></p><p>反序列化时，注意版本号</p><p>transient：瞬态关键字，不会把当前对象序列化到本地文件中</p><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><img src="/posts/4748/微信截图_20230622225909.png" style="zoom:50%;"><h4 id="PintStream"><a href="#PintStream" class="headerlink" title="PintStream"></a>PintStream</h4><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622230041.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622230149.png"></p><h4 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h4><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622230904.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622230924.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622230942.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622231602.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622230016.png"></p><h3 id="压缩流"><a href="#压缩流" class="headerlink" title="压缩流"></a>压缩流</h3><p>Java只能识别zip，其中为zipEntry对象</p><p>无需递归，只需循环，不断在循环中操作entry对象</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623101324.png" alt="解压"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623102200.png" alt="压缩单个文件"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623102824.png" alt="压缩文件夹"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623103344.png"></p><h3 id="Commons-io"><a href="#Commons-io" class="headerlink" title="Commons-io"></a>Commons-io</h3><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623103510.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623103611.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623103627.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623103959.png"></p><h3 id="Hutool"><a href="#Hutool" class="headerlink" title="Hutool"></a>Hutool</h3><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623104715.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623104737.png"></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h2><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620185627.png" alt="小文件"></p><p>一次只读写一个字节，非常慢，改进</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620190952.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622213400.png"></p><h2 id="文件加密"><a href="#文件加密" class="headerlink" title="文件加密"></a>文件加密</h2><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622213609.png"></p><h2 id="修改文件数据"><a href="#修改文件数据" class="headerlink" title="修改文件数据"></a>修改文件数据</h2><p><img src="/posts/4748/"><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622213641.png" alt="微信截图_20230622213641"></p><h2 id="转换流-1"><a href="#转换流-1" class="headerlink" title="转换流"></a>转换流</h2><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622221444.png" alt="按照指定的方案读入和按照指定的方法写出数据"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622221454.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622221840.png" alt="利用转换流，可以按指定编码格式读取数据"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622222154.png" alt="掌握"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622222326.png" alt="也被替代了"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622222456.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>File类</title>
      <link href="/posts/11300.html"/>
      <url>/posts/11300.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[toc]</p><h1 id="File"><a href="#File" class="headerlink" title="File"></a>File</h1><h2 id="File是什么"><a href="#File是什么" class="headerlink" title="File是什么"></a>File是什么</h2><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619125213.png"></p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619125246.png"></p><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><ol><li><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619125420.png"></p></li><li><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619125515.png"></p><p>最好使用构造方法拼接，手动拼接时 不同系统的分隔符可能不同</p></li><li><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619125649.png"></p></li></ol><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><h3 id="判断，获取"><a href="#判断，获取" class="headerlink" title="判断，获取"></a>判断，获取</h3><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619125830.png"></p><ul><li><p>length 只能获取文件的大小，单位是字节，其他单位可以处1024</p><p>如果需要获取一个文件夹的大小，需要把这个文件夹里所有文件的大小都累加在一起</p></li><li><p>getNmae 对于文件会获取到后缀</p></li></ul><h3 id="创建，删除"><a href="#创建，删除" class="headerlink" title="创建，删除"></a>创建，删除</h3><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619130736.png"></p><ul><li>creat如果当前路径表示文件已存在，返回false，且父级路径必须已经存在，只能创建文件，如果没有后缀名，则会创建一个没有后缀的文件</li><li>mkdirs能创建多级文件夹，也能创建单级文件夹，mkdir只能创建单级文件夹</li><li>delete只能删除空文件夹，和文件，且不走回收站</li></ul><h3 id="获取，遍历"><a href="#获取，遍历" class="headerlink" title="获取，遍历"></a>获取，遍历</h3><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619131829.png"></p><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619132055.png"></p><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619132111.png"></p><ul><li>listRoots 获取所有盘符</li><li>FilenameFilter文件名过滤器——函数式接口，匿名内部类，Lambda表达式，方法引用</li></ul><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619133235.png" alt="简单案例"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619125732.png"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619133417.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;P001\\aaa&quot;</span>);</span><br><span class="line">        file.mkdirs();</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file, <span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> src.createNewFile();</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619133429.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        check(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;P01/aaa&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f.isFile() &amp;&amp; f.getName().endsWith(<span class="string">&quot;.avi&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619133445.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\&quot;</span>);</span><br><span class="line">        findAVIs(src);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findAVIs</span><span class="params">(File src)</span> &#123;</span><br><span class="line">        File[] files = src.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (files == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> file.getName();</span><br><span class="line">                <span class="keyword">if</span> (name.endsWith(<span class="string">&quot;.avi&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(file);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                findAVIs(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619135827.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\aaa\\src&quot;</span>);</span><br><span class="line">        delete(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(File src)</span> &#123;</span><br><span class="line">        File[] files = src.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                file.delete();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                delete(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        src.delete();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619140849.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\aaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getLen</span><span class="params">(File src)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        File[] files = src.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                len += file.length();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                len += getLen(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619133458.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\aaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, Integer&gt; <span class="title function_">getLen</span><span class="params">(File src)</span> &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        File[] files = src.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> file.getName();</span><br><span class="line">                String[] arr = name.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (arr.length &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">endName</span> <span class="operator">=</span> arr[arr.length - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (hm.containsKey(endName)) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> hm.get(endName);</span><br><span class="line">                        count++;</span><br><span class="line">                        hm.put(endName, count);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        hm.put(endName, <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    HashMap&lt;String, Integer&gt; sonMap = getLen(file);</span><br><span class="line">                    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = sonMap.entrySet();</span><br><span class="line">                    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : entries) &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">                        <span class="keyword">if</span> (hm.containsKey(key)) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">count</span>  <span class="operator">=</span> hm.get(key);</span><br><span class="line">                            count = count + value;</span><br><span class="line">                            hm.put(key, count);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            hm.put(key, value);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hm;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java异常</title>
      <link href="/posts/48508.html"/>
      <url>/posts/48508.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[toc]</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618155444.png"></p><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618155507.png"></p><p><img src="/posts/48508/"><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618155613.png" alt="微信截图_20230618155613"></p><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618155710.png"></p><h3 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h3><p>红线划出，严重，大多数为语法错误</p><p>在编译阶段必须手动处理</p><p>提醒程序员检查本地信息</p><h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>编译阶段无法检查的异常，大多数为逻辑错误</p><h2 id="异常的作用"><a href="#异常的作用" class="headerlink" title="异常的作用"></a>异常的作用</h2><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618160316.png"></p><p>告诉我（控制台）出错了，跟告诉程序（返回值）出错了还是很不一样的</p><h2 id="异常的处理方式"><a href="#异常的处理方式" class="headerlink" title="异常的处理方式"></a>异常的处理方式</h2><ol><li>JVM默认处理方式</li></ol><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618161225.png"></p><ol start="2"><li><p>捕获异常</p><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618161328.png"></p></li></ol><p>​程序会继续进行</p><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618161505.png"></p><ol start="3"><li><p>细节</p><ul><li><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618161747.png"></p></li><li><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618162040.png"></p><p>多态</p><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618162137.png"></p></li><li><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618162326.png"></p></li><li><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618162430.png"></p></li></ul></li></ol><h2 id="异常中的常见方法"><a href="#异常中的常见方法" class="headerlink" title="异常中的常见方法"></a>异常中的常见方法</h2><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618162541.png"></p><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618163255.png"></p><p>手动抛出</p><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618163511.png"></p><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618163653.png"></p><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618163800.png"></p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618165432.png"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618163833.png"></p><p>抛出——告诉调用者错了</p><p>捕获——程序不能停止</p><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618165228.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>方法引用</title>
      <link href="/posts/9063.html"/>
      <url>/posts/9063.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><h2 id="什么是方法引用"><a href="#什么是方法引用" class="headerlink" title="什么是方法引用"></a>什么是方法引用</h2><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618104127.png"></p><ul><li>引用处必须是函数式接口</li><li>被引用方法必须已经存在</li><li>被引用方法的返回值需要跟抽象方法保持一直</li><li>被引用方法的功能要满足当前需求</li></ul><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618104528.png"></p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618104611.png"></p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618104737.png"></p><p>类名::方法名</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618104842.png"></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="引用静态方法"><a href="#引用静态方法" class="headerlink" title="引用静态方法"></a>引用静态方法</h3><ol><li><p>格式</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618104939.png"></p></li><li><p>使用案例</p><img src="/posts/9063/微信截图_20230618105259.png" style="zoom: 50%;"></li></ol><h3 id="引用成员方法"><a href="#引用成员方法" class="headerlink" title="引用成员方法"></a>引用成员方法</h3><ol><li><p>格式</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618105346.png"></p><p>注意：此处为对象，是引用了对象中的方法</p></li><li><p>使用案例</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618105926.png"></p></li></ol><ul><li><p>GUI界面中点击事件可以用方法引用写法</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618110525.png"></p><p>这个方法中的参数为函数式接口，使用方法引用，能让代码更加独立，可以改进之前的拼图游戏跟打字游戏，nice</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618110642.png"></p><p>现在我们应该可以写一个专门的监听事件的类，将方法写在类里面，然后使用引用方法</p></li></ul><h3 id="引用构造方法"><a href="#引用构造方法" class="headerlink" title="引用构造方法"></a>引用构造方法</h3><ol><li><p>格式</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618110829.png"></p></li><li><p>使用案例</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618110917.png"></p><p>如何手写Json解释器，呵呵呵</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618111121.png"></p><p>要重写构造方法，通过字符串来构造成员变量</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618111348.png"></p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618111403.png"></p></li></ol><h3 id="类名引用成员方法"><a href="#类名引用成员方法" class="headerlink" title="类名引用成员方法"></a>类名引用成员方法</h3><ol><li><p>格式</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618111946.png"></p></li><li><p>使用案例</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618112018.png"></p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618112154.png"></p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618112220.png"></p><ol start="3"><li><p>ps</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618112407.png"></p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618112433.png"></p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618112658.png"></p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618112732.png"></p></li></ol></li></ol><h3 id="引用数组的构造方法"><a href="#引用数组的构造方法" class="headerlink" title="引用数组的构造方法"></a>引用数组的构造方法</h3><ol><li>格式</li></ol><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618112749.png"></p><p>创建数组的类型必须跟流中的数据类型保持一致</p><ol start="2"><li><p>使用案例</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618112920.png"></p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618113431.png"></p></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618113531.png"></p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618113630.png"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618150941.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;aa,12&quot;</span>,<span class="string">&quot;bb,13&quot;</span>,<span class="string">&quot;cc,14&quot;</span>,<span class="string">&quot;dd,15&quot;</span>,<span class="string">&quot;jj,16&quot;</span>);</span><br><span class="line">        Student[] array = list.stream().map(Student::<span class="keyword">new</span>).toArray(Student[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    Student(String str) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = str.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">this</span>.age = Integer.parseInt(str.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">p4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;aa,12&quot;</span>,<span class="string">&quot;bb,13&quot;</span>,<span class="string">&quot;cc,14&quot;</span>,<span class="string">&quot;dd,15&quot;</span>,<span class="string">&quot;jj,16&quot;</span>);</span><br><span class="line">        Student[] array = list.stream().map(Student::<span class="keyword">new</span>).toArray(Student[]::<span class="keyword">new</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; list1 =  list.stream().map(Student::<span class="keyword">new</span>).collect(Collectors.toList());</span><br><span class="line">        String[] array1 = list1.stream().map(Student::getName).toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array1));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    Student(String str) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = str.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">this</span>.age = Integer.parseInt(str.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="string">&quot;-&quot;</span> + <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">p4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;aa,12&quot;</span>,<span class="string">&quot;bb,13&quot;</span>,<span class="string">&quot;cc,14&quot;</span>,<span class="string">&quot;dd,15&quot;</span>,<span class="string">&quot;jj,16&quot;</span>);</span><br><span class="line">        Student[] array = list.stream().map(Student::<span class="keyword">new</span>).toArray(Student[]::<span class="keyword">new</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; list1 =  list.stream().map(Student::<span class="keyword">new</span>).collect(Collectors.toList());</span><br><span class="line">        String[] array1 = list1.stream().map(Student::toString).toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Stream流</title>
      <link href="/posts/46403.html"/>
      <url>/posts/46403.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[toc]</p><h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>结合Lambda表达式，简化集合与数组的操作</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>获取流，操作，获得结果</p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618092148.png"></p><h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h3><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618092109.png"></p><ol><li><p>单列集合获取流</p><p>直接使用Collection接口中的Stream方法</p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618092248.png"></p></li><li><p>双列集合获取流</p><p>要先将集合中的元素转换为单独的key集合或者entrySet集合再进行操作</p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618093026.png"></p></li><li><p>数组获取流</p><p>使用Arrays中的静态方法</p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618093128.png"></p></li><li><p>零散数据获取流</p><p>直接使用Stream接口中的静态方法</p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618093224.png"></p></li></ol><h3 id="操作方法（中间方法）"><a href="#操作方法（中间方法）" class="headerlink" title="操作方法（中间方法）"></a>操作方法（中间方法）</h3><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618093351.png"></p><p>如果流中是对象，并且要进行去重的操作，那么要重写hashCode和equals方法</p><h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618093619.png" alt="去掉指定元素"></p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618093645.png" alt="获取前几个，跳过前几个"></p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618093713.png"></p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618093855.png" alt="去重，合并"></p><p>底层使用hashSet进行去重，合并时如果两个集合的类型不同，会使用他们的父类</p><h3 id="终结方法"><a href="#终结方法" class="headerlink" title="终结方法"></a>终结方法</h3><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618094027.png"></p><ul><li><p>forEach中的形参为Consumer，为一个函数式接口，可以改为Lambda表达式</p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618094545.png"></p></li></ul><p>​<img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618094600.png"></p><ul><li><p>toArray的空参返回类型为Object，含参为一个IntFunction也是一个函数式接口</p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618095018.png"></p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618095127.png"></p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618095306.png"></p></li><li><p>collect 可以传入一个函数，集合工具类中的函数把数据转换成集合</p><p>如果不加，则默认为Object数组</p></li></ul><h4 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h4><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618094847.png" alt="forEach"></p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618094912.png" alt="count"></p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618095232.png"></p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618095340.png"></p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618095606.png"></p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618095640.png"></p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618100025.png"></p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618100047.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; collect = hm.entrySet().stream().</span><br><span class="line">                filter(s -&gt; s.getValue() * <span class="number">10</span> &lt; w * <span class="number">2.5</span> / <span class="number">2</span>).</span><br><span class="line">                map(Map.Entry::getKey).</span><br><span class="line">                collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618141111.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">p4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Collections.addAll(list, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        Object[] a = list.stream().filter(s -&gt; s % <span class="number">2</span> == <span class="number">0</span>).toArray();</span><br><span class="line">        List&lt;Integer&gt; collect = list.stream().filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (integer % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618141933.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;aaa,23&quot;</span>, <span class="string">&quot;bbb,25&quot;</span>,<span class="string">&quot;ccc,26&quot;</span>,<span class="string">&quot;ddd,27&quot;</span>);</span><br><span class="line">        list.stream().forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (age &gt;= <span class="number">25</span>) &#123;</span><br><span class="line">                    map.put(name, age);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Map&lt;String, Integer&gt; collect = list.stream().filter(s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]) &gt;= <span class="number">25</span>).collect(Collectors.toMap(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        System.out.println(collect);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; collect1 = list.stream().filter(s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]) &gt;= <span class="number">25</span>).collect(Collectors.toMap(s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>], s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]));</span><br><span class="line">        System.out.println(collect1);</span><br></pre></td></tr></table></figure><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618141958.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Actor</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String age;</span><br><span class="line"></span><br><span class="line">    Actor(String str) &#123;</span><br><span class="line">        String[] a = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = a[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">this</span>.age = a[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">p4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; mal = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(mal, <span class="string">&quot;aa,25&quot;</span>,<span class="string">&quot;bb,23&quot;</span>,<span class="string">&quot;ccc,54&quot;</span>,<span class="string">&quot;ddd,60&quot;</span>,<span class="string">&quot;eee,55&quot;</span>,<span class="string">&quot;fff,51&quot;</span>,<span class="string">&quot;ccc,23&quot;</span>);</span><br><span class="line">        ArrayList&lt;String&gt; fal = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(fal, <span class="string">&quot;aa,25&quot;</span>,<span class="string">&quot;cd,23&quot;</span>,<span class="string">&quot;ef,54&quot;</span>,<span class="string">&quot;ak,60&quot;</span>,<span class="string">&quot;ac,55&quot;</span>,<span class="string">&quot;ac,51&quot;</span>,<span class="string">&quot;ad,23&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; ma = mal.stream().filter(s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>].length() == <span class="number">3</span>).limit(<span class="number">2</span>).collect(Collectors.toList());</span><br><span class="line">        List&lt;String&gt; fa = fal.stream().filter(s -&gt; s.charAt(<span class="number">0</span>) == <span class="string">&#x27;a&#x27;</span>).skip(<span class="number">1</span>).collect(Collectors.toList());</span><br><span class="line">        List&lt;String&gt; list = Stream.concat(ma.stream(), fa.stream()).collect(Collectors.toList());</span><br><span class="line">        List&lt;Actor&gt; ans = list.stream().map(Actor::<span class="keyword">new</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java双列集合</title>
      <link href="/posts/31756.html"/>
      <url>/posts/31756.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[toc]</p><h1 id="Java双列集合"><a href="#Java双列集合" class="headerlink" title="Java双列集合"></a>Java双列集合</h1><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617144233.png"></p><h2 id="双列集合的特点"><a href="#双列集合的特点" class="headerlink" title="双列集合的特点"></a>双列集合的特点</h2><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617142141.png"></p><h2 id="常见API"><a href="#常见API" class="headerlink" title="常见API"></a>常见API</h2><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617142252.png"></p><ul><li>put方法，既可添加，也可覆盖，添加时如果键存在，那么会把原来的值覆盖并返回，如果不存在，返回null</li><li>remove 根据键移除对应键值对</li><li>clear 直接清空</li><li>判断是否包含某键，判断是否包含某值 contains key or value</li><li>keySet（）：返回一个键集合<ul><li>语法：Set<K> keySet()</K></li></ul></li><li>entrySet（）：返回一个键值对集合<ul><li>语法：Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</li></ul></li></ul><h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><h3 id="1-键找值"><a href="#1-键找值" class="headerlink" title="1. 键找值"></a>1. 键找值</h3><p>使用 keySet方法将键提出为一个单列集合，遍历单列集合，找出对应值</p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617143245.png"></p><h3 id="2-键值对"><a href="#2-键值对" class="headerlink" title="2. 键值对"></a>2. 键值对</h3><p>通过EntrySet方法获取Entry对象来进行遍历</p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617143712.png"></p><h3 id="3-lambda表达式"><a href="#3-lambda表达式" class="headerlink" title="3. lambda表达式"></a>3. lambda表达式</h3><p>在forEach方法中使用Lambda表达式</p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617144034.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617144132.png"></p><h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><strong>特点</strong></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617144331.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617144500.png"></p><p><strong>底层原理</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>看源码之前需要了解的一些内容</span><br><span class="line"></span><br><span class="line">Node&lt;K,V&gt;[] table   哈希表结构中数组的名字</span><br><span class="line"></span><br><span class="line">DEFAULT_INITIAL_CAPACITY：   数组默认长度<span class="number">16</span></span><br><span class="line"></span><br><span class="line">DEFAULT_LOAD_FACTOR：        默认加载因子<span class="number">0.75</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HashMap里面每一个对象包含以下内容：</span><br><span class="line">数组中的对象要分情况进行讨论</span><br><span class="line"><span class="number">1.1</span> 链表中的键值对对象</span><br><span class="line">    包含：  </span><br><span class="line"><span class="type">int</span> hash;         <span class="comment">//键的哈希值</span></span><br><span class="line">            <span class="keyword">final</span> K key;      <span class="comment">//键</span></span><br><span class="line">            V value;          <span class="comment">//值</span></span><br><span class="line">            Node&lt;K,V&gt; next;   <span class="comment">//下一个节点的地址值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.2</span> 红黑树中的键值对对象</span><br><span class="line">包含：</span><br><span class="line"><span class="type">int</span> hash;         <span class="comment">//键的哈希值</span></span><br><span class="line">            <span class="keyword">final</span> K key;      <span class="comment">//键</span></span><br><span class="line">            V value;          <span class="comment">//值</span></span><br><span class="line">            TreeNode&lt;K,V&gt; parent;  <span class="comment">//父节点的地址值</span></span><br><span class="line">TreeNode&lt;K,V&gt; left;<span class="comment">//左子节点的地址值</span></span><br><span class="line">TreeNode&lt;K,V&gt; right;<span class="comment">//右子节点的地址值</span></span><br><span class="line"><span class="type">boolean</span> red;<span class="comment">//节点的颜色</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>添加元素</span><br><span class="line">HashMap&lt;String,Integer&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">hm.put(<span class="string">&quot;aaa&quot;</span> , <span class="number">111</span>);</span><br><span class="line">hm.put(<span class="string">&quot;bbb&quot;</span> , <span class="number">222</span>);</span><br><span class="line">hm.put(<span class="string">&quot;ccc&quot;</span> , <span class="number">333</span>);</span><br><span class="line">hm.put(<span class="string">&quot;ddd&quot;</span> , <span class="number">444</span>);</span><br><span class="line">hm.put(<span class="string">&quot;eee&quot;</span> , <span class="number">555</span>);</span><br><span class="line"></span><br><span class="line">添加元素的时候至少考虑三种情况：</span><br><span class="line"><span class="number">2.1</span>数组位置为<span class="literal">null</span></span><br><span class="line"><span class="number">2.2</span>数组位置不为<span class="literal">null</span>，键不重复，挂在下面形成链表或者红黑树</span><br><span class="line"><span class="number">2.3</span>数组位置不为<span class="literal">null</span>，键重复，元素覆盖</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数一：键</span></span><br><span class="line"><span class="comment">//参数二：值</span></span><br><span class="line"><span class="comment">//返回值：被覆盖元素的值，如果没有覆盖，返回null</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用键计算出对应的哈希值，再把哈希值进行一些额外的处理</span></span><br><span class="line"><span class="comment">//简单理解：返回值就是返回键的哈希值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数一：键的哈希值</span></span><br><span class="line"><span class="comment">//参数二：键</span></span><br><span class="line"><span class="comment">//参数三：值</span></span><br><span class="line"><span class="comment">//参数四：如果键重复了是否保留</span></span><br><span class="line"><span class="comment">//   true，表示老元素的值保留，不会覆盖</span></span><br><span class="line"><span class="comment">//   false，表示老元素的值不保留，会进行覆盖</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个局部变量，用来记录哈希表中数组的地址值。</span></span><br><span class="line">    <span class="comment">//成员变量储存在堆中，而局部变量在栈中，使用局部变量，提升效率</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line"></span><br><span class="line"><span class="comment">//临时的第三方变量，用来记录键值对对象的地址值</span></span><br><span class="line">        Node&lt;K,V&gt; p;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//表示当前数组的长度</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示索引</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把哈希表中数组的地址值，赋值给局部变量tab</span></span><br><span class="line">tab = table; <span class="comment">// 原数组</span></span><br><span class="line">n = tab.length <span class="comment">// 当前数组长度</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || n == <span class="number">0</span>)&#123;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//1.如果当前是第一次添加数据，底层会创建一个默认长度为16，加载因子为0.75的数组</span></span><br><span class="line"><span class="comment">//2.如果不是第一次添加数据，会看数组中的元素是否达到了扩容的条件</span></span><br><span class="line"><span class="comment">//如果没有达到扩容条件，底层不会做任何操作</span></span><br><span class="line"><span class="comment">//如果达到了扩容条件，底层会把数组扩容为原先的两倍，并把数据全部转移到新的哈希表中</span></span><br><span class="line">tab = resize();</span><br><span class="line"><span class="comment">//表示把当前数组的长度赋值给n</span></span><br><span class="line">            n = tab.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拿着数组的长度跟键的哈希值进行计算，计算出当前键值对对象，在数组中应存入的位置</span></span><br><span class="line">i = (n - <span class="number">1</span>) &amp; hash;<span class="comment">//index</span></span><br><span class="line"><span class="comment">//获取数组中对应元素的数据</span></span><br><span class="line">p = tab[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="comment">//底层会创建一个键值对对象，直接放到数组当中</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            K k;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等号的左边：数组中键值对的哈希值</span></span><br><span class="line"><span class="comment">//等号的右边：当前要添加键值对的哈希值</span></span><br><span class="line"><span class="comment">//如果键不一样，此时返回false</span></span><br><span class="line"><span class="comment">//如果键一样，返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> p.hash == hash;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (b1 &amp;&amp; ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">                e = p;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)&#123;</span><br><span class="line"><span class="comment">//判断数组中获取出来的键值对是不是红黑树中的节点</span></span><br><span class="line"><span class="comment">//如果是，则调用方法putTreeVal，把当前的节点按照红黑树的规则添加到树当中。</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果从数组中获取出来的键值对不是红黑树中的节点</span></span><br><span class="line"><span class="comment">//表示此时下面挂的是链表</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//此时就会创建一个新的节点，挂在下面形成链表</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//判断当前链表长度是否超过8，如果超过8，就会调用方法treeifyBin</span></span><br><span class="line"><span class="comment">//treeifyBin方法的底层还会继续判断</span></span><br><span class="line"><span class="comment">//判断数组的长度是否大于等于64</span></span><br><span class="line"><span class="comment">//如果同时满足这两个条件，就会把这个链表转成红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//e：  0x0044  ddd  444</span></span><br><span class="line"><span class="comment">//要添加的元素： 0x0055   ddd   555</span></span><br><span class="line"><span class="comment">//如果哈希值一样，就会调用equals方法比较内部的属性值是否相同</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果e为null，表示当前不需要覆盖任何元素</span></span><br><span class="line"><span class="comment">//如果e不为null，表示当前的键是一样的，值会被覆盖</span></span><br><span class="line"><span class="comment">//e:0x0044  ddd  555</span></span><br><span class="line"><span class="comment">//要添加的元素： 0x0055   ddd   555</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等号的右边：当前要添加的值</span></span><br><span class="line"><span class="comment">//等号的左边：0x0044的值</span></span><br><span class="line">e.value = value;</span><br><span class="line">&#125;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//threshold：记录的就是数组的长度 * 0.75，哈希表的扩容时机  16 * 0.75 = 12</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)&#123;</span><br><span class="line"> resize();</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//表示当前没有覆盖任何元素，返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>练习</strong></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617144540.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617144552.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617145423.png"></p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617145713.png"></p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p><strong>特点</strong></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617151951.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617153028.png"></p><p><strong>底层原理</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>TreeMap中每一个节点的内部属性</span><br><span class="line">K key;<span class="comment">//键</span></span><br><span class="line">V value;<span class="comment">//值</span></span><br><span class="line">Entry&lt;K,V&gt; left;<span class="comment">//左子节点</span></span><br><span class="line">Entry&lt;K,V&gt; right;<span class="comment">//右子节点</span></span><br><span class="line">Entry&lt;K,V&gt; parent;<span class="comment">//父节点</span></span><br><span class="line"><span class="type">boolean</span> color;<span class="comment">//节点的颜色</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>TreeMap类中中要知道的一些成员变量</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMap</span>&lt;K,V&gt;&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//比较器对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line"><span class="comment">//集合的长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>空参构造</span><br><span class="line"><span class="comment">//空参构造就是没有传递比较器对象</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span> &#123;</span><br><span class="line">        comparator = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>带参构造</span><br><span class="line"><span class="comment">//带参构造就是传递了比较器对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>添加元素</span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> put(key, value, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">参数一：键</span><br><span class="line">参数二：值</span><br><span class="line">参数三：当键重复的时候，是否需要覆盖值</span><br><span class="line"><span class="literal">true</span>：覆盖</span><br><span class="line"><span class="literal">false</span>：不覆盖</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> V <span class="title function_">put</span><span class="params">(K key, V value, <span class="type">boolean</span> replaceOld)</span> &#123;</span><br><span class="line"><span class="comment">//获取根节点的地址值，赋值给局部变量t</span></span><br><span class="line">        Entry&lt;K,V&gt; t = root;</span><br><span class="line"><span class="comment">//判断根节点是否为null</span></span><br><span class="line"><span class="comment">//如果为null，表示当前是第一次添加，会把当前要添加的元素，当做根节点</span></span><br><span class="line"><span class="comment">//如果不为null，表示当前不是第一次添加，跳过这个判断继续执行下面的代码</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//方法的底层，会创建一个Entry对象，把他当做根节点</span></span><br><span class="line">            addEntryToEmptyMap(key, value);</span><br><span class="line"><span class="comment">//表示此时没有覆盖任何的元素</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//表示两个元素的键比较之后的结果</span></span><br><span class="line">        <span class="type">int</span> cmp;</span><br><span class="line"><span class="comment">//表示当前要添加节点的父节点</span></span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示当前的比较规则</span></span><br><span class="line"><span class="comment">//如果我们是采取默认的自然排序，那么此时comparator记录的是null，cpr记录的也是null</span></span><br><span class="line"><span class="comment">//如果我们是采取比较去排序方式，那么此时comparator记录的是就是比较器</span></span><br><span class="line">        Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;</span><br><span class="line"><span class="comment">//表示判断当前是否有比较器对象</span></span><br><span class="line"><span class="comment">//如果传递了比较器对象，就执行if里面的代码，此时以比较器的规则为准</span></span><br><span class="line"><span class="comment">//如果没有传递比较器对象，就执行else里面的代码，此时以自然排序的规则为准</span></span><br><span class="line">        <span class="keyword">if</span> (cpr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = cpr.compare(key, t.key);</span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> t.value;</span><br><span class="line">                    <span class="keyword">if</span> (replaceOld || oldValue == <span class="literal">null</span>) &#123;</span><br><span class="line">                        t.value = value;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> oldValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//把键进行强转，强转成Comparable类型的</span></span><br><span class="line"><span class="comment">//要求：键必须要实现Comparable接口，如果没有实现这个接口</span></span><br><span class="line"><span class="comment">//此时在强转的时候，就会报错。</span></span><br><span class="line">            Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">//把根节点当做当前节点的父节点</span></span><br><span class="line">                parent = t;</span><br><span class="line"><span class="comment">//调用compareTo方法，比较根节点和当前要添加节点的大小关系</span></span><br><span class="line">                cmp = k.compareTo(t.key);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">//如果比较的结果为负数</span></span><br><span class="line"><span class="comment">//那么继续到根节点的左边去找</span></span><br><span class="line">                    t = t.left;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">//如果比较的结果为正数</span></span><br><span class="line"><span class="comment">//那么继续到根节点的右边去找</span></span><br><span class="line">                    t = t.right;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果比较的结果为0，会覆盖</span></span><br><span class="line">                    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> t.value;</span><br><span class="line">                    <span class="keyword">if</span> (replaceOld || oldValue == <span class="literal">null</span>) &#123;</span><br><span class="line">                        t.value = value;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> oldValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//就会把当前节点按照指定的规则进行添加</span></span><br><span class="line">        addEntry(key, value, parent, cmp &lt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(K key, V value, Entry&lt;K, V&gt; parent, <span class="type">boolean</span> addToLeft)</span> &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, parent);</span><br><span class="line">        <span class="keyword">if</span> (addToLeft)</span><br><span class="line">            parent.left = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent.right = e;</span><br><span class="line"><span class="comment">//添加完毕之后，需要按照红黑树的规则进行调整</span></span><br><span class="line">        fixAfterInsertion(e);</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> &#123;</span><br><span class="line"><span class="comment">//因为红黑树的节点默认就是红色的</span></span><br><span class="line">        x.color = RED;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照红黑规则进行调整</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//parentOf:获取x的父节点</span></span><br><span class="line"><span class="comment">//parentOf(parentOf(x)):获取x的爷爷节点</span></span><br><span class="line"><span class="comment">//leftOf:获取左子节点</span></span><br><span class="line">        <span class="keyword">while</span> (x != <span class="literal">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前节点的父节点是爷爷节点的左子节点还是右子节点</span></span><br><span class="line"><span class="comment">//目的：为了获取当前节点的叔叔节点</span></span><br><span class="line">            <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line"><span class="comment">//表示当前节点的父节点是爷爷节点的左子节点</span></span><br><span class="line"><span class="comment">//那么下面就可以用rightOf获取到当前节点的叔叔节点</span></span><br><span class="line">                Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">                <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line"><span class="comment">//叔叔节点为红色的处理方案</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把父节点设置为黑色</span></span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line"><span class="comment">//把叔叔节点设置为黑色</span></span><br><span class="line">                    setColor(y, BLACK);</span><br><span class="line"><span class="comment">//把爷爷节点设置为红色</span></span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把爷爷节点设置为当前节点</span></span><br><span class="line">                    x = parentOf(parentOf(x));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//叔叔节点为黑色的处理方案</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//表示判断当前节点是否为父节点的右子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示当前节点是父节点的右子节点</span></span><br><span class="line">                        x = parentOf(x);</span><br><span class="line"><span class="comment">//左旋</span></span><br><span class="line">                        rotateLeft(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    rotateRight(parentOf(parentOf(x)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//表示当前节点的父节点是爷爷节点的右子节点</span></span><br><span class="line"><span class="comment">//那么下面就可以用leftOf获取到当前节点的叔叔节点</span></span><br><span class="line">                Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">                <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(y, BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    x = parentOf(parentOf(x));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                        x = parentOf(x);</span><br><span class="line">                        rotateRight(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把根节点设置为黑色</span></span><br><span class="line">        root.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>TreeMap添加元素的时候，键是否需要重写hashCode和equals方法？<br>此时是不需要重写的。</p></li><li><p>HashMap是哈希表结构的，JDK8开始由数组，链表，红黑树组成的。<br>既然有红黑树，HashMap的键是否需要实现Compareable接口或者传递比较器对象呢？<br>不需要的。<br>因为在HashMap的底层，默认是利用哈希值的大小关系来创建红黑树的</p></li><li><p>TreeMap和HashMap谁的效率更高？<br>如果是最坏情况，添加了8个元素，这8个元素形成了链表，此时TreeMap的效率要更高<br>但是这种情况出现的几率非常的少。<br>一般而言，还是HashMap的效率要更高。</p></li><li><p>你觉得在Map集合中，java会提供一个如果键重复了，不会覆盖的put方法呢？<br>此时putIfAbsent本身不重要。<br>传递一个思想：<br>代码中的逻辑都有两面性，如果我们只知道了其中的A面，而且代码中还发现了有变量可以控制两面性的发生。<br>那么该逻辑一定会有B面。<br><br> 习惯：<br> boolean类型的变量控制，一般只有AB两面，因为boolean只有两个值<br> int类型的变量控制，一般至少有三面，因为int可以取多个值。</p></li><li><p>三种双列集合，以后如何选择？<br>HashMap LinkedHashMap TreeMap<br> 默认：HashMap（效率最高）<br> 如果要保证存取有序：LinkedHashMap<br> 如果要进行排序：TreeMap</p></li></ol><h1 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h1><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>如何设计方法求n个数的和</p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618084959.png"></p><p>简化</p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618085107.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618085153.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618085354.png"></p><h2 id="集合工具类"><a href="#集合工具类" class="headerlink" title="集合工具类"></a>集合工具类</h2><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618085501.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618085531.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618085625.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618085706.png"></p><h2 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h2><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618090004.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618090022.png"></p><p>使用</p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618090222.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618090245.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618090436.png"></p><p>map无可变参数，最多只能传递20个键值对，但是有Entry的可变参数</p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618091601.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618091622.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618091644.png"></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618132859.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">p1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 随机点名</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用集合工具类添加数据</span></span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;aba&quot;</span>,<span class="string">&quot;aac&quot;</span>,<span class="string">&quot;eaa&quot;</span>,<span class="string">&quot;afa&quot;</span>,<span class="string">&quot;gaa&quot;</span>,<span class="string">&quot;haa&quot;</span>,<span class="string">&quot;aai&quot;</span>,<span class="string">&quot;aja&quot;</span>,<span class="string">&quot;kaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一种随机方式</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Random</span> <span class="variable">rd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> rd.nextInt(list.size());</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> list.get(idx);</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用集合工具进行打乱</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618132922.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">p2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 带权重的随机， 70%随机到男生 30%到女生</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如何解决概率问题</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        Collections.addAll(list, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在集合中有百分之七十概率抽到 1 百分之三十概率抽到 0</span></span><br><span class="line">        <span class="comment">// 如果抽到 1 我们从 男生的链表中随机，如果抽到 0 从女生的链表中随机</span></span><br><span class="line"></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> rd.nextInt(list.size());</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> list.get(idx);</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;从男生的集合中抽取&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;从女生的集合中抽取&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//在这个方法中，我们可以把随机抽取的这个步骤设计成方法多次调用即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618132938.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">p3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 点到的学生不会再点到，如果都电完，开启第二轮点名</span></span><br><span class="line">        <span class="comment">// 记忆化抽取</span></span><br><span class="line">        <span class="comment">// 也可以删一个就往另一个链表中加一个，当一个链表空的时候就重新往里面加就可以了 list.addAll(list1)</span></span><br><span class="line">        <span class="comment">// 在使用链表长度作为循环判断条件的时候需要注意链表的长度是有可能发生改变导致数组遍历不完全的</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//使用集合工具类添加数据</span></span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;aba&quot;</span>,<span class="string">&quot;aac&quot;</span>,<span class="string">&quot;eaa&quot;</span>,<span class="string">&quot;afa&quot;</span>,<span class="string">&quot;gaa&quot;</span>,<span class="string">&quot;haa&quot;</span>,<span class="string">&quot;aai&quot;</span>,<span class="string">&quot;aja&quot;</span>,<span class="string">&quot;kaa&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span>[] flag = <span class="keyword">new</span> <span class="title class_">boolean</span>[list.size()];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跟记忆化搜索一样，懒得写了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618133000.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618140425.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, ArrayList&lt;String&gt;&gt; list = new HashMap()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/posts/2053.html"/>
      <url>/posts/2053.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h2><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617092143.png"></p><p>泛型是为了能够统一数据，方便操作</p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617092436.png"></p><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617092552.png"></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617092651.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617092816.png"></p><ol><li>因为在编译的时候都会转为Object类，而基本数据类型无法转成Object所以只能用对应的包装类</li><li>多态</li><li>所以不能用基本数据类型</li></ol><h1 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h1><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617093039.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617093101.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617093355.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617093456.png"></p><h1 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h1><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617093635.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617093655.png"></p><p>可变参数</p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617094104.png"></p><h1 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h1><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617094145.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617094201.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617094302.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617094414.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617094501.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617094621.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617094636.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617094947.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617095044.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617095625.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617095644.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617095713.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617095742.png"></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617095138.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java数据结构</title>
      <link href="/posts/60592.html"/>
      <url>/posts/60592.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[toc]</p><h1 id><a href="#" class="headerlink" title></a></h1><h1 id="Java数据结构"><a href="#Java数据结构" class="headerlink" title="Java数据结构"></a>Java数据结构</h1><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616231612.png"></p><h2 id="1-栈"><a href="#1-栈" class="headerlink" title="1. 栈"></a>1. 栈</h2><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616231645.png"></p><p>进栈的过程称为压&#x2F;进栈，离开的过程称为弹&#x2F;出栈</p><h2 id="2-队列"><a href="#2-队列" class="headerlink" title="2. 队列"></a>2. 队列</h2><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616231815.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616231903.png"></p><h2 id="3-数组"><a href="#3-数组" class="headerlink" title="3. 数组"></a>3. 数组</h2><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616232016.png"></p><h2 id="4-链表"><a href="#4-链表" class="headerlink" title="4. 链表"></a>4. 链表</h2><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616232045.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616232204.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616232258.png"></p><h2 id="5-树"><a href="#5-树" class="headerlink" title="5. 树"></a>5. 树</h2><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617102155.png"></p><h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617102644.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617102728.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617102752.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617102807.png"></p><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="- 二叉查找树"></a>- 二叉查找树</h3><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617102328.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617102428.png"></p><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="- 平衡二叉树"></a>- 平衡二叉树</h3><p>查找树优化</p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617103047.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617103446.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617103713.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617103742.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617103822.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617103855.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617104030.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617104206.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617104325.png"></p><p>插入情况</p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617104520.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617104705.png"></p><p>先局部左旋,在整体右旋</p><img src="/posts/60592/微信截图_20230617104830.png" style="zoom:80%;"><p>小结</p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617104907.png"></p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="- 红黑树"></a>- 红黑树</h3><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617105152.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617105437.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617110042.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617113911.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="/posts/21079.html"/>
      <url>/posts/21079.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[toc]</p><h1 id="集合体系结构"><a href="#集合体系结构" class="headerlink" title="集合体系结构"></a>集合体系结构</h1><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616222503.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616222539.png"></p><p>list 集合特点：有序，可重复，有索引</p><p>set集合特点：无序，不重复，无索引</p><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616222802.png"></p><p>Collection是一个接口，所以不能直接创建对象，只能创建他实现类的对象</p><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><h3 id="1-add"><a href="#1-add" class="headerlink" title="1. add"></a>1. add</h3><p>往list中添加数据，永远返回true因为list是允许元素重复的</p><p>如果往set中添加数据，则如果数据不存在返回true，否则返回false，因为set中的元素不允许重复</p><h3 id="2-clear"><a href="#2-clear" class="headerlink" title="2. clear"></a>2. clear</h3><p>清空集合</p><h3 id="3-remove"><a href="#3-remove" class="headerlink" title="3. remove"></a>3. remove</h3><p>因为是list跟set共有的方法，所以不嫩沟通过索引进行删除，只能通过元素对象进行删除，如果集合中存在该元素，则删除成功返回true，否则返回false</p><h3 id="4-contains"><a href="#4-contains" class="headerlink" title="4. contains"></a>4. contains</h3><p>判断是否包含某元素</p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616224336.png"></p><p>底层是依靠equals判断是否存在，如果储存的是自定义对象则需要重写equals方法（equals方法依靠地址值进行判断而我们一般需要比较的是属性值）</p><h3 id="5-isEmpty"><a href="#5-isEmpty" class="headerlink" title="5. isEmpty"></a>5. isEmpty</h3><p>判断集合是否为空，底层直接判断集合的长度</p><h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><p>因为collection没有索引，所以无法通过普通遍历方式进行遍历 </p><h3 id="1-迭代器遍历"><a href="#1-迭代器遍历" class="headerlink" title="1. 迭代器遍历"></a>1. 迭代器遍历</h3><p>迭代器对象，不依赖索引</p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616224908.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616225010.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616225128.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616225406.png"></p><p>对于4，会出现并发修改异常，如果需要在迭代时进行删除，那么我们不能用集合的方法进行删除，可以用迭代器使用的remove方法</p><h3 id="2-增强-for-遍历"><a href="#2-增强-for-遍历" class="headerlink" title="2. 增强 for 遍历"></a>2. 增强 for 遍历</h3><img src="/posts/21079/微信截图_20230616225635.png" style="zoom:67%;"><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616225728.png"></p><p>增强for遍历中的元素为临时变量</p><h3 id="3-lambda表达式遍历"><a href="#3-lambda表达式遍历" class="headerlink" title="3. lambda表达式遍历"></a>3. lambda表达式遍历</h3><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616230030.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616230104.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616230144.png"></p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h2><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617130104.png"></p><h2 id="2-特有方法"><a href="#2-特有方法" class="headerlink" title="2. 特有方法"></a>2. 特有方法</h2><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616230334.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616230543.png"></p><h2 id="3-遍历方式"><a href="#3-遍历方式" class="headerlink" title="3. 遍历方式"></a>3. 遍历方式</h2><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616230716.png"></p><p>重点，列表迭代器，为迭代器的子接口</p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616230915.png"></p><p>在这个迭代器中，指针的移动更加灵活，既可以向前，也可以向后，并且在迭代时可以添加元素</p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616231136.png"></p><h2 id="4-实现类"><a href="#4-实现类" class="headerlink" title="4. 实现类"></a>4. 实现类</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ul><li><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616232744.png"></li></ul><p>size 变量是指list的长度，也是下一个存入的位置</p><ul><li><p>空参构造</p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616232925.png"></p></li><li><p>扩容（理解）</p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616233410.png" alt="神奇的源码"></p></li></ul><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616233912.png" alt="神奇的源码"></p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ul><li><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616234036.png"></li></ul><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616234111.png"></p><ul><li><p>结构</p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617090856.png"></p></li></ul><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><ul><li><p>源码</p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617092007.png"></p></li></ul><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="1-特点-1"><a href="#1-特点-1" class="headerlink" title="1. 特点"></a>1. 特点</h2><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617114249.png"></p><h2 id="2-包含方法"><a href="#2-包含方法" class="headerlink" title="2. 包含方法"></a>2. 包含方法</h2><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617130302.png"></p><ul><li>add方法不一定成功,因为不允许有重复元素</li></ul><h2 id="3-遍历方式-1"><a href="#3-遍历方式-1" class="headerlink" title="3. 遍历方式"></a>3. 遍历方式</h2><ul><li>迭代器遍历</li><li>增强for遍历</li><li>lambda表达式遍历</li></ul><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617130713.png"></p><h2 id="4-实现类-1"><a href="#4-实现类-1" class="headerlink" title="4.实现类"></a>4.实现类</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617131123.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617130932.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617131037.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617131357.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617131633.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617131911.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617131925.png"></p><p>HashCode equals方法保证去重</p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617132136.png"></p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617132611.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617132744.png"></p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617132851.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617135231.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617140311.png"></p><p>实现比较接口</p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617135633.png"></p><p>传递比较器</p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617140513.png"></p><p>函数式接口可以改为lambda表达式</p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617140636.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617141115.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617141146.png"></p><h1 id="使用情景"><a href="#使用情景" class="headerlink" title="使用情景"></a>使用情景</h1><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617141252.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>双指针</title>
      <link href="/posts/58208.html"/>
      <url>/posts/58208.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>双指针可以使我们在不使用额外空间且只遍历一次数组的情况下修改数组中的元素</p><p>通常我们需要定义两个指针，利用他们前进的不同速度来实现不同的操作，快指针我们用来寻找新的目标，慢指针用于修改目标</p><h2 id="一，移除元素"><a href="#一，移除元素" class="headerlink" title="一，移除元素"></a>一，移除元素</h2><p><img src="/posts/58208/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230413213357.png"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>通过循环不断把右边的值赋给左边，也就是将fast指向的值赋给slow，fast指向待处理的元素，slow指向下一个要赋值的位置，如果右指针指向的元素为目标元素，则它不能出现在我们覆盖后的数组里，此时左指针不同，右指针移动一位</p><p>整个过程保持不变的性质是：区间[0, left)中的元素都不等于val，当左右指针遍历完输入数组以后，left的值就是输出数组的长度</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeElement(int[] nums, int val) &#123;</span><br><span class="line">        int slow = 0;</span><br><span class="line">        for (int fast = 0; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">            if (nums[fast] != val) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二，删除数组中相邻重复项"><a href="#二，删除数组中相邻重复项" class="headerlink" title="二，删除数组中相邻重复项"></a>二，删除数组中相邻重复项</h2><p><img src="/posts/58208/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230413214638.png"></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>跟第一道题思路类似，通过循环不断把快指针指向的值赋给左边，如果快指针指向的值等于慢指针指向的值，那么慢指针不懂，快指针右移一位，前两个题目看似不同，其实都是同一个道理</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeDuplicates(int[] nums) &#123;</span><br><span class="line"></span><br><span class="line">        int fast = 0;</span><br><span class="line">        int slow = 0;</span><br><span class="line">        while (fast != nums.length) &#123;</span><br><span class="line">            if (nums[fast] == nums[slow]) &#123;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125; else if (nums[fast] != nums[slow]) &#123;</span><br><span class="line">                nums[slow + 1] = nums[fast];</span><br><span class="line">                fast++;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow += 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三，移动零"><a href="#三，移动零" class="headerlink" title="三，移动零"></a>三，移动零</h2><p><img src="/posts/58208/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230413220705.png"></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>与前面题目的不同是，前面的题目都是在用快指针进行判断，如果快指针的值满足要求，那么我们进行操作，不断把右边的值移向左边，但是这个题目是把值移向右边，所以我们在对快指针指向值进行判断的前提下还要对慢指针指向的值进行判断，当两者指向的值都满足要求时，我们才进行操作</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void moveZeroes(int[] nums) &#123;</span><br><span class="line">        int slow = 0;</span><br><span class="line">        int fast = 0;</span><br><span class="line">        while (fast &lt; nums.length) &#123;</span><br><span class="line">            if (nums[slow] == 0 &amp;&amp; nums[fast] == 0) &#123;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125; else if (nums[slow] == 0 &amp;&amp; nums[fast] != 0) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                nums[fast] = 0;</span><br><span class="line">                slow++;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                slow++;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四，比较含退格的字符串"><a href="#四，比较含退格的字符串" class="headerlink" title="四，比较含退格的字符串"></a>四，比较含退格的字符串</h2><p><img src="/posts/58208/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230413221228.png"></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>这个题目我第一思路是用栈</p><p>双指针的思路也挺好想，我们定义两个指针分别逆序遍历两个数组，直到两个字符串能确定一个字符，对这两个字符进行比较，直到找到两个不一样的字符或者遍历完整个数组</p><p><img src="/posts/58208/1.gif" alt="作者：LeetCode-Solution        链接：https://leetcode.cn/problems/backspace-string-compare/solution/bi-jiao-han-tui-ge-de-zi-fu-chuan-by-leetcode-solu/        来源：力扣（LeetCode）"></p><p>栈是处理完字符之后比较最后的答案，但是双指针则是一部分，一部分的进行比较，这里直接上官方答案</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean backspaceCompare(String S, String T) &#123;</span><br><span class="line">        int i = S.length() - 1, j = T.length() - 1;</span><br><span class="line">        int skipS = 0, skipT = 0;</span><br><span class="line"></span><br><span class="line">        while (i &gt;= 0 || j &gt;= 0) &#123;</span><br><span class="line">            while (i &gt;= 0) &#123;</span><br><span class="line">                if (S.charAt(i) == &#x27;#&#x27;) &#123;</span><br><span class="line">                    skipS++;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125; else if (skipS &gt; 0) &#123;</span><br><span class="line">                    skipS--;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            while (j &gt;= 0) &#123;</span><br><span class="line">                if (T.charAt(j) == &#x27;#&#x27;) &#123;</span><br><span class="line">                    skipT++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125; else if (skipT &gt; 0) &#123;</span><br><span class="line">                    skipT--;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123;</span><br><span class="line">                if (S.charAt(i) != T.charAt(j)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (i &gt;= 0 || j &gt;= 0) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">        链接：https://leetcode.cn/problems/backspace-string-compare/solution/bi-jiao-han-tui-ge-de-zi-fu-chuan-by-leetcode-solu/</span><br><span class="line">        来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure><h2 id="五，有序数组的平方"><a href="#五，有序数组的平方" class="headerlink" title="五，有序数组的平方"></a>五，有序数组的平方</h2><p><img src="/posts/58208/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230413221928.png"></p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>类似并规排序，找到分界线，对两边数组进行遍历，比较两个指针对应的数字，把符合条件的放到答案中，当有一边碰到边界时，把另一边的数一次放入答案</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] sortedSquares(int[] nums) &#123;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (nums.length &lt;= 1) &#123;</span><br><span class="line">            return nums;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int slow = 0, fast = nums.length - 1;</span><br><span class="line">        int[] ans = new int[nums.length];</span><br><span class="line">        int count = nums.length - 1;</span><br><span class="line">        int mid = 0;</span><br><span class="line">        while (mid != nums.length - 1 &amp;&amp; nums[mid] &gt;= nums[mid + 1]) mid++;</span><br><span class="line">        while (slow &lt;= fast) &#123;</span><br><span class="line">            if (slow != mid &amp;&amp; fast != mid) &#123;</span><br><span class="line">                if (nums[slow] &gt;= nums[fast]) &#123;</span><br><span class="line">                    ans[count--] = nums[slow];</span><br><span class="line">                    slow++;</span><br><span class="line">                &#125; else if (nums[slow] &lt; nums[fast]) &#123;</span><br><span class="line">                    ans[count--] = nums[fast];</span><br><span class="line">                    fast--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (fast == mid) &#123;</span><br><span class="line">                    ans[count--] = nums[slow++];</span><br><span class="line">                &#125; else if (slow == mid) &#123;</span><br><span class="line">                    ans[count--] = nums[fast--];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//又是一个错误写法</span><br><span class="line">        // int slow = 0, fast = nums.length - 1;</span><br><span class="line">        // while (slow &lt;= fast) &#123;</span><br><span class="line"></span><br><span class="line">        //     //一个数轴上总移动量为一次，可以使用等于，否则有风险</span><br><span class="line"></span><br><span class="line">        //     if (nums[slow] &gt; nums[fast]) &#123;</span><br><span class="line">        //         int cur = nums[slow];</span><br><span class="line">        //         nums[slow] = nums[fast];</span><br><span class="line">        //         nums[fast] = cur;</span><br><span class="line">        //         slow++;</span><br><span class="line">        //     &#125;</span><br><span class="line"></span><br><span class="line">        //     fast--;</span><br><span class="line">        // &#125;</span><br><span class="line"></span><br><span class="line">        // return nums;</span><br><span class="line"></span><br><span class="line">//错误写法</span><br><span class="line">        // int slow = 0, fast = 0;</span><br><span class="line">        // int mid = 0;</span><br><span class="line">        // while (nums[mid] &gt; nums[mid + 1]) mid++;</span><br><span class="line">        // fast = mid;</span><br><span class="line">        // while (slow != fast) &#123;</span><br><span class="line">        //     if (nums[slow] &gt; nums[fast]) &#123;</span><br><span class="line">        //         int cur = nums[slow];</span><br><span class="line">        //         nums[slow] = nums[fast];</span><br><span class="line">        //         nums[fast] = cur;</span><br><span class="line">        //     &#125;</span><br><span class="line">        //     slow++;</span><br><span class="line">        //     if (fast != nums.length - 1) fast++;</span><br><span class="line">        // &#125;</span><br><span class="line"></span><br><span class="line">        // return nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>毛毛虫算法（滑动窗口）</title>
      <link href="/posts/37949.html"/>
      <url>/posts/37949.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="长度最小子数组"><a href="#长度最小子数组" class="headerlink" title="长度最小子数组"></a>长度最小子数组</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h2 id="水果成篮"><a href="#水果成篮" class="headerlink" title="水果成篮"></a>水果成篮</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PTA错题第四次收录</title>
      <link href="/posts/22469.html"/>
      <url>/posts/22469.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="嘟嘟可大骑士的犯二手册"><a href="#嘟嘟可大骑士的犯二手册" class="headerlink" title="嘟嘟可大骑士的犯二手册"></a>嘟嘟可大骑士的犯二手册</h1><h2 id="一，阅览室"><a href="#一，阅览室" class="headerlink" title="一，阅览室"></a>一，阅览室</h2><p><img src="/posts/22469/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230328111454.png"></p><p><img src="/posts/22469/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230328111513.png"></p><h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><p>这个题目的难点在系统如何能自动忽略无效记录，可以采用桶排的思想，创建两个数组分别用于储存借出信息和归还信息，如果借出，那么在对应地方进行标记，如果归还查询借出数组是否有借出的标记，如果没有那么这是一条只有归还没有借出的记录，那么我们进行忽略。另外还需要注意的是，如果书名为0，那么我们要对后面的一系列数据进行读取，要不然会乱，另外快读的读取方式也需要注意，还有，出现除法，一定要考虑0</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>&#96;&#96;错误代码，没有注意，时间的读入，书名为0的时候没有对后面面的数据进行处理</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Z2017;</span><br><span class="line"></span><br><span class="line">import jdk.swing.interop.SwingInterOpUtils;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line">public class p03 &#123;</span><br><span class="line">    static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">    static StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line"></span><br><span class="line">    static int[][] bookState = new int[1000][6];</span><br><span class="line">    //1. jiechu 0 2. huan 1 3.jsj 2 3 4.hsj 4 5</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int n = readInt();</span><br><span class="line">        int bt = 0;</span><br><span class="line">        int pn = 0;</span><br><span class="line">        while (n != 0) &#123;</span><br><span class="line">            int bookName = readInt();</span><br><span class="line">            if (bookName == 0) &#123;</span><br><span class="line">                n -= 1;</span><br><span class="line">                readChar();</span><br><span class="line">                int hh = readInt();st.nextToken();</span><br><span class="line">                int mm = readInt();</span><br><span class="line">                System.out.println(pn +&quot; &quot;+ bt*1.0 / pn);</span><br><span class="line">                pn = 0;</span><br><span class="line">                bt = 0;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            char a = readChar();</span><br><span class="line">            if (a == &#x27;S&#x27;) &#123;</span><br><span class="line">                bookState[bookName][0] = 1;</span><br><span class="line">                //char[] time = readCharArray();</span><br><span class="line">                //String aaa = readStr();</span><br><span class="line">                //char[] time = aaa.toCharArray();</span><br><span class="line">                //int hh = (time[0] - &#x27;0&#x27;) * 10 + (time[1] - &#x27;0&#x27;);</span><br><span class="line">                //int mm = (time[3] - &#x27;0&#x27;) * 10 + (time[4] - &#x27;0&#x27;);</span><br><span class="line">                int hh = readInt();st.nextToken();</span><br><span class="line">                int mm = readInt();</span><br><span class="line">                bookState[bookName][2] = hh;</span><br><span class="line">                bookState[bookName][3] = mm;</span><br><span class="line">            &#125; else if (a == &#x27;E&#x27;) &#123;</span><br><span class="line">                if (bookState[bookName][0] != 1)&#123;</span><br><span class="line">                    readStr();</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else if (bookState[bookName][0] == 1)&#123;</span><br><span class="line">                    pn++;</span><br><span class="line">//                    char[] time = readCharArray();</span><br><span class="line">//                    int hh = (time[0] - &#x27;0&#x27;) * 10 + (time[1] - &#x27;0&#x27;);</span><br><span class="line">//                    int mm = (time[3] - &#x27;0&#x27;) * 10 + (time[4] - &#x27;0&#x27;);</span><br><span class="line">                    int hh = readInt();st.nextToken();</span><br><span class="line">                    int mm = readInt();</span><br><span class="line">                    bookState[bookName][4] = hh;</span><br><span class="line">                    bookState[bookName][5] = mm;</span><br><span class="line">                    bt += countTime(bookState[bookName][2],bookState[bookName][3],bookState[bookName][4],bookState[bookName][5]);</span><br><span class="line">                    bookState[bookName][0] =bookState[bookName][1] = bookState[bookName][2] = bookState[bookName][3] = bookState[bookName][4] = bookState[bookName][5] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        readInt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int countTime (int h1, int m1, int h2, int m2) &#123;</span><br><span class="line">        int all = 0;</span><br><span class="line">        if (h2 == h1) &#123;</span><br><span class="line">            all += m2 - m1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            all += 60 - m1;</span><br><span class="line">            h1++;</span><br><span class="line">            all += (h2 - h1) * 60;</span><br><span class="line">            all += m2;</span><br><span class="line">        &#125;</span><br><span class="line">        return all;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int readInt () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return (int)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String readStr () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char readChar () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.charAt(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readCharArray () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Z2017;</span><br><span class="line"></span><br><span class="line">import jdk.swing.interop.SwingInterOpUtils;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line">public class p03_1 &#123;</span><br><span class="line">    static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">    static StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line"></span><br><span class="line">    static int[][] bookState = new int[1000][6];</span><br><span class="line">    //1. jiechu 0 2. huan 1 3.jsj 2 3 4.hsj 4 5</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int n = readInt();</span><br><span class="line">        int bt = 0;</span><br><span class="line">        int pn = 0;</span><br><span class="line">        while (n != 0) &#123;</span><br><span class="line">            int bookName = readInt();</span><br><span class="line">            if (bookName == 0) &#123;</span><br><span class="line">                n -= 1;</span><br><span class="line">                readChar();</span><br><span class="line">                int hh = readInt();st.nextToken();</span><br><span class="line">                int mm = readInt();</span><br><span class="line">                System.out.print(pn +&quot; &quot;);</span><br><span class="line">                if (pn == 0) &#123;</span><br><span class="line">                    System.out.println(0);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.printf(&quot;%.0f\n&quot;, bt * 1.0 / pn);</span><br><span class="line">                &#125;</span><br><span class="line">                pn = 0;</span><br><span class="line">                bt = 0;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            char a = readChar();</span><br><span class="line">            if (a == &#x27;S&#x27;) &#123;</span><br><span class="line">                bookState[bookName][0] = 1;</span><br><span class="line">                //char[] time = readCharArray();</span><br><span class="line">                //String aaa = readStr();</span><br><span class="line">                //char[] time = aaa.toCharArray();</span><br><span class="line">                //int hh = (time[0] - &#x27;0&#x27;) * 10 + (time[1] - &#x27;0&#x27;);</span><br><span class="line">                //int mm = (time[3] - &#x27;0&#x27;) * 10 + (time[4] - &#x27;0&#x27;);</span><br><span class="line">                int hh = readInt();st.nextToken();</span><br><span class="line">                int mm = readInt();</span><br><span class="line">                bookState[bookName][2] = hh;</span><br><span class="line">                bookState[bookName][3] = mm;</span><br><span class="line">            &#125; else if (a == &#x27;E&#x27;) &#123;</span><br><span class="line">                if (bookState[bookName][0] != 1)&#123;</span><br><span class="line">                    int hh = readInt();st.nextToken();</span><br><span class="line">                    int mm = readInt();</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else if (bookState[bookName][0] == 1)&#123;</span><br><span class="line">                    pn++;</span><br><span class="line">//                    char[] time = readCharArray();</span><br><span class="line">//                    int hh = (time[0] - &#x27;0&#x27;) * 10 + (time[1] - &#x27;0&#x27;);</span><br><span class="line">//                    int mm = (time[3] - &#x27;0&#x27;) * 10 + (time[4] - &#x27;0&#x27;);</span><br><span class="line">                    int hh = readInt();st.nextToken();</span><br><span class="line">                    int mm = readInt();</span><br><span class="line">                    bookState[bookName][4] = hh;</span><br><span class="line">                    bookState[bookName][5] = mm;</span><br><span class="line">                    bt += countTime(bookState[bookName][2],bookState[bookName][3],bookState[bookName][4],bookState[bookName][5]);</span><br><span class="line">                    bookState[bookName][0] =bookState[bookName][1] = bookState[bookName][2] = bookState[bookName][3] = bookState[bookName][4] = bookState[bookName][5] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        readInt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int countTime (int h1, int m1, int h2, int m2) &#123;</span><br><span class="line">        int all = 0;</span><br><span class="line">        if (h2 == h1) &#123;</span><br><span class="line">            all += m2 - m1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            all += 60 - m1;</span><br><span class="line">            h1++;</span><br><span class="line">            all += (h2 - h1) * 60;</span><br><span class="line">            all += m2;</span><br><span class="line">        &#125;</span><br><span class="line">        return all;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int readInt () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return (int)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String readStr () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char readChar () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.charAt(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readCharArray () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二，猜数字"><a href="#二，猜数字" class="headerlink" title="二，猜数字"></a>二，猜数字</h2><p><img src="/posts/22469/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230328151216.png"></p><h3 id="坑-1"><a href="#坑-1" class="headerlink" title="坑"></a>坑</h3><p>这个题目其实相当简单，算出平均成绩的四分之一（ans）后对成绩数组(num[])进行排序，然后利用二分查找的思想找到ans两边的数就行了但是我如果ans用doule来存的话会出错，估计是在使用double之后小数点后面的量进位导致出现偏差</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Z2018;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line">public class 猜数字_1 &#123;</span><br><span class="line">    static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">    static StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line"></span><br><span class="line">    static String[] name = new String[10010];</span><br><span class="line">    static int[] num = new int[10010];</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int n = readInt();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            name[i] = readStr();</span><br><span class="line">            num[i] = readInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //        double ans = 0;</span><br><span class="line">//        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">//            ans += num[i];</span><br><span class="line">//        &#125;</span><br><span class="line">//        if (n != 0)ans = ans * 0.5 / n;错误部分</span><br><span class="line"></span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            ans += num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if (n != 0)ans = (int)(ans * 0.5 / n);</span><br><span class="line"></span><br><span class="line">        int left = -10;</span><br><span class="line">        int right = 110;</span><br><span class="line">        int lidx = 0;</span><br><span class="line">        int ridx = 0;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (num[i] &gt; left &amp;&amp; num[i] &lt;= ans) &#123;</span><br><span class="line">                left = num[i];</span><br><span class="line">                lidx = i;</span><br><span class="line">            &#125; else if (num[i] &gt; ans &amp;&amp; num[i] &lt; right) &#123;</span><br><span class="line">                right = num[i];</span><br><span class="line">                ridx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int lc = (int)Math.abs(ans - left);</span><br><span class="line">        int rc = (int)Math.abs(ans - right);</span><br><span class="line">        int a = (int)ans;</span><br><span class="line">        if (lc &lt; rc &amp;&amp; n != 0) &#123;</span><br><span class="line">            System.out.printf(&quot;%d&quot;,a);</span><br><span class="line">            System.out.println(&quot; &quot;+name[lidx]);</span><br><span class="line">        &#125; else if (n != 0)&#123;</span><br><span class="line">            System.out.printf(&quot;%d&quot;,a);</span><br><span class="line">            System.out.println(&quot; &quot;+name[ridx]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readSP () throws IOException &#123;</span><br><span class="line">        char aa[] = new char[5];</span><br><span class="line">        bf.read(aa);</span><br><span class="line">        return  aa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int readInt () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return (int)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String readStr () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char readChar () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.charAt(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readCharArray () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String readLine () throws IOException &#123;</span><br><span class="line">        return bf.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三，座位分配"><a href="#三，座位分配" class="headerlink" title="三，座位分配"></a>三，座位分配</h2><p><img src="/posts/22469/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230328155134.png"></p><p><img src="C:/Users/SLH/AppData/Roaming/Typora/typora-user-images/image-20230328155158406.png" alt="image-20230328155158406"></p><h3 id="坑-2"><a href="#坑-2" class="headerlink" title="坑"></a>坑</h3><p>这个题目我脑子一抽用了三维数组模拟，我只想说，实在是十分痛苦，这个题目细节挺多</p><p>如果只剩1所学校没分配座位如果上一行是本学校的，那么下一个行要+&#x3D;2，如果还+&#x3D;1那么他们可能会坐到一起，如果上一行不是本学校的，那么+&#x3D;1就可以，如果+&#x3D;2直接过不了，还有就是如果只有一个学校参赛，那么不但要求间隔座位，还必须要从1开始，否则过不了，这个题目我只能说真的是非常‘真实’</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Z2018;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line">public class 座位分配_1 &#123;</span><br><span class="line">    static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">    static StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int n = readInt();</span><br><span class="line">        int[][][] map = new int[n + 1][][];</span><br><span class="line"></span><br><span class="line">        int count = 1;</span><br><span class="line">        if (n == 1) count = -1;</span><br><span class="line">        int max = 0;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            int cur = readInt();</span><br><span class="line">            if (max &lt; cur)max = cur;</span><br><span class="line">            int[][] curr = new int[cur + 1][11];</span><br><span class="line">            curr[0][0] = cur;</span><br><span class="line">            curr[1][1] = count++;</span><br><span class="line">            map[i] = curr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count = 0;</span><br><span class="line">        boolean f = pd(map, n);</span><br><span class="line">        if (n == 1)count = -1;</span><br><span class="line">        int i = 1;</span><br><span class="line">        while (i &lt;= max) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= 10; j++) &#123;</span><br><span class="line">                for (int m = 1; m &lt; map.length; m++) &#123;</span><br><span class="line">                    if (i &gt;= map[m].length) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (f) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                        map[m][i][j] = count;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        if (count != map[m][i - 1][10] &amp;&amp; j == 1 &amp;&amp; n != 1) &#123;</span><br><span class="line">                            count++;</span><br><span class="line">                            map[m][i][j] = count;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            map[m][i][j] = count+=2;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i1 = 1; i1 &lt; map.length; i1++) &#123;</span><br><span class="line">                map[i1][0][0]--;</span><br><span class="line">            &#125;</span><br><span class="line">            f = pd(map, n);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int j = 1; j &lt; map.length; j++) &#123;</span><br><span class="line">            System.out.println(&quot;#&quot;+j);</span><br><span class="line">            for (int i1 = 1; i1 &lt; map[j].length; i1++) &#123;</span><br><span class="line">                for (int i2 = 1; i2 &lt; map[j][i1].length; i2++) &#123;</span><br><span class="line">                    System.out.print(map[j][i1][i2]);</span><br><span class="line">                    if (i2 != map[j][i1].length - 1) &#123;</span><br><span class="line">                        System.out.print(&quot; &quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static boolean pd (int[][][] a, int n) &#123;</span><br><span class="line">        if (n == 1) return false;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 1; i &lt; a.length; i++) &#123;</span><br><span class="line">            if (a[i][0][0] &gt; 0) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (count &gt;= 2) return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readSP () throws IOException &#123;</span><br><span class="line">        char aa[] = new char[5];</span><br><span class="line">        bf.read(aa);</span><br><span class="line">        return  aa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int readInt () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return (int)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String readStr () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char readChar () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.charAt(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readCharArray () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String readLine () throws IOException &#123;</span><br><span class="line">        return bf.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Z2018;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line">public class 座位分配_1 &#123;</span><br><span class="line">    static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">    static StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int n = readInt();</span><br><span class="line">        int[][][] map = new int[n + 1][][];</span><br><span class="line"></span><br><span class="line">        int count = 1;</span><br><span class="line">        if (n == 1) count = -1;</span><br><span class="line">        int max = 0;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            int cur = readInt();</span><br><span class="line">            if (max &lt; cur)max = cur;</span><br><span class="line">            int[][] curr = new int[cur + 1][11];</span><br><span class="line">            curr[0][0] = cur;</span><br><span class="line">            curr[1][1] = count++;</span><br><span class="line">            map[i] = curr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count = 0;</span><br><span class="line">        boolean f = pd(map, n);</span><br><span class="line">        if (n == 1)count = -1;</span><br><span class="line">        int i = 1;</span><br><span class="line">        while (i &lt;= max) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= 10; j++) &#123;</span><br><span class="line">                for (int m = 1; m &lt; map.length; m++) &#123;</span><br><span class="line">                    if (i &gt;= map[m].length) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (f) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                        map[m][i][j] = count;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        if (count != map[m][i - 1][10] &amp;&amp; j == 1 &amp;&amp; n != 1) &#123;</span><br><span class="line">                            count++;</span><br><span class="line">                            map[m][i][j] = count;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            map[m][i][j] = count+=2;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i1 = 1; i1 &lt; map.length; i1++) &#123;</span><br><span class="line">                map[i1][0][0]--;</span><br><span class="line">            &#125;</span><br><span class="line">            f = pd(map, n);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int j = 1; j &lt; map.length; j++) &#123;</span><br><span class="line">            System.out.println(&quot;#&quot;+j);</span><br><span class="line">            for (int i1 = 1; i1 &lt; map[j].length; i1++) &#123;</span><br><span class="line">                for (int i2 = 1; i2 &lt; map[j][i1].length; i2++) &#123;</span><br><span class="line">                    System.out.print(map[j][i1][i2]);</span><br><span class="line">                    if (i2 != map[j][i1].length - 1) &#123;</span><br><span class="line">                        System.out.print(&quot; &quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static boolean pd (int[][][] a, int n) &#123;</span><br><span class="line">        if (n == 1) return false;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 1; i &lt; a.length; i++) &#123;</span><br><span class="line">            if (a[i][0][0] &gt; 0) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (count &gt;= 2) return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readSP () throws IOException &#123;</span><br><span class="line">        char aa[] = new char[5];</span><br><span class="line">        bf.read(aa);</span><br><span class="line">        return  aa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int readInt () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return (int)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String readStr () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char readChar () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.charAt(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readCharArray () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String readLine () throws IOException &#123;</span><br><span class="line">        return bf.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四，倒数数第N个字符串"><a href="#四，倒数数第N个字符串" class="headerlink" title="四，倒数数第N个字符串"></a>四，倒数数第N个字符串</h2><p><img src="/posts/22469/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230328155950.png"></p><h3 id="坑-3"><a href="#坑-3" class="headerlink" title="坑"></a>坑</h3><p>这个题目也比较有意思，一开始我还以为要用数组模拟来做（这应该也算一个坑吧）但是后来画了图之后发现，原来是考的进制，这个字符串明显就是一个二十六进制的数，问倒数第几个数罢了，第一次出错的地方是在倒数第最后一位，因为本来进位的逻辑是直接取模，以两位数为例子，如果676直接取模的话得到100，打印出来就是zz显然是不对的，直接在一开始减一，再取模的话就是25，25这就没问题了，</p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Z2018;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class 倒数第N个字符串 &#123;</span><br><span class="line">    static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">    static StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line"></span><br><span class="line">    static int[] jzb = new int[10];</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int l = readInt();</span><br><span class="line">        int n = readInt();</span><br><span class="line">        char[] a = new char[l];</span><br><span class="line">        Arrays.fill(a,&#x27;z&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0; i &lt; l + 1; i++) &#123;</span><br><span class="line">            jzb[count++] = n % 26;</span><br><span class="line">            n /= 26;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (jzb[0] != 0)jzb[0] -= 1;</span><br><span class="line">        if (jzb[l] != 0) &#123;</span><br><span class="line">            for (int i = 0; i &lt; jzb.length; i++) &#123;</span><br><span class="line">                jzb[i] = 25;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count -= 2;</span><br><span class="line">        for (int i = 0; i &lt; l; i++) &#123;</span><br><span class="line">            a[i] = (char)(a[i] - jzb[count--]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readSP () throws IOException &#123;</span><br><span class="line">        char aa[] = new char[5];</span><br><span class="line">        bf.read(aa);</span><br><span class="line">        return  aa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int readInt () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return (int)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String readStr () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char readChar () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.charAt(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readCharArray () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Z2018;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class 倒数第N个字符串_1 &#123;</span><br><span class="line">    static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">    static StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line"></span><br><span class="line">    static int[] jzb = new int[10];</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int l = readInt();</span><br><span class="line">        int n = readInt();</span><br><span class="line">        char[] a = new char[l];</span><br><span class="line">        Arrays.fill(a,&#x27;z&#x27;);</span><br><span class="line"></span><br><span class="line">        n--;</span><br><span class="line"></span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0; i &lt; l + 1; i++) &#123;</span><br><span class="line">            jzb[count++] = n % 26;</span><br><span class="line">            n /= 26;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count -= 2;</span><br><span class="line">        for (int i = 0; i &lt; l; i++) &#123;</span><br><span class="line">            a[i] = (char)(a[i] - jzb[count--]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readSP () throws IOException &#123;</span><br><span class="line">        char aa[] = new char[5];</span><br><span class="line">        bf.read(aa);</span><br><span class="line">        return  aa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int readInt () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return (int)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String readStr () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char readChar () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.charAt(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readCharArray () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Big</title>
      <link href="/posts/44751.html"/>
      <url>/posts/44751.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="BIG"><a href="#BIG" class="headerlink" title="BIG"></a>BIG</h1><p>什么东西很BIG？？？当然是数据啦，要不然你以为会是什么东西。。。[滑稽]</p><p>先上题目</p><p><img src="/posts/44751/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230325143407.png"></p><p>这道题有两种解题思路，一种是用高精度，一种是模拟除法</p><p>在这里我主要用的是Java自带的BigInteger类实现的高精度</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Z2017;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line">import java.math.BigInteger;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class 整除光棍 &#123;</span><br><span class="line">    static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">    static StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line"></span><br><span class="line">    //学习bigInteger</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        BigInteger s = new BigInteger(&quot;0&quot;);</span><br><span class="line">        BigInteger x = sc.nextBigInteger();</span><br><span class="line"></span><br><span class="line">        for (int i = 1;;i++) &#123;</span><br><span class="line">            s = s.multiply(new BigInteger(&quot;10&quot;)); // s* 10  返回s *10的值</span><br><span class="line">            s = s.add(new BigInteger(&quot;1&quot;)); // &#x27;s&#x27;+&#x27;1&#x27; 在个位补1  例如从0开始，s的值变依次转变为 0 1 11 111 1111</span><br><span class="line">            if(s.mod(x).equals(new BigInteger(&quot;0&quot;))) &#123;  //如果s除以输入的数模为0</span><br><span class="line">                System.out.println(s.divide(x).toString() + &quot; &quot; + i); // 输出s除以输入的数 + 1的个数</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readSP () throws IOException &#123;</span><br><span class="line">        char aa[] = new char[5];</span><br><span class="line">        bf.read(aa);</span><br><span class="line">        return  aa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int readInt () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return (int)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String readStr () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char readChar () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.charAt(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readCharArray () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是重要的不是这个题目，而是要熟悉Java中高精度类的使用</p><h1 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h1><p>BigInteger是Java中一个非常有用的类，用于处理任意精度整数，普通整数类型都有固定的位数限制，但是BigInteger类可以处理无限长度的整数</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ol><li>BigInteger <strong>add</strong>(BigInteger val)：将此BigInteger的值与给定BigInteger的值相加，并返回一个新的BigInteger对象。需要传入一个BigInteger对象作为参数。</li><li>BigInteger <strong>subtract</strong>(BigInteger val)：从此BigInteger的值中减去给定BigInteger的值，并返回一个新的BigInteger对象。需要传入一个BigInteger对象作为参数。</li><li>BigInteger <strong>multiply</strong>(BigInteger val)：将此BigInteger的值乘以给定BigInteger的值，并返回一个新的BigInteger对象。需要传入一个BigInteger对象作为参数。</li><li>BigInteger <strong>divide</strong>(BigInteger val)：将此BigInteger的值除以给定BigInteger的值，并返回一个新的BigInteger对象。需要传入一个BigInteger对象作为参数。如果除数为0，会抛出ArithmeticException异常。</li><li>BigInteger <strong>mod</strong>(BigInteger val)：返回此BigInteger除以给定BigInteger的余数，并返回一个新的BigInteger对象。需要传入一个BigInteger对象作为参数。如果除数为0，会抛出ArithmeticException异常。</li><li>BigInteger <strong>pow</strong>(int exponent)：返回此BigInteger的给定指数幂，并返回一个新的BigInteger对象。需要传入一个int类型的指数作为参数。</li><li>BigInteger <strong>gcd</strong>(BigInteger val)：返回此BigInteger和给定BigInteger的最大公约数，并返回一个新的BigInteger对象。需要传入一个BigInteger对象作为参数。</li><li>int <strong>compareTo</strong>(BigInteger val)：将此BigInteger与给定BigInteger进行比较。如果此BigInteger<strong>小于</strong>给定BigInteger，则<strong>返回一个负数</strong>；如果此BigInteger<strong>等于</strong>给定BigInteger，则<strong>返回0</strong>；如果此BigInteger<strong>大于</strong>给定BigInteger，则<strong>返回一个正数</strong>。需要传入一个BigInteger对象作为参数。</li><li>BigInteger <strong>negate</strong>()：返回此BigInteger的相反数，并返回一个新的BigInteger对象。</li><li>BigInteger <strong>abs</strong>()：返回此BigInteger的绝对值，并返回一个新的BigInteger对象。</li><li>BigInteger <strong>shiftLeft</strong>(int n)：将此BigInteger左移n位，并返回一个新的BigInteger对象。需要传入一个int类型的位数作为参数。</li><li>BigInteger <strong>shiftRight</strong>(int n)：将此BigInteger右移n位，并返回一个新的BigInteger对象。需要传入一个int类型的位数作为参数。</li></ol><h2 id="与基本类型间的转换"><a href="#与基本类型间的转换" class="headerlink" title="与基本类型间的转换"></a>与基本类型间的转换</h2><p>1.BigInteger转换为int或long类型：</p><p>使用BigInteger对象的<strong>intValue()<strong>方法可以</strong>将BigInteger对象转换为int类型</strong>，使用<strong>longValue()<strong>方法可以将</strong>BigInteger对象转换为long</strong>类型。需要注意的是，如果BigInteger对象超出了int或long类型的取值范围，转换结果可能会丢失精度，因此在进行转换之前应该检查BigInteger对象的大小。</p><p>2.int或long类型转换为BigInteger：</p><p>使用BigInteger类的<strong>valueOf()<strong>方法可以</strong>将int或long类型转换为BigInteger对象</strong>。这个方法有两个重载形式，一个接受一个long类型的参数，另一个接受一个int类型的参数。</p><p>3.String类型转换为BigInteger：</p><p>使用<strong>BigInteger类的构造方法可以将String类型转换为BigInteger对象</strong>。这个构造方法接受一个String类型的参数，用于表示BigInteger对象的值。</p><h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>bigdecimal是Java中一个用于高精度计算的类，用于处理需要高精度的小数运算和金额计算等场景，和基本数据类型的浮点数相比，这个类可以准确的表示任意位数的小数，并且不会产生摄入误差</p><p>使用这个类需要注意的是，BigDecimal对象不可变（BigIneger也是一样的），对BigDecimal对象的任何修改都会返回一个新的BigDecimal对象，因此，在对BigDecimal进行运算时，需要将结果保存在新的BigDecimal对象中</p><h2 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h2><ol><li>BigDecimal <strong>add</strong>(BigDecimal augend)：将此BigDecimal与指定的BigDecimal相加，返回一个新的BigDecimal对象。</li><li>BigDecimal <strong>subtract</strong>(BigDecimal subtrahend)：从此BigDecimal中减去指定的BigDecimal，返回一个新的BigDecimal对象。</li><li>BigDecimal <strong>multiply</strong>(BigDecimal multiplicand)：将此BigDecimal与指定的BigDecimal相乘，返回一个新的BigDecimal对象。</li><li>BigDecimal <strong>divide</strong>(BigDecimal divisor, int scale, RoundingMode roundingMode)：将此BigDecimal除以指定的BigDecimal，使用指定的舍入模式将结果四舍五入到指定的小数位数，返回一个新的BigDecimal对象。</li><li>BigDecimal <strong>remainder</strong>(BigDecimal divisor)：返回此BigDecimal除以指定的BigDecimal的余数，返回一个新的BigDecimal对象。</li><li>BigDecimal <strong>pow</strong>(int n)：返回此BigDecimal的n次幂，返回一个新的BigDecimal对象。</li><li>BigDecimal <strong>abs</strong>()：返回此BigDecimal的绝对值，返回一个新的BigDecimal对象。</li><li>BigDecimal <strong>negate</strong>()：返回此BigDecimal的相反数，返回一个新的BigDecimal对象。</li><li>int <strong>compareTo</strong>(BigDecimal val)：将此BigDecimal与指定的BigDecimal进行比较，返回一个整数。如果此BigDecimal小于指定的BigDecimal，则返回负整数；如果此BigDecimal等于指定的BigDecimal，则返回0；如果此BigDecimal大于指定的BigDecimal，则返回正整数。</li></ol><h3 id="与基本数据类型间的转换"><a href="#与基本数据类型间的转换" class="headerlink" title="与基本数据类型间的转换"></a>与基本数据类型间的转换</h3><ol><li>double <strong>doubleValue</strong>()：将此BigDecimal转换为double类型。</li><li>float <strong>floatValue</strong>()：将此BigDecimal转换为float类型。</li><li>long <strong>longValue</strong>()：将此BigDecimal转换为long类型。</li><li>int <strong>intValue</strong>()：将此BigDecimal转换为int类型。</li></ol><h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><ol><li>BigInteger和BigDecimal是不可变对象，每次对它们进行操作都会返回一个新的对象，因此在处理大量数据时，需要考虑内存的使用和性能的问题。</li><li>对于BigDecimal对象的比较操作，需要使用compareTo方法而不是equals方法。这是因为<strong>equals</strong>方法在比较两个BigDecimal对象时，<strong>会比较它们的值和精度</strong>，而不仅仅是它们的值。因此，如果两个BigDecimal对象的值相等但精度不同，equals方法会返回false。而compareTo方法则只比较值的大小，不考虑精度。</li><li>在进行BigDecimal对象的除法运算时，需要注意<strong>除数不能为0</strong>的情况，否则会抛出ArithmeticException异常。同时，需要指定保留小数位数和舍入模式，否则可能会得到一个不精确的结果。</li><li>在进行BigInteger对象的除法运算时，需要注意被<strong>除数不能为0</strong>的情况，否则会抛出ArithmeticException异常。同时，需要使用divide方法的重载形式指定舍入模式，否则可能会得到一个不精确的结果。</li><li>在使用BigInteger和BigDecimal对象时，需要注意它们的位数限制。由于这两个类是基于内存的，因此它们的位数限制取决于计算机内存的大小。在处理特别大的数值时，可能需要使用其他技术，如分布式计算或使用第三方库。</li><li>在使用BigInteger和BigDecimal对象时，需要注意它们的精度限制。由于浮点数的精度是有限的，因此对于某些计算，可能需要使用BigDecimal类来保证精度。例如，在进行货币计算时，需要使用BigDecimal类来避免舍入误差。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我与AI</title>
      <link href="/posts/53343.html"/>
      <url>/posts/53343.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="我与AI"><a href="#我与AI" class="headerlink" title="我与AI"></a>我与AI</h1><p>​我自己算是最早的一批感受到ChatGPT有多强的人，随着自己对AI领域知识了解的逐渐增加，愈发觉得自己将来可能会被AI取代，人生第一次由衷的觉得我们的科技发展的太快了，感觉自己快要跟不上，第一次产生害怕被时代远远甩在后头的恐惧</p><p>​在低版本的时候我就觉得普通的码农肯定会被取代，但是随着AI版本的提高，到现在的GhatGPT4,我逐渐感觉被取代的可能不只是码农，随着AI智能的不断增加我有理由相信在未来我们可以实现只要说出需求人工智能就能编写出对应的程序</p><p>​以后的开发流程完全可能是一个人代替之前的十个人，一个开发团队可能只会需要一个产品经理，我们的出路在哪里呢？使用AI，如何更好的，更有效率的去使用AI，应该是我应该去关注的重点，所以我修改了我博客的副标题——积极拥抱新技术，如何去更好的，更有效率的去使用AI ，以及如何使用AI去编写一个大型的程序，其实从表面上看，AI可能是会取代现在的相当大的一部分人，但其中也包含着机会，AI让每个人都能有机会去接触他们并不熟悉的领域。</p><p>​所以我在这里给自己定一个小目标，在AI的帮助下学习关于软件扩展的知识，尝试将ChatGPT的API接到自己想要的软件上。</p><p>​其实如果人工智能真的保持一定的速度持续发展下去，我相信被取代的绝对不仅仅是程序员，试想一下，把人工智能接到机器上面，让AI去执行以前需要一定人类智能的流水线操作，有多少流水线岗位会被取代</p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>愿天下有情人都是失散多年的兄妹</title>
      <link href="/posts/34527.html"/>
      <url>/posts/34527.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="兄妹"><a href="#兄妹" class="headerlink" title="兄妹"></a>兄妹</h1><p>这句话表达了一种希望，希望所有有情人都能够像失散多年的兄妹一样相互关爱、相互扶持。这种关系是亲密而纯洁的，没有任何的欲望和争斗，只有相互的理解和支持。这样的愿望是美好的，也是值得我们去追求的。CSDN上的人工智能回答的，感觉一般般，感觉没有ChatGPT智能</p><p>开个玩笑，接下来看看题目</p><p><img src="/posts/34527/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230322172124.png"></p><p><img src="/posts/34527/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230322172151.png"></p><p><img src="/posts/34527/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230322172203.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题我乍一看，亲戚关系，猛地想到，并查集，但是仔细想了想还是得用DFS，深度优先搜索，给我们两个人，向上翻五代，如果五代之内有相同的父母，那么就不能结婚，如果不可考，那么算可以，在递归的时候我们传入两个参数，如果深度大于四，结束递归，否则，获取x的父母和y的父母，如果两个人的父母都可考，且有相等的，那么我们返回false，结束递归，否则，判断x的母亲和y的母亲有没有相同父母，x的父亲和y的父亲有没有相等的，x的父亲和y的母亲有没有相等父母，x的母亲和y的父亲有没有相等父母，只要有一个返回false那么结束递归。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Trial.兄妹;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class p2 &#123;</span><br><span class="line">    static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">    static StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line"></span><br><span class="line">    static int[] id = new int[100000];</span><br><span class="line">    static String[] sex = new String[100000];</span><br><span class="line">    static int[] fid = new int[100000];</span><br><span class="line">    static int[] mid = new int[100000];</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Arrays.fill(fid, -1);</span><br><span class="line">        Arrays.fill(mid, -1);</span><br><span class="line">        int n = nextInt();</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            id[i] = nextInt();</span><br><span class="line">            sex[i] = next();</span><br><span class="line">            fid[i] = nextInt();</span><br><span class="line">            mid[i] = nextInt();</span><br><span class="line">            if (fid[i] != -1) &#123;</span><br><span class="line">                sex[fid[i]] = &quot;M&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mid[i] != -1) &#123;</span><br><span class="line">                sex[mid[i]] = &quot;F&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int k = nextInt();</span><br><span class="line">        for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">            int xid = nextInt();</span><br><span class="line">            int yid = nextInt();</span><br><span class="line">            if (sex[xid].equals(sex[yid])) &#123;</span><br><span class="line">                System.out.println(&quot;Never Mind&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (DFS(xid, yid, 1)) &#123;</span><br><span class="line">                    System.out.println(&quot;Yes&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.println(&quot;No&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static boolean DFS (int xid, int yid, int deep) &#123;</span><br><span class="line">        if (xid == -1 || yid == -1 || deep &gt; 5) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int xfid = -1;</span><br><span class="line">        int xmid = -1;</span><br><span class="line">        int yfid = -1;</span><br><span class="line">        int ymid = -1;</span><br><span class="line">        xfid = fid[xid];</span><br><span class="line">        xmid = mid[xid];</span><br><span class="line">        yfid = fid[yid];</span><br><span class="line">        ymid = mid[yid];</span><br><span class="line">        if (xfid != -1 &amp;&amp; xfid == yfid || xmid != -1 &amp;&amp; xmid == ymid) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deep++;</span><br><span class="line">        return DFS(xfid, yfid, deep) &amp;&amp; DFS(xmid, ymid, deep) &amp;&amp; DFS(xfid, ymid, deep) &amp;&amp; DFS(xmid, yfid, deep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int nextInt () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return (int)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static String next () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个代码只得了18分，具体差在哪我还真的没找到</p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>列车调度</title>
      <link href="/posts/36741.html"/>
      <url>/posts/36741.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="列车调度"><a href="#列车调度" class="headerlink" title="列车调度"></a>列车调度</h1><p>这是一道理解题意之后十分容易使用栈这种数据结构进行模拟的题目，个人觉得有一点要注意的是一条铁轨并不是只能停一辆火车，一开始理解错题目了，苦想用例答案为什么会是四</p><p><img src="/posts/36741/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230321212027.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><img src="/posts/36741/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230321212844.png"></p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Trial.列车调度;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class p01_1 &#123;</span><br><span class="line">    static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">    static StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line">    static Stack&lt;Stack&lt;Integer&gt;&gt; mp = new Stack&lt;&gt;();</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        inItStack();</span><br><span class="line">        int n = readInt();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            int c = readInt();</span><br><span class="line">            add(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(mp.size());</span><br><span class="line">    &#125;</span><br><span class="line">    static void inItStack () &#123;</span><br><span class="line">        Stack&lt;Integer&gt; item = new Stack&lt;&gt;();</span><br><span class="line">        item.add(1000000);</span><br><span class="line">        mp.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void add(int c) &#123;</span><br><span class="line">        for (int i = 0; i &lt; mp.size(); i++) &#123;</span><br><span class="line">            int temp = mp.get(i).peek();</span><br><span class="line">            if (c &lt; temp) &#123;</span><br><span class="line">                mp.get(i).add(c);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; item = new Stack&lt;&gt;();</span><br><span class="line">        item.add(c);</span><br><span class="line">        mp.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int readInt() throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return (int)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己用栈模拟的代码最后果然不出我所料，超时了，然后在网上找到了一份比较有技术含量的题解</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Trial.列车调度;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.BufferedWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.io.OutputStreamWriter;</span><br><span class="line">import java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class copy &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Reader.init(System.in);</span><br><span class="line">        Writer.init(System.out);</span><br><span class="line">        solve();</span><br><span class="line">        Writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void solve() throws IOException &#123;</span><br><span class="line">        int n = Reader.nextInt();</span><br><span class="line">        map = new int[n];</span><br><span class="line">        int count = 0;</span><br><span class="line">        map[count++] = Reader.nextInt();</span><br><span class="line">        n--;</span><br><span class="line">        while (n-- &gt; 0) &#123;</span><br><span class="line">            int id = Reader.nextInt();</span><br><span class="line">            if (map[count-1] &lt; id) &#123;</span><br><span class="line">                map[count++] = id;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            int low = 0;</span><br><span class="line">            int high = count - 1;</span><br><span class="line">            while (low &lt; high) &#123;</span><br><span class="line">                int mid = (low + high) &gt;&gt; 1;</span><br><span class="line">                if (id &lt; map[mid]) &#123;</span><br><span class="line">                    high = mid;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    low = mid + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map[low] = id;</span><br><span class="line">        &#125;</span><br><span class="line">        Writer.print(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int[] map;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Class for buffered reading int and double values *//*</span><br><span class="line">class Reader &#123;</span><br><span class="line">    static BufferedReader reader;</span><br><span class="line">    static StringTokenizer tokenizer;</span><br><span class="line"></span><br><span class="line">    // ** call this method to initialize reader for InputStream *//*</span><br><span class="line">    static void init(InputStream input) &#123;</span><br><span class="line">        reader = new BufferedReader(new InputStreamReader(input));</span><br><span class="line">        tokenizer = new StringTokenizer(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ** get next word *//*</span><br><span class="line">    static String next() throws IOException &#123;</span><br><span class="line">        while (!tokenizer.hasMoreTokens()) &#123;</span><br><span class="line">            // TODO add check for eof if necessary</span><br><span class="line">            tokenizer = new StringTokenizer(reader.readLine());</span><br><span class="line">        &#125;</span><br><span class="line">        return tokenizer.nextToken();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String nextLine() throws IOException &#123;</span><br><span class="line">        return reader.readLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int nextInt() throws IOException &#123;</span><br><span class="line">        return Integer.parseInt(next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char nextChar() throws IOException &#123;</span><br><span class="line">        return next().toCharArray()[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static float nextFloat() throws IOException &#123;</span><br><span class="line">        return Float.parseFloat(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Writer &#123;</span><br><span class="line">    static BufferedWriter writer;</span><br><span class="line"></span><br><span class="line">    static void init(OutputStream outputStream) &#123;</span><br><span class="line">        writer = new BufferedWriter(new OutputStreamWriter(outputStream));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void print(Object object) throws IOException &#123;</span><br><span class="line">        writer.write(object.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void println(Object object) throws IOException &#123;</span><br><span class="line">        writer.write(object.toString());</span><br><span class="line">        writer.write(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void close() throws IOException &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我将快读写成了方法以为很好用了，没想到有人竟然将快读跟快输都写成了类，这里面的读入方法我还没试过，比较好奇的是他能不能实现对一个单词中的挨个字符进行读取。。。。。要不现在先试试吧。。。刚试了试。。。也会跳过，算了算了，只不过他这种编程的思路可以借鉴，自己重写一个专门用于读入和输出的类</p><p>再说一说思路，我是用栈模拟，但实际上栈中储存了什么，储存了多少并不重要，重要的 是栈的大小罢了，他用的一维数组进行模拟，数组中的一个元素就相当于我一条栈的入口，如果一个元素符合进栈的要求就直接把数据存进该位置最后计算数组中元素不为0，也就是入口不为空的元素有多少个就可以了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红色警报</title>
      <link href="/posts/63117.html"/>
      <url>/posts/63117.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="红色警报"><a href="#红色警报" class="headerlink" title="红色警报"></a>红色警报</h1><p>并查集使用第二弹，上次使用并查集是体会了集合的合并于查找，这次的题目让我体会了什么是“维护联通性”，在这个题目中，我们依然使用一个二维数组来储存两个对象之间的关系，上次是保存两个人之间是不是仇敌，这次是保存两个城市之间是否联通，而且学到一个新词，连通块</p><p>先上题目</p><p><img src="/posts/63117/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320215946.png"></p><p><img src="/posts/63117/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320215946.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在这个题目中，我们首先使用一个二维数组储存两个城市之间是否连续的逻辑关系，并且在并查集数组将两个互相连通的元素合并到一个集合当中，这时候，连通块的概念就出现了，连通块其实指的就是集合中公最远公共祖先的数量，也就是集合的数目，假设有五个城市，其中三个是连通的，算是集合A，另外两个也是连通的，算是集合B，这两个集合之间不连通，那么这两个集合就会有两个代表元素，两个公共祖先，如果集合A中的三个元素之间的连接断开了，那么这时候集合中就有四个连通块，通过查询并查集中连通块的数目我们就可以知道一个城市被攻占之后是否会对其他城市的连通性产生影响</p><p>所以在这个题目中，我们首先使用一个二维数组储存两个城市之间是否连续的逻辑关系，并且在并查集数组将两个互相连通的元素合并到一个集合当中，记录原本的连通块数量，如果一个城市被攻占，那么我们改变二维数组中的值，然后根据二维数组中的值去重新构建一个并查集，然后计算其中连通块的数量，如果两次的连通块数量相等或者比原来的多一个（被攻占的城市自己也算一个连通块）相等，那么这一个城市被攻占就不会对其他城市的连通性产生影响（反正如果连通块增加数量大于一那就是出问题了）反之则会</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Trial.红色警报;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line">import java.math.BigInteger;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class 红色警报 &#123;</span><br><span class="line">    static int[] a = new int[510];</span><br><span class="line">    static int[][] aa = new int[510][510];</span><br><span class="line">    static int n = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int cnt = 0;//原本连通块数量</span><br><span class="line">        int cnt2 = 0;//修改后连通块数量</span><br><span class="line">        int flag = 0;//判断是否GAMEOVER</span><br><span class="line"></span><br><span class="line">        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line">        st.nextToken();</span><br><span class="line">        n = (int)st.nval;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        int m = (int)st.nval;</span><br><span class="line">        inIt();</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int n1 = (int)st.nval;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int n2 = (int)st.nval;</span><br><span class="line">            aa[n1][n2] = aa[n2][n1] = 1;</span><br><span class="line">            union(n1, n2);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (i == find(i)) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        int k = (int)st.nval;</span><br><span class="line">        if (k == n) &#123;</span><br><span class="line">            flag = 1;</span><br><span class="line">        &#125;</span><br><span class="line">            for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                int x = (int)st.nval;</span><br><span class="line">                inIt();</span><br><span class="line">                cnt2 = 0;</span><br><span class="line">                for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                    aa[x][j] = aa[j][x] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                    for (int l = 0; l &lt; n; l++) &#123;</span><br><span class="line">                        if (aa[j][l] == 1) union(j, l);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                    if (j == find(j)) cnt2++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (cnt2 &lt;= cnt + 1) &#123;</span><br><span class="line">                    System.out.println(&quot;City &quot;+x+&quot; is lost.&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.println(&quot;Red Alert: City &quot;+x+&quot; is lost!&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                cnt = cnt2;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        if (flag == 1) &#123;</span><br><span class="line">            System.out.println(&quot;Game Over.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void inIt () &#123;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            a[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int find (int i) &#123;</span><br><span class="line">        if (a[i] == i) &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return a[i] = find(a[i]);//依然cai&#x27;qu</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void union (int i, int j) &#123;</span><br><span class="line">        int iF = find(i);</span><br><span class="line">        int jF = find(j);</span><br><span class="line">        if (iF != jF) &#123;</span><br><span class="line">            a[jF] = iF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转二叉树</title>
      <link href="/posts/29808.html"/>
      <url>/posts/29808.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="玩转二叉树"><a href="#玩转二叉树" class="headerlink" title="玩转二叉树"></a>玩转二叉树</h1><p>幸好假期自学了数据结构，能看得出知识点在哪</p><p>1.根据前序遍历和中序遍历构造二叉树</p><p>2.镜面反转</p><p>3.二叉树的层序遍历</p><p><img src="/posts/29808/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320215946.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先是根据前序遍历和中序遍历来构建二叉树</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; inorder.length; i++) &#123; // 用map保存中序序列的数值对应位置</span><br><span class="line">        map.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return findNode(preorder, 0, preorder.length, inorder,  0, inorder.length);  // 前闭后开</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public TreeNode findNode(int[] preorder, int preBegin, int preEnd, int[] inorder, int inBegin, int inEnd) &#123;</span><br><span class="line">    // 参数里的范围都是前闭后开</span><br><span class="line">    if (preBegin &gt;= preEnd || inBegin &gt;= inEnd) &#123;  // 不满足左闭右开，说明没有元素，返回空树</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int rootIndex = map.get(preorder[preBegin]);  // 找到前序遍历的第一个元素在中序遍历中的位置</span><br><span class="line">    TreeNode root = new TreeNode(inorder[rootIndex]);  // 构造结点</span><br><span class="line">    int lenOfLeft = rootIndex - inBegin;  //// 保存中序左子树个数（结点位置，减去中序开始位置），用来确定前序数列的个数</span><br><span class="line">    //这里思路要非常清楚除非想陷入改bug地狱，尤其是在处理前序遍历下标的时候</span><br><span class="line">    root.left = findNode(preorder, preBegin + 1, preBegin + lenOfLeft + 1,//前序遍历结束位置等于前序开始位置加上左子树大小加上一</span><br><span class="line">            inorder, inBegin, rootIndex);</span><br><span class="line">    root.right = findNode(preorder, preBegin + lenOfLeft + 1, preEnd,//开始位置等于前序开始位置加上左子树个数</span><br><span class="line">            inorder, rootIndex + 1, inEnd);</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法看着复杂其实也就还行，首先是建树的方法，我们往这个方法里传入两个数组，也就是前序遍历和中续遍历的结果，先用哈希表将数组元素变成下标以便我们找到对应的数据，方便我们直接根据某个值直接找到对应元素的位置然后使用findNode方法构造结点</p><p>findNode方法包含六个参数，前序数组，开始位置，结束位置，中序数组，开始位置，结束位置（注意全部都是左闭右开）如果开始位置大于等于结束位置，说明没有元素，返回空结点，如果存在元素，则找到前序数组中第一个元素在中序数组中的位置，然后构造新节点，在确定左子树元素个数，将左子树返回值赋给左节点，右子树返回值赋给右结点，完事，返回当前结点</p><p>镜像交换比较简单，直接上代码</p><p>&#96;&#96;注意是否为叶子结点即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void change (Node a) &#123;</span><br><span class="line">    if (a == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125; else if (a.leftNode == null &amp;&amp; a.rightNode == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Node cur = a.rightNode;</span><br><span class="line">        a.rightNode = a.leftNode;</span><br><span class="line">        a.leftNode = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    change(a.leftNode);</span><br><span class="line">    change(a.rightNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层序遍历我还没想到有可以在迭代的过程中打印的，我用的递归，存在二维链表中，结束后再打印链表中元素，注意要传入一个参数来判断深度是否需要增加新的链表</p><p><code>static List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void cengXu (Node a, int deep) &#123;</span><br><span class="line">    if (a == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    deep++;</span><br><span class="line">    if (ans.size() &lt; deep) &#123;</span><br><span class="line">        List&lt;Integer&gt; item = new ArrayList&lt;&gt;();</span><br><span class="line">        ans.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.get(deep - 1).add(a.num);</span><br><span class="line">    cengXu(a.leftNode, deep);</span><br><span class="line">    cengXu(a.rightNode, deep);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class 二叉树 &#123;</span><br><span class="line">    static Map&lt;Integer, Integer&gt; map;</span><br><span class="line">    static List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line">        st.nextToken();</span><br><span class="line">        int n = (int)st.nval;</span><br><span class="line">        int[] zx = new int[n];</span><br><span class="line">        int[] qx = new int[n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            zx[i] = (int)st.nval;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            qx[i] = (int)st.nval;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node first = createTree(qx, zx);</span><br><span class="line">        change(first);</span><br><span class="line"></span><br><span class="line">        int deep = 0;</span><br><span class="line">        cengXu(first, deep);</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; ans.size(); i++) &#123;</span><br><span class="line">            for (int i1 = 0; i1 &lt; ans.get(i).size(); i1++) &#123;</span><br><span class="line">                sb.append(ans.get(i).get(i1)+&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sb.deleteCharAt(sb.length() - 1);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排座位</title>
      <link href="/posts/55749.html"/>
      <url>/posts/55749.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="排座位"><a href="#排座位" class="headerlink" title="排座位"></a>排座位</h1><p><img src="/posts/55749/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320213126.png"></p><p><img src="/posts/55749/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320213137.png"></p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集是一种用于处理集合合并及查询问题的数据结构，在并查集种，每个元素都有一个父节点，表示它所属的集合。并查集支持两种操作：合并两个集合和查询某个元素所在的集合。其中查询操作通常用于检测两个元素是否属于同一个集合</p><p>并查集的基本思想是将元素分组，每个组内元素之间存在一种特殊的关系，可以通过这种关系来判断元素是否属于同一个集合，在并查集种，每个元素都有一个代表元，也称为根结点，也是公共祖先，表示该元素所属的集合。当两个集合需要合并时，只需要将其中一个集合的根节点设置为 另一个集合的根节点即可。这样，就可以将两个集合合并为一个集合</p><p>并查集的主要应用场景包括网络连通性问题，图的连通性问题等。</p><p>并查集来维护一组联通的结点，快速查询两个结点之间是否存在联通路径</p><p>实现</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Q2016.排座位;</span><br><span class="line"></span><br><span class="line">public class 并查集 &#123;</span><br><span class="line">    public static int[] a = new int[100000];</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //合并两个东西合并两个东西，可以为元素与元素，也可以为集合与集合，也可以为集合与元素</span><br><span class="line">    public static void union (int i, int j) &#123;</span><br><span class="line">        int iFather = find(i);//查找i的祖先</span><br><span class="line">        int jFather = find(j);//查找j的祖先</span><br><span class="line">        a[jFather] = iFather;//j的祖先指向i的祖先</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //普通查找，如果需要查找的次数多，不建议用此方法</span><br><span class="line">    public static int find(int i) &#123;</span><br><span class="line">        if (a[i] == i) &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return find(a[i]); //查找父节点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //压缩路径，让一条链表上的所有元素全部指向他们的公共祖先，如果需要多次查找建议使用</span><br><span class="line">    public static int ys (int i) &#123;</span><br><span class="line">        if (a[i] == i) &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            a[i] = ys(a[i]);</span><br><span class="line">            return a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化,理解，位置，与位置储存数值的含义</span><br><span class="line">    public static void inIt (int[] a) &#123;</span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/55749/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320214020.png">一堆元素</p><p><img src="/posts/55749/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320214826.png"></p><p>存在关系，合并之后</p><p><img src="/posts/55749/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320214831.png"></p><p>压缩路径之后的样子</p><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><p>那么这个题目最大的难点就在于我们如何判断两个人之间是否有公共朋友，这个我们就可以使用并查集，把是朋友的分到一个集合当中，通过查找一个元素与一个元素之间是否存在公共祖先就可以快速判断两个人是否有公共朋友</p><p>而且我们可以使用一个二维数组来储存两个人时间的关系，（新的数据安排）</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Q2016.排座位;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line">public class 排座位 &#123;</span><br><span class="line">    public static int[] a = new int[110];//并查集</span><br><span class="line">    public static int[][] aa = new int[110][110];//存关系</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line">        st.nextToken();</span><br><span class="line">        int n = (int)st.nval;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        int m = (int)st.nval;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        int k = (int)st.nval;</span><br><span class="line">        inIt();</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int b1 = (int)st.nval;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int b2 = (int)st.nval;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int gx = (int)st.nval;</span><br><span class="line">            if (gx == -1) &#123;//如果是死对头，矩阵中进行标记</span><br><span class="line">                aa[b1][b2] = aa[b2][b1] = -1;</span><br><span class="line">            &#125; else &#123;//如果是朋友，进行合并</span><br><span class="line">                union(b1, b2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int c1 = (int)st.nval;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int c2 = (int)st.nval;</span><br><span class="line">            if (ys(c1) == ys(c2) &amp;&amp; aa[c1][c2] != -1) &#123;//有公共朋友，不是敌人</span><br><span class="line">                System.out.println(&quot;No problem&quot;);</span><br><span class="line">            &#125; else if (ys(c1) == ys(c2) &amp;&amp; aa[c1][c2] == -1) &#123;//有公共朋友，是敌人</span><br><span class="line">                System.out.println(&quot;OK but...&quot;);</span><br><span class="line">            &#125; else if (ys(c1) != ys(c2) &amp;&amp; aa[c1][c2] != -1) &#123;//无公共朋友，不是敌人</span><br><span class="line">                System.out.println(&quot;OK&quot;);</span><br><span class="line">            &#125; else if (ys(c1) != ys(c2) &amp;&amp; aa[c1][c2] == -1) &#123;//无公共朋友，是敌人</span><br><span class="line">                System.out.println(&quot;No way&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//初始化——让元素的祖先变成自己</span><br><span class="line">    public static void inIt () &#123;</span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//压缩路径</span><br><span class="line">    public static int ys(int i) &#123;</span><br><span class="line">        if (a[i] == i) &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            a[i] = ys(a[i]);</span><br><span class="line">            return a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//合并</span><br><span class="line">    public static void union (int i, int j) &#123;</span><br><span class="line">        int iF = ys(i);</span><br><span class="line">        int jF = ys(j);</span><br><span class="line">        a[jF] = iF;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抢红包</title>
      <link href="/posts/37296.html"/>
      <url>/posts/37296.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="抢红包"><a href="#抢红包" class="headerlink" title="抢红包"></a>抢红包</h1><p> 这个题目首先想到的就是对对象进行排序，但是不出意料的超时了，然后将对象换成数组，加深了我对Arrarys.sort方法的理解，让我重洗思考了数据的安排，和重新看待二维数组</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/posts/37296/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320211541.png"></p><p><img src="/posts/37296/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320211603.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Q2016.抢红包;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line"></span><br><span class="line">class person &#123;</span><br><span class="line">    int count;</span><br><span class="line">    int name;</span><br><span class="line">    double sr;</span><br><span class="line"></span><br><span class="line">    public person(int name, double sr) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.sr = sr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class 抢红包 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line">        st.nextToken();</span><br><span class="line">        int n = (int)st.nval;</span><br><span class="line">        person[] ar = new person[n + 1];</span><br><span class="line">        for (int i = 0; i &lt; ar.length; i++) &#123;</span><br><span class="line">            ar[i] = new person(i, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int k = (int)st.nval;</span><br><span class="line">            for (int j = 0; j &lt; k; j++) &#123;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                int nn = (int)st.nval;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                int pp = (int)st.nval;</span><br><span class="line">                ar[nn].sr += pp;</span><br><span class="line">                ar[i].sr -= pp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">//这部分出错，排序依据先是收入，再是抢红包个数，再是名字</span><br><span class="line">        Arrays.sort(ar, new Comparator&lt;person&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(person o1, person o2) &#123;</span><br><span class="line">                if (o1.sr &gt; o2.sr) &#123;//sr是double</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125; else if (o1.sr &lt; o2.sr) &#123;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (o1.name &gt; o2.name) &#123;//name是字符串</span><br><span class="line">                        return 1;</span><br><span class="line">                    &#125; else if (o1.name &lt; o2.name)&#123;</span><br><span class="line">                        return -1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        for (int i = ar.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            if (ar[i].name != 0) &#123;</span><br><span class="line">                System.out.print(ar[i].name+&quot; &quot;);</span><br><span class="line">                System.out.printf(&quot;%.2f&quot;,ar[i].sr / 100);</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一思路，尝试对对象数组进行排序，然后重写比较器</p><p>&#96;&#96;精简比较器部分代码，并改进其中错误</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.sort(ar, new Comparator&lt;person&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public int compare(person o1, person o2) &#123;</span><br><span class="line">               if (o1.sr != o2.sr) &#123;</span><br><span class="line">                   return Double.compare(o1.sr, o2.sr);</span><br><span class="line">               &#125; else if (o1.count != o2.count) &#123;</span><br><span class="line">                   return Integer.compare(o1.count, o2.count);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   return Integer.compare(o2.name, o1.name);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p>错误改进1</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class 抢红包_3 &#123;</span><br><span class="line">    public static int[][] person = new int[3][10010];</span><br><span class="line">    //sr</span><br><span class="line">    //count</span><br><span class="line">    //name;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line">        st.nextToken();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 10010; i ++) &#123;</span><br><span class="line">            person[2][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int n = (int)st.nval;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt;= n; i ++) &#123;</span><br><span class="line">            person[2][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int k = (int)st.nval;</span><br><span class="line">            for (int j = 0; j &lt; k; j++) &#123;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                int nn = (int)st.nval;//谁</span><br><span class="line">                st.nextToken();</span><br><span class="line">                int pp = (int)st.nval;//强到了多少</span><br><span class="line">                person[0][nn] += pp;</span><br><span class="line">                person[1][nn] ++;</span><br><span class="line">                person[0][i] -= pp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(person, 1, n + 1, Comparator.comparingInt(a -&gt; a[0]));</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            System.out.println(person[2][i]+&quot; &quot;+person[1][i]+&quot; &quot;+person[0][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个首先数据的安排就有问题，很明显，一列就相当于一个person第一行为收入，我们如果要根据第一行的收入进行排序，那么我们在sort里面就要交换三个元素，交换三个什么东西，但是Arrays.sort()只允许我们重写其中的比较方法不能重写交换的方法，那么我们一次就只能交换一个什么东西，所以无法用它对这个二维数组进行排序，除非我们自己手写sort方法，要不然就不行</p><p>正确答案</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Q2016.抢红包;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line"></span><br><span class="line">public class 抢红包_4 &#123;</span><br><span class="line">    public static int[][] per = new int[10010][3];</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line">        st.nextToken();</span><br><span class="line">        int n = (int)st.nval;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            per[i][2] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int k = (int)st.nval;</span><br><span class="line">            for (int j = 0; j &lt; k; j++) &#123;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                int nn = (int)st.nval;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                int pp = (int)st.nval;</span><br><span class="line">                per[nn][0] += pp;</span><br><span class="line">                per[nn][1] ++;</span><br><span class="line">                per[i][0] -= pp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(per,  1, n + 1, new Comparator&lt;int[]&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(int[] o1,int[] o2) &#123;</span><br><span class="line">                if (o1[0] != o2[0]) &#123;</span><br><span class="line">                    return Integer.compare(o2[0],o1[0]);</span><br><span class="line">                &#125; else if (o1[1] != o2[1]) &#123;</span><br><span class="line">                    return Integer.compare(o2[1],o1[1]);//默认少在前</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return Integer.compare(o1[2],o2[2]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            System.out.print(per[i][2] +&quot; &quot;);</span><br><span class="line">            System.out.printf(&quot;%.2f&quot; , per[i][0] * 1.0 / 100);;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次我们一行就是一个元素，就是一个人，这个就可以在Arrays.sort中进行排序这个时候我们交换的就是其中的一个子数组</p><p>反正这个题目对我这种彩笔来说挺典型的，尤其是对数据结构的安排上</p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA错题第三次收录</title>
      <link href="/posts/20284.html"/>
      <url>/posts/20284.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="嘟嘟可大骑士的犯二手册三"><a href="#嘟嘟可大骑士的犯二手册三" class="headerlink" title="嘟嘟可大骑士的犯二手册三"></a>嘟嘟可大骑士的犯二手册三</h2><p>这次只有一道题，这次犯的错误提醒我应该认真仔细的去考虑输入输出的问题，前两次已经看到了输出类型00000，说明数字不足五位数应该加上前导零，然后这个提示的输入。。。。非常有意思</p><h3 id="正整数A-B"><a href="#正整数A-B" class="headerlink" title="正整数A+B"></a>正整数A+B</h3><p><img src="/posts/20284/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230317140339.png"></p><p>至少存在一个空格，且第一个空格认为是A与B的分隔，说明第一个字符串不可能为空字符串，所以我十分有信心的写了下面的代码</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Trial;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class P1 &#123;</span><br><span class="line">    public static int aaa;</span><br><span class="line">    public static int bbb;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        String a = sc.nextLine();</span><br><span class="line">        String b = sc.nextLine();</span><br><span class="line">        char[] aa = a.toCharArray();</span><br><span class="line">        char[] bb = b.toCharArray();</span><br><span class="line">        //Arrays.copyOfRange()</span><br><span class="line">        boolean a1 = check(aa,a);</span><br><span class="line">        boolean a2 = check(bb,b);</span><br><span class="line"></span><br><span class="line">        if (a1 &amp;&amp; a2) &#123;</span><br><span class="line">            aaa = Integer.parseInt(a);</span><br><span class="line">            bbb = Integer.parseInt(b);</span><br><span class="line">            int c = aaa + bbb;</span><br><span class="line">            System.out.println(aaa+&quot; + &quot;+bbb+&quot; = &quot;+c);</span><br><span class="line">        &#125; else if (!a1 &amp;&amp; !a2) &#123;</span><br><span class="line">            System.out.println(&quot;? + ? = ?&quot;);</span><br><span class="line">        &#125; else if (a1 &amp;&amp; !a2) &#123;</span><br><span class="line">            aaa = Integer.parseInt(a);</span><br><span class="line">            System.out.println(aaa+&quot; + ? = ?&quot;);</span><br><span class="line">        &#125; else if (!a1 &amp;&amp; a2) &#123;</span><br><span class="line">            bbb = Integer.parseInt(b);</span><br><span class="line">            System.out.println(&quot;? + &quot; + bbb +&quot; = ?&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static boolean check(char[] a, String aa) &#123;</span><br><span class="line"></span><br><span class="line">        if (a.length &gt; 4) return false;</span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            if (a[i] &gt;= &#x27;0&#x27; &amp;&amp; a[i] &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int c = Integer.parseInt(aa);</span><br><span class="line">        if (c &gt; 1000 || c &lt; 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个测试点不能通过，用例是    输入  123 123 123 输出应该为123 + ？&#x3D; ？</p><p>题目中说至少存在一个空格，且无空字符串，但是可以有多个空格，在上面的例子由于我读取方法的错误所以得到的答案是123 + 123 &#x3D; 246 ，也就是说，我因为没有考虑到后面也有空格的情况从而让b少读取了一半</p><p>下面是修改后的代码</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Trial;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class P1 &#123;</span><br><span class="line">    public static int aaa;</span><br><span class="line">    public static int bbb;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        String aaaa = sc.nextLine();</span><br><span class="line">        String[] st = cf(aaaa);</span><br><span class="line">        String a = st[0];</span><br><span class="line">        String b = st[1];</span><br><span class="line">        char[] aa = a.toCharArray();</span><br><span class="line">        char[] bb = b.toCharArray();</span><br><span class="line">        //Arrays.copyOfRange()</span><br><span class="line">        boolean a1 = check(aa,a);</span><br><span class="line">        boolean a2 = check(bb,b);</span><br><span class="line"></span><br><span class="line">        if (a1 &amp;&amp; a2) &#123;</span><br><span class="line">            aaa = Integer.parseInt(a);</span><br><span class="line">            bbb = Integer.parseInt(b);</span><br><span class="line">            int c = aaa + bbb;</span><br><span class="line">            System.out.println(aaa+&quot; + &quot;+bbb+&quot; = &quot;+c);</span><br><span class="line">        &#125; else if (!a1 &amp;&amp; !a2) &#123;</span><br><span class="line">            System.out.println(&quot;? + ? = ?&quot;);</span><br><span class="line">        &#125; else if (a1 &amp;&amp; !a2) &#123;</span><br><span class="line">            aaa = Integer.parseInt(a);</span><br><span class="line">            System.out.println(aaa+&quot; + ? = ?&quot;);</span><br><span class="line">        &#125; else if (!a1 &amp;&amp; a2) &#123;</span><br><span class="line">            bbb = Integer.parseInt(b);</span><br><span class="line">            System.out.println(&quot;? + &quot; + bbb +&quot; = ?&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String[] cf (String a) &#123;</span><br><span class="line">        String[] k = new String[2];</span><br><span class="line">        int idx = 0;</span><br><span class="line">        char[] kk = a.toCharArray();</span><br><span class="line">        for (int i = 0; i &lt; kk.length; i++) &#123;</span><br><span class="line">            if (kk[i] == &#x27; &#x27;) &#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        char[] aa = Arrays.copyOfRange(kk, 0, idx);</span><br><span class="line">        char[] bb = Arrays.copyOfRange(kk, idx + 1, kk.length);</span><br><span class="line">        k[0] = String.valueOf(aa);</span><br><span class="line">        k[1] = String.valueOf(bb);</span><br><span class="line">        return k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean check(char[] a, String aa) &#123;</span><br><span class="line"></span><br><span class="line">        if (a.length &gt; 4) return false;</span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            if (a[i] &gt;= &#x27;0&#x27; &amp;&amp; a[i] &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int c = Integer.parseInt(aa);</span><br><span class="line">        if (c &gt; 1000 || c &lt; 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入输出~~~这是一个问题~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PTA错题第二次收录</title>
      <link href="/posts/59175.html"/>
      <url>/posts/59175.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="嘟嘟可大骑士的犯二手册二"><a href="#嘟嘟可大骑士的犯二手册二" class="headerlink" title="嘟嘟可大骑士的犯二手册二"></a>嘟嘟可大骑士的犯二手册二</h2><p>没错新一期的错题集，这次在刷题的时候我对修改的不同版本的代码进行保存，通过比较自己的第一思路与修改后通过的的代码之间的不同来发现自己哪些地方犯二</p><h3 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h3><p><img src="/posts/59175/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230317132515.png"></p><p>这个题目与2016年区域赛帅到没朋友非常相似，使用类似桶排的方法进行统计，然后遍历一次数组来确定答案，虽然并没有错但是当个典型题收集一下</p><p><img src="/posts/59175/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230317132904.png"></p><p>使用了快读，复习快读基本用法</p><h3 id="古风排序"><a href="#古风排序" class="headerlink" title="古风排序"></a>古风排序</h3><p><img src="/posts/59175/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230317134143.png"></p><p>这个题目相当有意思，我修改了两个版本的代码，两个代码之间只有一个区别，那就是是否对二维字符数组钟非原字符数组的部分进行初始化，虽然两者运行之后输出的答案一模一样，但是一个只能对三个测试点</p><p><img src="/posts/59175/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230317134409.png" alt="未对数组空白部分进行初始化"></p><p><img src="/posts/59175/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230317134437.png" alt="将数组空白部分打印为空格"></p><p>在Java中，如果一个char类型数组未被完全初始化，那么未被初始化的元素将被赋予默认值’\u0000’（null字符）。而在打印此元素时，可能会输出类似于空格的空白字符，因此上面两个代码在控制台中的输出看起来是一模一样的，然而实际上两个输出的值却并不相同</p><p><img src="/posts/59175/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230317134954.png"></p><p>这个题目看起来简单，实际上也很简单，只不过这个是我第一用快读尝试字符数字的混合读取，而且似乎让我找到了读取单个字符的方法</p><p><img src="/posts/59175/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230317135104.png"></p><p>只不过这个提醒了我现在依然存在的一个问题，那对这些输入输出的使用，原理，可以读取哪些内容，怎样读取这些内容还是不够熟悉。相当有必要认真学一下BuffereReader这个类</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PTA错题第一次收录</title>
      <link href="/posts/24812.html"/>
      <url>/posts/24812.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​唉感觉自己好菜，别人用几毫秒，几百kb就能做的题目我得用一百多毫秒，几千kb想想就心酸啊，这是pta错题第一次收录，希望能给自己长点记性</p><h3 id="判断素数"><a href="#判断素数" class="headerlink" title="判断素数"></a>判断素数</h3><p><img src="/posts/24812/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230316215838.png">&#96;</p><p>原本以为是因为读入数据的速度太慢，结果发现是因为自己少了特判 “  1  “，算是因祸得福吧，学了快输</p><p><img src="/posts/24812/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230316220118.png" alt="改进后的代码"></p><h3 id="到底有多二"><a href="#到底有多二" class="headerlink" title="到底有多二"></a>到底有多二</h3><p><img src="/posts/24812/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230316220258.png"></p><p>这个题目算是给我提了个醒，顺着题目的思路来看不清楚如果一位正数，且为偶数的数最后要不要乘二，但这不是因为她没说清楚，在以后的工作中应该很少有客户能直接说清楚自己的需求，但是在这个题目里如果在这里错了那我就应该往这个我不太清楚的地方去思考正数的偶数是不是也要乘二，其实错了并不奇怪，但是关键的是错了之后要知道往哪个地方去怀疑</p><p><code>错误代码</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Q2016;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class p01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        String a = sc.next();</span><br><span class="line">        double er = 0;</span><br><span class="line">        double ws = 0;</span><br><span class="line">        double ans = 0;</span><br><span class="line">        boolean fs = false;</span><br><span class="line">        boolean os = false;</span><br><span class="line"></span><br><span class="line">        char[] aa = a.toCharArray();</span><br><span class="line">        if (aa[0] == &#x27;-&#x27;) &#123;</span><br><span class="line">            fs = true;</span><br><span class="line">        &#125;</span><br><span class="line">        int cur = aa[aa.length - 1] - &#x27;0&#x27;;</span><br><span class="line">        if (cur % 2 == 0) &#123;</span><br><span class="line">            os = true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; aa.length; i++) &#123;</span><br><span class="line">            if ((aa[i] - &#x27;0&#x27;) == 2) &#123;</span><br><span class="line">                er++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (fs) &#123;</span><br><span class="line">            ws = aa.length - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ws = aa.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (fs) &#123;</span><br><span class="line">            if (os) &#123;</span><br><span class="line">                ans = er /ws * 1.5 * 2 * 100;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ans = er /ws * 1.5 * 100;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (os) &#123;</span><br><span class="line">                ans = er /ws * 1.0 * 2 * 100;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ans = er/ws * 1.0 * 100;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">            System.out.printf(&quot;%.2f&quot;, ans);</span><br><span class="line">            System.out.println(&quot;%&quot;);</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>正确代码</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Q2016;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class p01_1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        int ws = 0;</span><br><span class="line"></span><br><span class="line">        double er = 0;</span><br><span class="line">        double bs = 1;</span><br><span class="line">        double bss = 1;</span><br><span class="line">        double ans = 0;</span><br><span class="line"></span><br><span class="line">        String a = sc.next();</span><br><span class="line">        char[] aa = a.toCharArray();</span><br><span class="line">        if (aa[0] == &#x27;-&#x27;) &#123;</span><br><span class="line">            bs = 1.5;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ws = aa.length;</span><br><span class="line"></span><br><span class="line">        if (aa[aa.length - 1]%2 == 0) &#123;</span><br><span class="line">            bss = 2;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; aa.length; i++) &#123;</span><br><span class="line">            if (aa[i] == &#x27;2&#x27;) &#123;</span><br><span class="line">                er++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (aa[0] == &#x27;-&#x27;) &#123;</span><br><span class="line">            ws = ws - 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = er / ws * bs * bss * 100;</span><br><span class="line">        System.out.printf(&quot;%.2f&quot;, ans);</span><br><span class="line">        System.out.print(&quot;%&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大笨钟"><a href="#大笨钟" class="headerlink" title="大笨钟"></a>大笨钟</h3><p><img src="/posts/24812/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230316220751.png"></p><p>这个题目在端点时间理解错了，以为端点时间是12：00，但结果在12点的时候都不敲而且我的代码思路不够好</p><p><code>这个是我的垃圾代码</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Q2016;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class p01_1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        int ws = 0;</span><br><span class="line"></span><br><span class="line">        double er = 0;</span><br><span class="line">        double bs = 1;</span><br><span class="line">        double bss = 1;</span><br><span class="line">        double ans = 0;</span><br><span class="line"></span><br><span class="line">        String a = sc.next();</span><br><span class="line">        char[] aa = a.toCharArray();</span><br><span class="line">        if (aa[0] == &#x27;-&#x27;) &#123;</span><br><span class="line">            bs = 1.5;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ws = aa.length;</span><br><span class="line"></span><br><span class="line">        if (aa[aa.length - 1]%2 == 0) &#123;</span><br><span class="line">            bss = 2;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; aa.length; i++) &#123;</span><br><span class="line">            if (aa[i] == &#x27;2&#x27;) &#123;</span><br><span class="line">                er++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (aa[0] == &#x27;-&#x27;) &#123;</span><br><span class="line">            ws = ws - 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = er / ws * bs * bss * 100;</span><br><span class="line">        System.out.printf(&quot;%.2f&quot;, ans);</span><br><span class="line">        System.out.print(&quot;%&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">        using namespace std;</span><br><span class="line">        int main()&#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        scanf(&quot;%02d:%02d&quot;,&amp;a,&amp;b);</span><br><span class="line">        if(a&lt;=12)&#123;</span><br><span class="line">        printf(&quot;Only %02d:%02d.  Too early to Dang.&quot;,a,b);</span><br><span class="line">        &#125;else if(b==0)&#123;</span><br><span class="line">        for(int i=0;i&lt;(a-12);i++)&#123;</span><br><span class="line">        printf(&quot;Dang&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;else if(b&gt;0)&#123;</span><br><span class="line">        for(int i=0;i&lt;=(a-12);i++)&#123;</span><br><span class="line">        printf(&quot;Dang&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是别人的思路清晰且相当简洁的代码，学习，学习</p><h3 id="帅到没朋友"><a href="#帅到没朋友" class="headerlink" title="帅到没朋友"></a>帅到没朋友</h3><p><img src="/posts/24812/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230316221446.png"></p><p>这个题目相当有意思</p><p>我的第一思路是创建二维数组，然后遍历，但是越看越不对，因为相当可能会超时，然后我想到了桶排，虽然我能往这个思路靠，但是还是相当复杂，我的打算是用类似桶排的方法储存一个数出现的坐标，然后要查的时候遍历坐标所在的数组，但是后来我发现一个数可能出现在多个位置，所以储存坐标的想法并不可靠</p><p>答案的思想是利用类似桶排序的方法直接在读入数据的时候进行标记</p><p><img src="/posts/24812/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230316221716.png" alt="第一版代码"></p><p>这个代码在写的时候光想着当k&#x3D;&#x3D;1的时候不进行操作，结果忘记虽然不操作但数依然得读</p><p>而且这个题目有一个相当细节的地方  0 的写法是 00000 无论如何都得凑足五位数，所以输出部分也是错的</p><p><img src="/posts/24812/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230316222310.png" alt="第二版代码"></p><p>最后一个测试点超时，使用快读</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Q2016;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class p04_2 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line">        int[] id = new int[100000];</span><br><span class="line"></span><br><span class="line">        st.nextToken();</span><br><span class="line">        int n = (int)st.nval;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int k = (int)st.nval;</span><br><span class="line">            if (k &lt;= 1) &#123;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                int kk = (int)st.nval;;//错误在这里</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for (int i1 = 0; i1 &lt; k; i1++) &#123;</span><br><span class="line">                    st.nextToken();</span><br><span class="line">                    int cur = (int)st.nval;</span><br><span class="line">                    id[cur]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int flag = 0;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        int m = (int)st.nval;</span><br><span class="line">        int[] ans = new int[m];</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int cur = (int)st.nval;</span><br><span class="line">            if (id[cur] == 0) &#123;</span><br><span class="line">                flag ++;</span><br><span class="line">                ans[count++] = cur;</span><br><span class="line">                id[cur]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (flag == 0) &#123;</span><br><span class="line">            System.out.println(&quot;No one is handsome&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt; flag; i++) &#123;</span><br><span class="line">                System.out.printf(&quot;%05d&quot;, ans[i]);</span><br><span class="line">                if (i != flag - 1) &#123;</span><br><span class="line">                    System.out.print(&quot; &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是超时，数组去重</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Q2016;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class p04_3 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line">        int[] id = new int[100000];</span><br><span class="line"></span><br><span class="line">        st.nextToken();</span><br><span class="line">        int n = (int)st.nval;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int k = (int)st.nval;</span><br><span class="line">            if (k &lt;= 1) &#123;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                int kk = (int)st.nval;;//错误在这里</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for (int i1 = 0; i1 &lt; k; i1++) &#123;</span><br><span class="line">                    st.nextToken();</span><br><span class="line">                    int cur = (int)st.nval;</span><br><span class="line">                    id[cur]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        st.nextToken();</span><br><span class="line">        int m = (int)st.nval;</span><br><span class="line">        int[] idx = new int[m];</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            idx[i] = (int)st.nval;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        idx = removeDuplicates(idx);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int flag = 0;</span><br><span class="line">        int[] ans = new int[m];</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0; i &lt; idx.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            int cur = idx[i];</span><br><span class="line">            if (id[cur] == 0) &#123;</span><br><span class="line">                flag ++;</span><br><span class="line">                ans[count++] = cur;</span><br><span class="line">                id[cur]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (flag == 0) &#123;</span><br><span class="line">            System.out.println(&quot;No one is handsome&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt; flag; i++) &#123;</span><br><span class="line">                System.out.printf(&quot;%05d&quot;, ans[i]);</span><br><span class="line">                if (i != flag - 1) &#123;</span><br><span class="line">                    System.out.print(&quot; &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static int[] removeDuplicates(int[] arr) &#123;</span><br><span class="line">        return Arrays.stream(arr).distinct().toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是超时，于是去抄了几个，下面是一个用字符串做的</p><p><img src="/posts/24812/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230316222504.png"></p><p>翻遍CSDN，用Java写的就没有一个过的</p><p>果然，错的不是我，是语言</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java快读</title>
      <link href="/posts/54254.html"/>
      <url>/posts/54254.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java快读"><a href="#Java快读" class="headerlink" title="Java快读"></a>Java快读</h1><p>起因是因为PTA题目中求素数的题目没过，有大佬提示说是因为Java的Scanner类在读取的数据过多时会显得非常慢，于是就去网上找到了快读的教程</p><p>下面是使用快读与不使用快读的区别</p><p><img src="/posts/54254/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230316175903.png"></p><p><img src="/posts/54254/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230316175916.png"></p><h2 id="StreamTokenizer"><a href="#StreamTokenizer" class="headerlink" title="StreamTokenizer"></a>StreamTokenizer</h2><p>在Java中，StreamTokenizer 是一个用于将输入流分解为标记（tokens）的类。输入流可以是文件，网络连接或其他数据源，st可以将文本分解为数字，字符串，和特殊字符</p><p>st的工作方式类似于标准的Tokenizer类，但更加灵活，可以处理更多类型 的输入流，StreamTokenizer可以用于解析不同格式的数据</p><p>StreamTokenizer可以设置不同的分隔符和标记类型，以适应不同的输入格式。在使用StreamTokenizer时，我们需要指定输入流并设置分隔符和标记类型，然后我们可以逐个读取每个标记，并根据需要进行处理。</p><p>下面是从文件中读取标记的示例：</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class StreamTokenizerExample &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        FileReader fileReader = new FileReader(&quot;input.txt&quot;);</span><br><span class="line">        StreamTokenizer tokenizer = new StreamTokenizer(fileReader);</span><br><span class="line">        while (tokenizer.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            if (tokenizer.ttype == StreamTokenizer.TT_NUMBER) &#123;</span><br><span class="line">                System.out.println(&quot;Number: &quot; + tokenizer.nval);</span><br><span class="line">            &#125; else if (tokenizer.ttype == StreamTokenizer.TT_WORD) &#123;</span><br><span class="line">                System.out.println(&quot;Word: &quot; + tokenizer.sval);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(&quot;Special character: &quot; + (char)tokenizer.ttype);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fileReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>（1）导入io包<br>（2）在使用这个类时，函数要throws IOException<br>（3）StreamTokenizer re &#x3D; new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); 具体实现</p><p><code>读取整数</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String args[]) throws IOException &#123;</span><br><span class="line">        StreamTokenizer re = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));</span><br><span class="line">        //获取下一个标记，每次读取数据之前必须写一次</span><br><span class="line">        re.nextToken(); </span><br><span class="line">        int n = (int)re.nval;</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取字符串不需要加StreamTokenizer类直接写成BufferedReader re &#x3D; new BufferedReader(new InputStreamReader(System.in))；</p><p><code>读取字符串</code></p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String args[]) throws IOException&#123;</span><br><span class="line">//    StreamTokenizer re = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));</span><br><span class="line">        BufferedReader re = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        String x = re.readLine();//读取字符串时不需要nextToken()方法</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>混合读取</p><p><code>混合读取</code></p><p>错误示例</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String args[]) throws IOException&#123;</span><br><span class="line">        BufferedReader re = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer r = new StreamTokenizer(re);</span><br><span class="line">        r.nextToken(); int n = (int)r.nval;</span><br><span class="line">        String x = re.readLine();</span><br><span class="line">        System.out.println(n+&quot; &quot;+x);</span><br><span class="line">//    输入 </span><br><span class="line">//    3</span><br><span class="line">//    afadfa</span><br><span class="line">//    输出</span><br><span class="line">//    3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>残留换行符</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String args[]) throws IOException&#123;</span><br><span class="line">        BufferedReader re = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer r = new StreamTokenizer(re);</span><br><span class="line">        r.nextToken(); int n = (int)r.nval;</span><br><span class="line">        re.readLine();</span><br><span class="line">        String x = re.readLine();</span><br><span class="line">        System.out.println(n+&quot; &quot;+x);</span><br><span class="line">//    输入 </span><br><span class="line">//    3</span><br><span class="line">//    afadfa</span><br><span class="line">//    输出</span><br><span class="line">//    3 afadfa</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps快输</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String args[]) throws IOException&#123;</span><br><span class="line">        BufferedReader re = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer r = new StreamTokenizer(re);</span><br><span class="line">        PrintWriter pr = new PrintWriter(new OutputStreamWriter(System.out));</span><br><span class="line">        r.nextToken(); int n = (int)r.nval;</span><br><span class="line">        re.readLine();</span><br><span class="line">        String x = re.readLine();</span><br><span class="line">        pr.println(n+&quot; &quot;+x);</span><br><span class="line">        pr.flush();</span><br><span class="line">//    输入 </span><br><span class="line">//    3</span><br><span class="line">//    afadfa</span><br><span class="line">//    输出</span><br><span class="line">//    3 afadfa</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的没学，保存，以备不时之需</p><ol><li><p>读取多行数据</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    StreamTokenizer tokenizer = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));</span><br><span class="line">while (tokenizer.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">        int n = (int) tokenizer.nval; // 读取数字</span><br><span class="line">        String s = tokenizer.sval; // 读取字符串</span><br><span class="line">        // 处理数据...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>读取空格分隔的数据</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    StreamTokenizer tokenizer = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));</span><br><span class="line">tokenizer.whitespaceChars(&#x27; &#x27;, &#x27; &#x27;); // 设置空格为分隔符</span><br><span class="line">        while (tokenizer.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">        int n = (int) tokenizer.nval; // 读取数字</span><br><span class="line">        String s = tokenizer.sval; // 读取字符串</span><br><span class="line">        // 处理数据...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>读取逗号分隔的数据</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    StreamTokenizer tokenizer = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));</span><br><span class="line">tokenizer.whitespaceChars(&#x27;,&#x27;, &#x27;,&#x27;); // 设置逗号为分隔符</span><br><span class="line">        while (tokenizer.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">        int n = (int) tokenizer.nval; // 读取数字</span><br><span class="line">        String s = tokenizer.sval; // 读取字符串</span><br><span class="line">        // 处理数据...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>读取 CSV 文件</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    StreamTokenizer tokenizer = new StreamTokenizer(new BufferedReader(new FileReader(&quot;input.csv&quot;)));</span><br><span class="line">tokenizer.eolIsSignificant(true); // 设置行末为分隔符</span><br><span class="line">        tokenizer.wordChars(&#x27;,&#x27;, &#x27;,&#x27;); // 设置逗号为单词字符</span><br><span class="line">        while (tokenizer.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">        String s = tokenizer.sval; // 读取字符串</span><br><span class="line">        // 处理数据...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>读取二维数组</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    StreamTokenizer tokenizer = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));</span><br><span class="line">while (tokenizer.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">        int n = (int) tokenizer.nval; // 读取行数</span><br><span class="line">        int m = (int) tokenizer.nval; // 读取列数</span><br><span class="line">        int[][] a = new int[n][m];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">        tokenizer.nextToken();</span><br><span class="line">        a[i][j] = (int) tokenizer.nval; // 读取数组元素</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 处理数据...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>读取带有换行符的数据</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    StreamTokenizer tokenizer = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));</span><br><span class="line">tokenizer.eolIsSignificant(true); // 设置行末为分隔符</span><br><span class="line">        while (tokenizer.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">        String s = tokenizer.sval; // 读取字符串</span><br><span class="line">        // 处理数据...</span><br><span class="line">        if (tokenizer.ttype == StreamTokenizer.TT_EOL) &#123;</span><br><span class="line">        // 处理换行符</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>读取不同类型的数据</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    StreamTokenizer tokenizer = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));</span><br><span class="line">tokenizer.wordChars(&#x27;_&#x27;, &#x27;_&#x27;); // 允许下划线作为单词字符</span><br><span class="line">        while (tokenizer.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">        switch (tokenizer.ttype) &#123;</span><br><span class="line">        case StreamTokenizer.TT_NUMBER:</span><br><span class="line">        int n = (int) tokenizer.nval; // 读取数字</span><br><span class="line">        // 处理数字...</span><br><span class="line">        break;</span><br><span class="line">        case StreamTokenizer.TT_WORD:</span><br><span class="line">        String s = tokenizer.sval; // 读取字符串</span><br><span class="line">        // 处理字符串...</span><br><span class="line">        break;</span><br><span class="line">        case &#x27;_&#x27;:</span><br><span class="line">        // 处理下划线...</span><br><span class="line">        break;</span><br><span class="line">default:</span><br><span class="line">        // 处理其他类型...</span><br><span class="line">        break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="第一次补充"><a href="#第一次补充" class="headerlink" title="第一次补充"></a>第一次补充</h3><p><img src="/posts/54254/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230318104953.png"></p><p>&#96;&#96;字符串数字混合读取</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class p07 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line">        st.nextToken();</span><br><span class="line">        int n = (int)st.nval;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            String a = st.sval;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int hx = (int)st.nval;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int mb = (int)st.nval;</span><br><span class="line"></span><br><span class="line">            if (!(hx &gt;= 15 &amp;&amp; hx &lt;= 20) || !(mb &gt;=50 &amp;&amp; mb &lt;= 70)) &#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#96;读取单个字符</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class p08 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line">        st.nextToken();</span><br><span class="line">        int n = (int)st.nval;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            int b = bf.read();</span><br><span class="line">            st.nextToken();</span><br><span class="line">            double h = st.nval;</span><br><span class="line"></span><br><span class="line">            if (b == (int)&#x27;M&#x27;) &#123;</span><br><span class="line">                System.out.printf(&quot;%.2f&quot;, h / 1.09);</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.printf(&quot;%.2f&quot;, h * 1.09);</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/54254/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320071952.png"></p><h3 id="第二次补充"><a href="#第二次补充" class="headerlink" title="第二次补充"></a>第二次补充</h3><p>这次遇到的问题是对时间的读取</p><p><img src="/posts/54254/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230325110136.png"></p><p>先上自己写的读取模板</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.awt.image.BufferedImageFilter;</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line">public class 模板 &#123;</span><br><span class="line">    static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">    static StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        System.out.println(readInt());</span><br><span class="line">        st.nextToken();</span><br><span class="line">        System.out.println(readInt());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int readInt () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return (int)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String readStr () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char readChar () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.charAt(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readCharArray () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来是想用模板中的readCharArray()将一整串直接作为字符串读取，但是发现报错</p><p>st的原理是将输入流分割成不同的标记，比如单词，数字，标点符号等，显然，对于上面的时间而言就直接被分割成了，数字标点数字的形式，此时使用获取下一个标记，输出字符串的操作显然会返回一个空字符串，因为我们获取不到字符串</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    String a = readStr();</span><br><span class="line">&#125;</span><br><span class="line">//输入50：20</span><br><span class="line">//输出null</span><br></pre></td></tr></table></figure><p>此时如果我们想要将输入作为字符串来读取可以使用bufferreader，bf.readLine(),这样的操作能使我们获取中间的特殊字符：</p><p>（<code>BufferedReader</code> 类中的 <code>read()</code> 方法用于读取一个字符。它会从输入流中读取下一个字符，并将其作为整数返回。如果已经到达输入流的末尾，则返回 <code>-1</code>。）</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    String a = bf.readLine();</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line">//输入50：20</span><br><span class="line">//输出50:20</span><br></pre></td></tr></table></figure><p>需要注意的是，readline会读取换行符之前的所有字符，但不会读取换行符</p><p>那我们想读取 555 50：20 aaa这样的数据的时候又该怎么办呢？</p><p>利用循环，使用bufferreader中的read方法逐个读取，读取到空格返回这可能是一个思路，但是我们可以直接使用read中的重载方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int read(char[] cbuf) throws IOException</span><br></pre></td></tr></table></figure><p>读取字符到指定的字符数组 <code>cbuf</code> 中，并返回读取的字符数。如果已经到达输入流的末尾，则返回 <code>-1</code>。该方法会一直阻塞，直到有字符可读，或者抛出异常。</p><p>下面是使用示例</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    System.out.println(readInt());</span><br><span class="line">    System.out.println(readSP());</span><br><span class="line">    System.out.println(readInt());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static char[] readSP () throws IOException &#123;</span><br><span class="line">    char aa[] = new char[5];</span><br><span class="line">    bf.read(aa);</span><br><span class="line">    return  aa;</span><br><span class="line">&#125;</span><br><span class="line">//输入500 50:20 555</span><br><span class="line">//输出</span><br><span class="line">//500</span><br><span class="line">//50:20</span><br><span class="line">//555</span><br></pre></td></tr></table></figure><p>下面是另一些read重载方法的介绍</p><ol><li></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int read(char[] cbuf, int off, int len) throws IOException</span><br></pre></td></tr></table></figure><p>读取字符到指定的字符数组 <code>cbuf</code> 中的指定位置，并返回读取的字符数。参数 <code>off</code> 指定读取的起始位置，参数 <code>len</code> 指定最多读取的字符数。如果已经到达输入流的末尾，则返回 <code>-1</code>。该方法会一直阻塞，直到有字符可读，或者抛出异常。</p><ol start="2"><li></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public long skip(long n) throws IOException</span><br></pre></td></tr></table></figure><p>跳过输入流中的 <code>n</code> 个字符。如果已经到达输入流的末尾，则返回 <code>0</code>。该方法会一直阻塞，直到跳过指定数量的字符，或者抛出异常。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>打字游戏小结</title>
      <link href="/posts/14869.html"/>
      <url>/posts/14869.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="小小的打字游戏"><a href="#小小的打字游戏" class="headerlink" title="小小的打字游戏"></a>小小的打字游戏</h1><p>本学期专业引导大作业，模仿假期写的一个拼图游戏写的，算是对假期所学知识的巩固</p><p>直接上代码</p><p>1.ResultJFrame</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package come.P531.ui;</span><br><span class="line"></span><br><span class="line">import javax.swing.*;</span><br><span class="line">import java.awt.*;</span><br><span class="line">import java.awt.event.MouseEvent;</span><br><span class="line">import java.awt.event.MouseListener;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ResultJFrame extends JFrame implements MouseListener &#123;</span><br><span class="line">    double result;</span><br><span class="line">    double speed;</span><br><span class="line">    String fileName;</span><br><span class="line">    boolean flag;</span><br><span class="line"></span><br><span class="line">    JButton save;</span><br><span class="line">    JButton replay;</span><br><span class="line">    JButton Menu;</span><br><span class="line">    JButton search;</span><br><span class="line">    JMenuItem poor;</span><br><span class="line">    JTextField name;</span><br><span class="line">    JButton enterName;</span><br><span class="line">    JDialog Enter;</span><br><span class="line"></span><br><span class="line">    //构造方法</span><br><span class="line">    public ResultJFrame(double result, double speed, String fileName) &#123;</span><br><span class="line">        this.result = result;</span><br><span class="line">        this.speed = speed;</span><br><span class="line">        this.fileName = fileName;</span><br><span class="line">        this.flag = false;</span><br><span class="line">        initJFrame();</span><br><span class="line">        initView();</span><br><span class="line"></span><br><span class="line">        this.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化界面</span><br><span class="line">    private void initView() &#123;</span><br><span class="line">        this.getContentPane().removeAll();</span><br><span class="line">        JMenuBar jMenuBar = new JMenuBar();</span><br><span class="line"></span><br><span class="line">        int a = (int)(result * 100);</span><br><span class="line">        int b = (int)(speed * 100);</span><br><span class="line">        double bb = (double) b / 100;</span><br><span class="line"></span><br><span class="line">        JLabel first = new JLabel(&quot;正确率:%&quot;+ a);</span><br><span class="line">        first.setBounds(125,150,200,100);</span><br><span class="line">        first.setFont(new Font(&quot;宋体&quot;,Font.BOLD,30));</span><br><span class="line">        this.add(first);</span><br><span class="line"></span><br><span class="line">        JLabel second = new JLabel(&quot;速度:&quot;+bb+&quot;个每秒&quot;);</span><br><span class="line">        second.setBounds(50, 250,275,100);</span><br><span class="line">        second.setFont(new Font(&quot;宋体&quot;,Font.BOLD,30));</span><br><span class="line">        this.add(second);</span><br><span class="line"></span><br><span class="line">        save = new JButton(&quot;保存记录&quot;);</span><br><span class="line">        save.setBounds(400,100,150,75);</span><br><span class="line">        replay = new JButton(&quot;重新开始&quot;);</span><br><span class="line">        replay.setBounds(400,200,150,75);</span><br><span class="line">        Menu = new JButton(&quot;返回菜单&quot;);</span><br><span class="line">        Menu.setBounds(400,300,150,75);</span><br><span class="line">        search = new JButton(&quot;查看记录&quot;);</span><br><span class="line">        search.setBounds(400,400,150,75);</span><br><span class="line">        poor = new JMenuItem(&quot;快吃不起饭了&quot;);</span><br><span class="line"></span><br><span class="line">        save.addMouseListener(this);</span><br><span class="line">        replay.addMouseListener(this);</span><br><span class="line">        Menu.addMouseListener(this);</span><br><span class="line">        search.addMouseListener(this);</span><br><span class="line">        poor.addMouseListener(this);</span><br><span class="line"></span><br><span class="line">        this.getContentPane().add(save);</span><br><span class="line">        this.getContentPane().add(replay);</span><br><span class="line">        this.getContentPane().add(Menu);</span><br><span class="line">        this.getContentPane().add(search);</span><br><span class="line">        jMenuBar.add(poor);</span><br><span class="line">        this.setJMenuBar(jMenuBar);</span><br><span class="line"></span><br><span class="line">        this.getContentPane().repaint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化窗口</span><br><span class="line">    private void initJFrame() &#123;</span><br><span class="line">        this.setSize(600,600);</span><br><span class="line">        this.setTitle(&quot;测试结果&quot;);</span><br><span class="line">        this.setAlwaysOnTop(true);</span><br><span class="line">        this.setLocationRelativeTo(null);</span><br><span class="line">        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">        this.setLayout(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //展示成绩记录</span><br><span class="line">    private void showList() throws FileNotFoundException &#123;</span><br><span class="line">        //gettext first</span><br><span class="line">        File file =  new File(&quot;List/aList.txt&quot;);</span><br><span class="line">        Scanner sc = new Scanner(file);</span><br><span class="line"></span><br><span class="line">        String content = &quot;&lt;html&gt;&quot;;</span><br><span class="line">        while (sc.hasNextLine()) &#123;</span><br><span class="line">            content += sc.nextLine();</span><br><span class="line">        &#125;</span><br><span class="line">        content += &quot;&lt;html&gt;&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JDialog jDialog = new JDialog();</span><br><span class="line">        JLabel jLabel = new JLabel(content);</span><br><span class="line">        jLabel.setHorizontalAlignment(SwingConstants.CENTER);</span><br><span class="line">        jLabel.setVerticalAlignment(SwingConstants.CENTER);</span><br><span class="line">        jLabel.setFont(new Font(&quot;宋体&quot;, Font.BOLD, 15));</span><br><span class="line">        jLabel.setBounds(0, 0, 300, 200);</span><br><span class="line"></span><br><span class="line">        JScrollPane scrollPane = new JScrollPane(jLabel);</span><br><span class="line">        jDialog.getContentPane().add(scrollPane);</span><br><span class="line">        scrollPane.setMaximumSize(new Dimension(Integer.MAX_VALUE, 200));</span><br><span class="line">        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);</span><br><span class="line"></span><br><span class="line">        jDialog.setSize(400,400);</span><br><span class="line">        jDialog.setAlwaysOnTop(true);</span><br><span class="line">        jDialog.setLocationRelativeTo(null);</span><br><span class="line">        jDialog.setModal(true);</span><br><span class="line">        jDialog.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //保存成绩——窗口</span><br><span class="line">    private void save () &#123;</span><br><span class="line">        JLabel tip = new JLabel(&quot;&lt;html&gt;请输入玩家名&lt;br&gt;不多于15个字符&lt;br&gt;&lt;html&gt;&quot;);</span><br><span class="line">        tip.setBounds(75,50,150,100);</span><br><span class="line"></span><br><span class="line">        name = new JTextField();</span><br><span class="line">        name.setBounds(75,150,150,30);</span><br><span class="line"></span><br><span class="line">        enterName = new JButton(&quot;确定&quot;);</span><br><span class="line">        enterName.setBounds(100,200,100,50);</span><br><span class="line">        enterName.addMouseListener(this);</span><br><span class="line"></span><br><span class="line">        Enter = new JDialog();</span><br><span class="line">        Enter.setLayout(null);</span><br><span class="line">        Enter.getContentPane().add(name);</span><br><span class="line">        Enter.getContentPane().add(tip);</span><br><span class="line">        Enter.getContentPane().add(enterName);</span><br><span class="line">        Enter.setSize(300,300);</span><br><span class="line">        Enter.setAlwaysOnTop(true);</span><br><span class="line">        Enter.setLocationRelativeTo(null);</span><br><span class="line">        Enter.setModal(true);</span><br><span class="line">        Enter.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //警告窗口</span><br><span class="line">    private void showJDialog() &#123;</span><br><span class="line">        JDialog jDialog = new JDialog();</span><br><span class="line">        jDialog.setSize(300,300);</span><br><span class="line">        jDialog.setAlwaysOnTop(true);</span><br><span class="line">        jDialog.setLocationRelativeTo(null);</span><br><span class="line">        jDialog.setModal(true);</span><br><span class="line"></span><br><span class="line">        JLabel warning = new JLabel(new ImageIcon(&quot;pictures/damie.jpg&quot;));</span><br><span class="line">        JLabel warnText = new JLabel(&quot;请重新输入！！！SD&quot;);</span><br><span class="line">        warning.setBounds(75, 75, 100, 100);</span><br><span class="line">        warnText.setBounds(100, 175,100,50);</span><br><span class="line">        jDialog.getContentPane().add(warnText);</span><br><span class="line">        jDialog.getContentPane().add(warning);</span><br><span class="line"></span><br><span class="line">        jDialog.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //保存成绩——数据</span><br><span class="line">    private void getIn(String a) throws IOException &#123;</span><br><span class="line">        a += &quot;&lt;br&gt;&quot;;</span><br><span class="line">        String text = &quot;&quot;;</span><br><span class="line">        File file = new File(&quot;List/aList.txt&quot;);</span><br><span class="line">        Scanner sc = new Scanner(file);</span><br><span class="line">        if (sc.hasNextLine()) &#123;</span><br><span class="line">            text += sc.nextLine();</span><br><span class="line">        &#125;</span><br><span class="line">        text = a + text;</span><br><span class="line"></span><br><span class="line">        BufferedWriter bw = Files.newBufferedWriter(Paths.get(&quot;List/aList.txt&quot;));</span><br><span class="line">        try &#123;</span><br><span class="line">            bw.write(&quot;&quot;);</span><br><span class="line">            bw.write(text);</span><br><span class="line">            bw.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mouseClicked(MouseEvent e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mousePressed(MouseEvent e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mouseReleased(MouseEvent e) &#123;</span><br><span class="line">        if (e.getSource() == Menu) &#123;</span><br><span class="line">            this.setVisible(false);</span><br><span class="line">            new StartJFrame();</span><br><span class="line">        &#125; else if (e.getSource() == replay) &#123;</span><br><span class="line">            this.setVisible(false);</span><br><span class="line">            try &#123;</span><br><span class="line">                new TypeJFrame(fileName);</span><br><span class="line">            &#125; catch (IOException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (e.getSource() == poor) &#123;</span><br><span class="line">            System.out.println(&quot;按下poor&quot;);</span><br><span class="line"></span><br><span class="line">            JDialog jDialog = new JDialog();</span><br><span class="line">            JLabel jLabel = new JLabel(new ImageIcon(&quot;pictures/hehehe.png&quot;));</span><br><span class="line">            jLabel.setBounds(0,0,100,100);</span><br><span class="line">            jDialog.getContentPane().add(jLabel);</span><br><span class="line">            jDialog.setSize(1400,1200);</span><br><span class="line">            jDialog.setAlwaysOnTop(true);</span><br><span class="line">            jDialog.setLocationRelativeTo(null);</span><br><span class="line">            jDialog.setModal(true);</span><br><span class="line">            jDialog.setVisible(true);</span><br><span class="line">        &#125; else if (e.getSource() == search) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                showList();</span><br><span class="line">            &#125; catch (FileNotFoundException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (e.getSource() == save) &#123;</span><br><span class="line">            save();</span><br><span class="line">        &#125; else if (e.getSource() == enterName) &#123;</span><br><span class="line">            System.out.println(&quot;点击了确定&quot;);</span><br><span class="line">            int aa = (int)(result * 100);</span><br><span class="line">            int b = (int)(speed * 100);</span><br><span class="line">            double bb = (double) b / 100;</span><br><span class="line">            String a = name.getText();</span><br><span class="line">            if (a.length() &lt;= 15) &#123;</span><br><span class="line">                a += &quot; &quot; + aa + &quot; &quot; + bb;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                try &#123;</span><br><span class="line">                    getIn(a);</span><br><span class="line">                &#125; catch (IOException ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                Enter.setVisible(false);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                showJDialog();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mouseEntered(MouseEvent e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mouseExited(MouseEvent e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.StartJFrame</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package come.P531.ui;</span><br><span class="line"></span><br><span class="line">import javax.swing.*;</span><br><span class="line">import java.awt.*;</span><br><span class="line">import java.awt.event.MouseEvent;</span><br><span class="line">import java.awt.event.MouseListener;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class StartJFrame extends JFrame implements MouseListener &#123;</span><br><span class="line"></span><br><span class="line">    JLabel testArticleJB;</span><br><span class="line">    JRadioButton englishRB;</span><br><span class="line">    JRadioButton chineseRB;</span><br><span class="line">    JComboBox&lt;String&gt; testArticleJCB;;</span><br><span class="line">    JButton startJB;</span><br><span class="line"></span><br><span class="line">    JMenuItem aboutUs;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    String filename;</span><br><span class="line">    String path = &quot;data&quot;;</span><br><span class="line"></span><br><span class="line">    //构造方法</span><br><span class="line">    public StartJFrame() &#123;</span><br><span class="line"></span><br><span class="line">        initJFram();</span><br><span class="line">        initView(1);</span><br><span class="line">        initJMenuBar();</span><br><span class="line"></span><br><span class="line">        this.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化界面</span><br><span class="line">    public void initView(int botton) &#123;</span><br><span class="line">        this.getContentPane().removeAll();</span><br><span class="line"></span><br><span class="line">        JLabel title = new JLabel(&quot;531打字通&quot;);</span><br><span class="line">        title.setFont(new Font(&quot;宋体&quot;, Font.BOLD, 24));</span><br><span class="line">        title.setBounds(200,25,200,50);</span><br><span class="line">        this.getContentPane().add(title);</span><br><span class="line"></span><br><span class="line">        JLabel lang = new JLabel(&quot;打字类型&quot;);</span><br><span class="line">        lang.setFont(new Font(&quot;打字类型&quot;, Font.ITALIC, 15));</span><br><span class="line">        lang.setBounds(80,100,65,50);</span><br><span class="line">        this.getContentPane().add(lang);</span><br><span class="line"></span><br><span class="line">        englishRB =  new JRadioButton(&quot;英文打字&quot;);</span><br><span class="line">        chineseRB = new JRadioButton(&quot;中文打字&quot;);</span><br><span class="line">        englishRB.setBounds(175,100,100,50);</span><br><span class="line">        chineseRB.setBounds(275,100,100,50);</span><br><span class="line">        //englishRB.setSelected(true);</span><br><span class="line">        this.getContentPane().add(englishRB);</span><br><span class="line">        this.getContentPane().add(chineseRB);</span><br><span class="line">        if (botton == 1) &#123;</span><br><span class="line">            englishRB.setSelected(true);</span><br><span class="line">            chineseRB.setSelected(false);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            englishRB.setSelected(false);</span><br><span class="line">            chineseRB.setSelected(true);</span><br><span class="line">        &#125;</span><br><span class="line">        englishRB.addMouseListener(this);</span><br><span class="line">        chineseRB.addMouseListener(this);</span><br><span class="line"></span><br><span class="line">        testArticleJB = new JLabel(&quot;测试文章&quot;,SwingConstants.RIGHT);</span><br><span class="line">        testArticleJCB = new JComboBox&lt;String&gt;();</span><br><span class="line">        testArticleJCB.setEditable(false);</span><br><span class="line">        testArticleJCB.setMaximumRowCount(7);</span><br><span class="line">        testArticleJCB.setBounds(250,200,150,25);</span><br><span class="line">        addEnglishArticleToJComBox();</span><br><span class="line">        this.getContentPane().add(testArticleJCB);</span><br><span class="line"></span><br><span class="line">        JLabel choose = new JLabel(&quot;文章选择&quot;);</span><br><span class="line">        choose.setFont(new Font(&quot;文章选择&quot;, Font.ITALIC, 15));</span><br><span class="line">        choose.setBounds(130, 200,65,25);</span><br><span class="line">        this.getContentPane().add(choose);</span><br><span class="line"></span><br><span class="line">        startJB = new JButton(&quot;开始打字&quot;);</span><br><span class="line">        startJB.setBounds(200,300,100,50);</span><br><span class="line">        this.getContentPane().add(startJB);</span><br><span class="line">        startJB.addMouseListener(this);</span><br><span class="line"></span><br><span class="line">        this.getContentPane().repaint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将文章名加入到 combox中</span><br><span class="line">    public void addEnglishArticleToJComBox() &#123;</span><br><span class="line">        File f = new File(path);</span><br><span class="line">        File[] files = f.listFiles();</span><br><span class="line">        for (int i = 0; i &lt; files.length; i++) &#123;</span><br><span class="line">            if (files[i].toString().endsWith(&quot;.txt&quot;)) &#123;</span><br><span class="line">                testArticleJCB.addItem(files[i].getName().toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化窗口</span><br><span class="line">    private void initJFram() &#123;</span><br><span class="line">        JLabel textTypeJLabel = new JLabel(&quot;测试类型：&quot;, SwingConstants.RIGHT);</span><br><span class="line">        JPanel jp = new JPanel(new GridLayout(4, 3));</span><br><span class="line"></span><br><span class="line">        this.setSize(500, 500);</span><br><span class="line">        this.setTitle(&quot;531打字通&quot;);</span><br><span class="line">        this.setDefaultCloseOperation(3);</span><br><span class="line">        this.setLocationRelativeTo(null);</span><br><span class="line">        this.setAlwaysOnTop(true);</span><br><span class="line">        this.setLayout(null);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化菜单</span><br><span class="line">    private void initJMenuBar() &#123;</span><br><span class="line">        JMenuBar jMenuBar = new JMenuBar();</span><br><span class="line">        aboutUs =  new JMenuItem(&quot;关于我们&quot;);</span><br><span class="line">        jMenuBar.add(aboutUs);</span><br><span class="line">        aboutUs.addMouseListener(this);</span><br><span class="line">        this.setJMenuBar(jMenuBar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mouseClicked(MouseEvent e) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mousePressed(MouseEvent e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mouseReleased(MouseEvent e) &#123;</span><br><span class="line">        if (e.getSource() == startJB) &#123;</span><br><span class="line">            System.out.println(&quot;你松开了开始键&quot;);</span><br><span class="line">            this.setVisible(false);</span><br><span class="line">            filename = testArticleJCB.getSelectedItem().toString();</span><br><span class="line">            try &#123;</span><br><span class="line">                new TypeJFrame(path +&quot;/&quot;+filename);</span><br><span class="line">            &#125; catch (IOException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (e.getSource() == englishRB) &#123;</span><br><span class="line">            System.out.println(&quot;你松开了英文键&quot;);</span><br><span class="line">            chineseRB.setSelected(false);</span><br><span class="line">            englishRB.setSelected(true);</span><br><span class="line">            path = &quot;data&quot;;</span><br><span class="line">            initView(1);</span><br><span class="line">        &#125; else if (e.getSource() == chineseRB) &#123;</span><br><span class="line">            System.out.println(&quot;你松开了中文键&quot;);</span><br><span class="line">            englishRB.setSelected(false);</span><br><span class="line">            chineseRB.setSelected(true);</span><br><span class="line">            path = &quot;atad&quot;;</span><br><span class="line">            initView(2);</span><br><span class="line">        &#125; else if (e.getSource()  == aboutUs) &#123;</span><br><span class="line">            System.out.println(&quot;你松开了关于我们&quot;);</span><br><span class="line"></span><br><span class="line">            JDialog jDialog = new JDialog();</span><br><span class="line">            JLabel jLabel = new JLabel((new ImageIcon(&quot;pictures/aboutus.png&quot;)));</span><br><span class="line">            jLabel.setBounds(0,0,400,450);</span><br><span class="line">            jDialog.getContentPane().add(jLabel);</span><br><span class="line">            jDialog.setSize(800,800);</span><br><span class="line">            jDialog.setAlwaysOnTop(true);</span><br><span class="line">            jDialog.setLocationRelativeTo(null);</span><br><span class="line">            jDialog.setModal(true);</span><br><span class="line">            jDialog.setVisible(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mouseEntered(MouseEvent e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mouseExited(MouseEvent e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.TypeJFrame</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package come.P531.ui;</span><br><span class="line"></span><br><span class="line">import come.P531.util.TimeCounter;</span><br><span class="line"></span><br><span class="line">import javax.swing.*;</span><br><span class="line">import java.awt.*;</span><br><span class="line">import java.awt.event.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class TypeJFrame extends JFrame implements  KeyListener, MouseListener &#123;</span><br><span class="line">    String playerText = &quot;&quot;;</span><br><span class="line">    String text = &quot;&quot;;</span><br><span class="line">    JTextArea textArea;</span><br><span class="line">    char[] pt;</span><br><span class="line">    char[] t;</span><br><span class="line">    int cont;</span><br><span class="line">    int score;</span><br><span class="line">    int typeNum;</span><br><span class="line">    int time;</span><br><span class="line">    double acc;</span><br><span class="line">    double speed;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    String filename;</span><br><span class="line">    JMenuItem returnMenu;</span><br><span class="line">    JMenuItem backMenu;</span><br><span class="line"></span><br><span class="line">    TimeCounter timeCounter;</span><br><span class="line"></span><br><span class="line">    //构造方法</span><br><span class="line">    public TypeJFrame(String file) throws IOException &#123;</span><br><span class="line">        this.filename = file;</span><br><span class="line">        initJFram();</span><br><span class="line">        initView();</span><br><span class="line">        initJMenuBar();</span><br><span class="line">        timeCounter = new TimeCounter();</span><br><span class="line">        this.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化界面，获得文本信息（内容，字数）</span><br><span class="line">    private void initView() throws IOException &#123;</span><br><span class="line">        this.getContentPane().removeAll();</span><br><span class="line"></span><br><span class="line">        JLabel textLB = new JLabel();</span><br><span class="line">        textLB.setHorizontalAlignment(JLabel.LEFT);</span><br><span class="line">        textLB.setVerticalAlignment(JLabel.TOP);</span><br><span class="line">        textLB.setFont(new Font(&quot;text&quot;,Font.BOLD,15));</span><br><span class="line">        String text = getText();</span><br><span class="line">        getCont();</span><br><span class="line">        textLB.setText(text);</span><br><span class="line">        textLB.setBounds(50,50,450,650);</span><br><span class="line">        this.getContentPane().add(textLB);</span><br><span class="line"></span><br><span class="line">        textArea = new JTextArea(32, 55);</span><br><span class="line">        textArea.setBounds(600,50,450,650);</span><br><span class="line">        textArea.setFont(new Font(&quot;text&quot;,Font.BOLD,15));</span><br><span class="line">        textArea.addKeyListener(this);</span><br><span class="line">        this.getContentPane().add(textArea);</span><br><span class="line"></span><br><span class="line">        this.getContentPane().repaint();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化菜单</span><br><span class="line">    private void initJMenuBar() &#123;</span><br><span class="line"></span><br><span class="line">        returnMenu = new JMenuItem(&quot;返回&quot;);</span><br><span class="line">        backMenu = new JMenuItem(&quot;结束&quot;);</span><br><span class="line"></span><br><span class="line">        JMenuBar jMenuBar = new JMenuBar();</span><br><span class="line">        jMenuBar.add(returnMenu);</span><br><span class="line">        jMenuBar.add(backMenu);</span><br><span class="line">        returnMenu.addMouseListener(this);</span><br><span class="line">        backMenu.addMouseListener(this);</span><br><span class="line"></span><br><span class="line">        this.setJMenuBar(jMenuBar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //打印文本</span><br><span class="line">    private String getText () throws FileNotFoundException &#123;</span><br><span class="line">        File file = new File(filename);</span><br><span class="line">        Scanner sc = new Scanner(file);</span><br><span class="line">        String content = &quot;&lt;html&gt;&quot;;</span><br><span class="line">        while (sc.hasNextLine()) &#123;</span><br><span class="line">            String cur = sc.nextLine();</span><br><span class="line">            content += cur + &quot;&lt;br&gt;&quot;;</span><br><span class="line">            text += cur +&#x27;\n&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        content += &quot;&lt;html&gt;&quot;;</span><br><span class="line">        sc.close();</span><br><span class="line"></span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化窗口</span><br><span class="line">    private void initJFram() &#123;</span><br><span class="line">        this.setSize(1200, 800);</span><br><span class="line">        this.setTitle(&quot;531打字通&quot;);</span><br><span class="line">        this.setDefaultCloseOperation(3);</span><br><span class="line">        this.setLocationRelativeTo(null);</span><br><span class="line">        this.setAlwaysOnTop(true);</span><br><span class="line">        this.setLayout(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取目标文本数目，根据目标文本数目创建数组</span><br><span class="line">    private void getCont() throws IOException &#123;</span><br><span class="line">        FileReader fileReader = new FileReader(filename);</span><br><span class="line"></span><br><span class="line">        BufferedReader bufferedReader =  new BufferedReader(fileReader);</span><br><span class="line">        int c;</span><br><span class="line">        while ((c = bufferedReader.read()) != -1) &#123;</span><br><span class="line">            if (c != &#x27;\n&#x27; &amp;&amp; c != &#x27;\r&#x27;) &#123;</span><br><span class="line">                cont++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //比较目标文本与玩家输入，获取正确数目</span><br><span class="line">    private void compareText () &#123;</span><br><span class="line">        for (int i = 0; i &lt; cont; i++) &#123;</span><br><span class="line">            if (i == pt.length || i == t.length) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if ( pt[i] == t[i]) &#123;</span><br><span class="line">                score++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取结果</span><br><span class="line">    private void getResult() &#123;</span><br><span class="line"></span><br><span class="line">        playerText = textArea.getText();</span><br><span class="line">        pt = playerText.toCharArray();</span><br><span class="line">        t = text.toCharArray();</span><br><span class="line"></span><br><span class="line">        compareText();</span><br><span class="line"></span><br><span class="line">        acc = score*1.0 / cont;</span><br><span class="line">        speed = score*1.0 / time;</span><br><span class="line">        System.out.printf(&quot;%d %d %d&quot;,score, cont,time);</span><br><span class="line"></span><br><span class="line">        System.out.printf(&quot;%.2f &quot;, acc);</span><br><span class="line">        System.out.printf(&quot;%.2f &quot;, speed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void keyTyped(KeyEvent e) &#123;</span><br><span class="line">        int code = e.getKeyCode();</span><br><span class="line">        if (typeNum == cont) &#123;</span><br><span class="line">            time = timeCounter.count();</span><br><span class="line">            getResult();</span><br><span class="line">            new ResultJFrame(acc,speed,filename);</span><br><span class="line">            this.setVisible(false);</span><br><span class="line">        &#125; else if (code == 8) &#123;</span><br><span class="line">            typeNum--;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            typeNum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void keyPressed(KeyEvent e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void keyReleased(KeyEvent e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mouseClicked(MouseEvent e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mousePressed(MouseEvent e) &#123;</span><br><span class="line">        if (e.getSource() == returnMenu) &#123;</span><br><span class="line">            System.out.println(&quot;按下返回键&quot;);</span><br><span class="line"></span><br><span class="line">            this.setVisible(false);</span><br><span class="line">            new StartJFrame();</span><br><span class="line">        &#125; else if (e.getSource() == backMenu) &#123;</span><br><span class="line">            System.out.println(&quot;按下结束&quot;);</span><br><span class="line">            time = timeCounter.count();</span><br><span class="line">            getResult();</span><br><span class="line">            new ResultJFrame(acc,speed,filename);</span><br><span class="line">            this.setVisible(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mouseReleased(MouseEvent e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mouseEntered(MouseEvent e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mouseExited(MouseEvent e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.TimeCounter</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package come.P531.util;</span><br><span class="line"></span><br><span class="line">import come.P531.ui.TypeJFrame;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.time.Duration;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line">import java.util.Timer;</span><br><span class="line">import java.util.TimerTask;</span><br><span class="line"></span><br><span class="line">public class TimeCounter extends  TimerTask&#123;</span><br><span class="line"></span><br><span class="line">    LocalDateTime start;</span><br><span class="line">    LocalDateTime end;</span><br><span class="line"></span><br><span class="line">    int Record;</span><br><span class="line"></span><br><span class="line">    //构造方法</span><br><span class="line">    public TimeCounter() &#123;</span><br><span class="line">        this.Start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //一个失败的尝试</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        this.End();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //记录开始时间</span><br><span class="line">    public void Start () &#123;</span><br><span class="line">        start = LocalDateTime.now();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //记录结束时间</span><br><span class="line">    public void End () &#123;</span><br><span class="line">        end = LocalDateTime.now();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取时间之差</span><br><span class="line">    public int count () &#123;</span><br><span class="line">        this.End();</span><br><span class="line">        Duration duration =  Duration.between(start, end);</span><br><span class="line">        Record = (int)duration.getSeconds();</span><br><span class="line">        System.out.println(Record);</span><br><span class="line">        return Record;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前期分析的时候打字软甲主要有三个界面，开始界面选择打字类型及打字文章，打字界面，结果界面，我们将这三个界面抽象为一种类，分别对其进行设计，因为我们打算实现的是一个带图形化界面的，所以我们让每个类分别继承Java中自带的JFram类，实现鼠标或键盘监听，因为打字游戏的实现逻辑比较简单所以我们将实现的逻辑作为方法写进类中，因为实现需要我后面又加了一个工具类进行计时</p><p>当时我是打算按着自己的直觉思路写下去，没有进行任何前期设计，只是在克服几个技术难点（对我来说），然后就开始编码，但是在不久后便遇到了不小困难，当我想修改程序的一小部分的时候我竟然找不到那个部分在哪。。。。。。虽然确实很尴尬但是确实发生了，并且在后期‘找’这个操作就占了我大部分的时间，如果<strong>前期程序的结构，数据结构，算法没有提前设计好的话，对后期的维护，修改，升级，将会产生巨大的影响</strong>，前期设计，相当重要</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java.sort</title>
      <link href="/posts/10609.html"/>
      <url>/posts/10609.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Arrays-sort"><a href="#Arrays-sort" class="headerlink" title="Arrays.sort()"></a>Arrays.sort()</h1><p>我觉得这个东西我得单独写一篇，为啥嘞，好用，强大，虽然不稳定</p><p>这是Java中一个用于对数组进行排序的方法，可以按照升序或降序的方式排序</p><p>该方法有多种重载形式，其中最常见的形式是传入一个数组作为参数，该数组将被按照默认升序排序方式进行排序</p><p>例如：</p><p><code>int[] arr = &#123;3, 5, 6 , 2, 1&#125;;  Arrays.sort(arr)</code></p><p>如果需要降序排序，想办法反转数组即可</p><p>该方法还可以对对象类型数组进行排序，但徐娅保证对象实现了Comparable接口或传入一个Comparator比较器对象作为参数</p><p><code>实例</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class pg implements Comparable&lt;pg&gt; &#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">    public pg(int x, int y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public pg() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(pg o) &#123;</span><br><span class="line">        return this.y - o.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象数组排序"><a href="#对象数组排序" class="headerlink" title="对象数组排序"></a>对象数组排序</h2><p>该对象在实现接口之后就可以使用 Arrays.sort()对该对象数组进行排序，需要注意的是，该数组中不能含有非空引用（在这里报错了一次）对这个的解决方法是在排序之前先将数组中的空引用过滤掉，可以使用<code>Arrays.stream()</code>方法将数组转换成流，然后使用<code>filter()</code>方法过滤掉空引用，最后使用<code>toArray()</code>方法将流转换回数组即可，示例如下：</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    YourObject[] arr = new YourObject[10];</span><br><span class="line">// 假设数组中有一些元素是 null</span><br><span class="line"></span><br><span class="line">    // 使用 Arrays.stream() 方法将数组转换成流，使用 filter() 方法过滤掉空引用，最后转换回数组</span><br><span class="line">    YourObject[] sortedArr = Arrays.stream(arr)</span><br><span class="line">            .filter(Objects::nonNull)</span><br><span class="line">            .sorted(/* 排序规则 */)</span><br><span class="line">            .toArray(YourObject[]::new);</span><br></pre></td></tr></table></figure><p>实现Comparable接口的类必须保证compareTo()方法满足自反性，对称性和传递性</p><p><img src="/posts/10609/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230313171553.png"></p><h2 id="二维数组排序"><a href="#二维数组排序" class="headerlink" title="二维数组排序"></a>二维数组排序</h2><p>Arrays.sort()方法可以对一维数组进行排序，但不能直接对二维数组排序，但是我们可以通过实现Comparator接口或者Comparable接口来对二维数组进行排序</p><p>首先，我们可以实现comparator接口，定义一个比较方法compare(),该方法接受两个参数，分别是待比较的两个数组，在该方法中，我们可以指定按照哪个元素进行比较。例如，假如有一个二维数组arr，包含若干个长度为2的一维数组，我们可以按照一维数组的第一个元素进行排序</p><p>&#96;&#96;这个好</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int [] arr = &#123;&#123;1,2&#125;,&#123;3,1&#125;,&#123;1,2&#125;,&#123;3,1&#125;&#125;;</span><br><span class="line">Arrays.sort(arr, new Comparator&lt;int[]&gt;()</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(int[] o1, int[] o2) &#123;</span><br><span class="line">            return o1[0] - o2[0];</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>（不太懂）另外，如果二维数组的每个一维数组实现了Comparable接口，那么我们也可以使用Arrays.sort()方法对二维数组进行排序，在这种情况下，Arrays.sort()方法会自动调用每个以为数组的compareTo()方法进行排序</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Pair implements Comparable&lt;Pair&gt; &#123;</span><br><span class="line"></span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line"></span><br><span class="line">    public Pair(int x, int y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Pair o) &#123;</span><br><span class="line">        return this.x - o.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pair[][] pairs = &#123;&#123;new Pair(1, 2), new Pair(3,1)&#125;, &#123;new Pair(5, 6), new Pair(8, 9)&#125;&#125;;</span><br><span class="line"></span><br><span class="line">Arrays.sort(pairs[0]);</span><br><span class="line">Arrays.sort(pairs[1]);//使用匿名内部类</span><br><span class="line">Arrays.sort(pairs, new Comparator&lt;Pair[]&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Pair[] o1, Pair[] o2) &#123;</span><br><span class="line">        return o1[0].x - o2[0].x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>多维数组使用Arrays.sort方法排序的另外一种方式</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">    int[][] aa = new int[5][2];</span><br><span class="line">    for (int i = 0; i &lt; aa.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; aa[i].length; j++) &#123;</span><br><span class="line">            aa[i][j] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//使用Lambda表达式进行比较</span><br><span class="line"></span><br><span class="line">    Arrays.sort(aa,  (a, b) -&gt; Integer.compare(a[1], b[1]));</span><br><span class="line"></span><br><span class="line">    for (int[] ints : aa) &#123;</span><br><span class="line">        for (int anInt : ints) &#123;</span><br><span class="line">            System.out.print(anInt+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个代码中，我们将一个Lambda表达式作为参数传递给函数</p><p>Lambda表达式的语法形式为（参数列表） - &gt;表达式或者参数列表 - &gt; {代码块}</p><p>这个表达式可以用来代替某些匿名内部类的定义，尤其是对于函数式接口，使用Lambda表达式可以更加简洁，易读，Lambda表达式也可以用于函数式编程，它提供了一种更加函数化的编程风格</p><p>实现不同的比较器</p><p>（个人猜想：sort排序最主要的是要一个值来判断是否要交换位置，然而在我们传入对象，多维数组的时候内置的方法就不能进行求值，这个时候我们重写求值的方法，或者传递一个表达式来求值就可以完成操作）</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>Java中Arrays.sort()方法使用的是一种改进的快速排序算法（也称为双轴快速排序），该算法可以在最坏情况下以O(n log n)的时间复杂度完成排序，具有较好的性能。</p><p>具体实现思路如下：</p><ol><li>对于数组中的元素，选择一个基准元素（pivot），通常可以选择第一个元素或者最后一个元素。</li><li>定义两个指针，一个指向数组的开头（left），另一个指向数组的结尾（right）。</li><li>从左向右扫描数组，找到第一个大于等于基准元素的元素。</li><li>从右向左扫描数组，找到第一个小于等于基准元素的元素。</li><li>如果left指针小于等于right指针，交换left和right位置上的元素，然后将left指针向右移动，right指针向左移动。</li><li>重复3-5步骤，直到left指针大于right指针。</li><li>将基准元素与right指针所在位置上的元素交换。</li><li>对基准元素左侧的子数组和右侧的子数组分别进行递归排序，直到整个数组有序。</li></ol><p>需要注意的是，为了避免最坏情况下快速排序的时间复杂度退化到O(n^2)，Arrays.sort()方法还使用了一些优化技巧，如在数组大小较小时使用插入排序，以及在递归过程中使用堆排序等。</p><p>&#96;&#96;</p><h3 id="第一次更新"><a href="#第一次更新" class="headerlink" title="第一次更新"></a>第一次更新</h3><p>添加使用sort对对象数组和二维数组排序的实例，纠正一个思维漏洞，结合题目</p><p><img src="/posts/10609/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320113525.png"></p><h4 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h4><p>首先是对对象数组进行排序</p><p><img src="/posts/10609/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320113633.png"></p><p>使用匿名内部类重写比较方法，比较元素顺序跟框里一样就是从小到大，反过来就是从大到小，字符串之间比较大小就是比较的字典序，虽然我这里没有用string存name</p><p><img src="/posts/10609/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320113649.png"></p><p>对上面的方法进行简化</p><p><img src="/posts/10609/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320114002.png"></p><p>直接使用比较类中的比较方法，同样，里面的元素反过来就是从大到小排序</p><p>而且我们还可以使用lambda表达式来使代码得到进一步的简化</p><p><img src="/posts/10609/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320114339.png"></p><p>顺便了解一下compareTo接口</p><p><img src="/posts/10609/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320114557.png"></p><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>在对二维数组使用sort进行排序的时候，我们需要知道sort中的元素交换方法是不能改的，只能是一个什么东西与另一个什么东西进行交换，对于这个题目，我最开始的数据安排是这样的</p><p><img src="/posts/10609/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320114812.png"></p><p>每一列存储一条信息，因为第一行存的是收入，按照通产思路对第一排进行排序，如果第一行第一个元素大于第一行第二个元素，那么我们就要将第一行的元素与第二行的元素进行交换，这个sort显然是做不到的，因为我们一次就要交换三个什么东西，除非我们自己写sort方法，要不然肯定不行</p><p>所以我把数据结构给改成了这样</p><p><img src="/posts/10609/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320115116.png"></p><p>对于Java来说，二维数组中的元素就是里面的一维数组，此时我们第一列存收入，如果第一列第一个元素大于第二列第一个元素，那么我们直接交换第一行和第二行，也就是交换二维数组中的第一个元素与第二个元素即可</p><p>所以排序的代码这样写</p><p><img src="/posts/10609/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320115330.png"></p><p>使用lambda表达式</p><p><img src="/posts/10609/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320115357.png"></p><h3 id="第二次更新"><a href="#第二次更新" class="headerlink" title="第二次更新"></a>第二次更新</h3><p>要重写比较器，就不能是基本数据类型</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>移除元素</title>
      <link href="/posts/51619.html"/>
      <url>/posts/51619.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>递归计算行列式的值</title>
      <link href="/posts/62292.html"/>
      <url>/posts/62292.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​n阶行列式不断展开再相加的过程是一个不断重复的过程，完全展开之后就是一个树的形状，我们采用递归的方法去实现，首先要考虑递归结束的条件，那就是当行列式的阶数为2的时候直接套用公式计算并给出返回值，如果阶数大于2，那么我们展开第一行的所有元素并使每一行的元素与其对应的算数余子式相乘，将所有结果相加之后即是答案，那么我们在递归的时候要考虑传递的就是展开后的新余子式，将该余子式，与余子式阶数，作为新一轮递归的条件继续往下进行分解</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package text;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class free &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入行列式阶数&quot;);</span><br><span class="line">        int n = sc.nextInt();</span><br><span class="line">        //读取最初的行列式</span><br><span class="line">        int[][] a = new int[n][n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j  = 0; j &lt; n; j++) &#123;</span><br><span class="line">                a[i][j] = sc.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = hls(a, n);</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //处理行列式</span><br><span class="line">    public static int hls(int[][] a, int n) &#123;</span><br><span class="line">        //如果阶数为2，直接使用公式返回结果</span><br><span class="line">        if (n == 2) &#123;</span><br><span class="line">            return a[0][0] * a[1][1] - a[0][1] * a[1][0];</span><br><span class="line">        &#125; else &#123; //如果阶数不为2，展开第一行</span><br><span class="line">            int ans = 0; //用于接受每一行展开后所计算得出的值</span><br><span class="line">            for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">                if (a[0][i] == 0) &#123;</span><br><span class="line">                &#125; else if (i % 2 == 0) &#123;</span><br><span class="line">                    //构造新的行列式</span><br><span class="line">                    int[][] num = new int[n - 1][n - 1];</span><br><span class="line">                    szcl(a, num, i);</span><br><span class="line">                    ans += a[0][i] * hls(num, n - 1);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    int[][] num = new int[n - 1][n - 1];</span><br><span class="line">                    szcl(a, num, i);</span><br><span class="line">                    ans += -1*a[0][i] * hls(num, n - 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //构造新的行列式，省略第一行，及第lie列</span><br><span class="line">    public static void szcl(int[][] a, int[][] b, int lie) &#123;</span><br><span class="line">        int h = 0, l = 0;</span><br><span class="line">        //直接省略第一行，从第二行开始</span><br><span class="line">        for (int i = 1; i &lt; a.length; i ++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; a.length; j++) &#123;</span><br><span class="line">                if (j != lie) &#123;</span><br><span class="line">                    b[h][l++] = a[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            l = 0;</span><br><span class="line">            h++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>逆波兰表达式求值</title>
      <link href="/posts/16133.html"/>
      <url>/posts/16133.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/"></a></p><p><img src="/posts/16133/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230127045353.png"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接用栈，简单明了，我觉得更难的是怎么把一个中缀式改成后缀式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int evalRPN(String[] tokens) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = new LinkedList();</span><br><span class="line">        for (String s : tokens) &#123;</span><br><span class="line">            if (&quot;+&quot;.equals(s)) &#123;        // leetcode 内置jdk的问题，不能使用==判断字符串是否相等</span><br><span class="line">                stack.push(stack.pop() + stack.pop());      // 注意 - 和/ 需要特殊处理</span><br><span class="line">                //因为存在除数与被除数，减数与被减数的关系，直接弹出顺序会反</span><br><span class="line">            &#125; else if (&quot;-&quot;.equals(s)) &#123;</span><br><span class="line">                stack.push(-stack.pop() + stack.pop());</span><br><span class="line">            &#125; else if (&quot;*&quot;.equals(s)) &#123;</span><br><span class="line">                stack.push(stack.pop() * stack.pop());</span><br><span class="line">            &#125; else if (&quot;/&quot;.equals(s)) &#123;</span><br><span class="line">                int temp1 = stack.pop();</span><br><span class="line">                int temp2 = stack.pop();</span><br><span class="line">                stack.push(temp2 / temp1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                stack.push(Integer.valueOf(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>删除相邻重复项</title>
      <link href="/posts/22431.html"/>
      <url>/posts/22431.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/"></a></p><p><img src="/posts/22431/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230127034735.png"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>与左右括号匹配的题目类似，逐个扫描，如果栈顶元素与扫描字符不同，入栈，如果相同，栈顶元素出栈</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String removeDuplicates(String s) &#123;</span><br><span class="line">        Stack&lt;Character&gt; a = new Stack&lt;&gt;();</span><br><span class="line">        char ch;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            ch = s.charAt(i);</span><br><span class="line">            if (a.isEmpty() || a.peek() != ch) &#123;</span><br><span class="line">                a.push(ch);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                a.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">//非常细节，每次加入都是加在本体的左边，本来以为因为出栈顺序的原因可能最后还要反转字符串，多虑了</span><br><span class="line">        String str = &quot;&quot;;</span><br><span class="line">        while (!a.isEmpty()) &#123;</span><br><span class="line">            str = a.pop()+str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = new StringBuilder(str);</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String removeDuplicates(String s) &#123;</span><br><span class="line">        // 将 res 当做栈</span><br><span class="line">        // 也可以用 StringBuilder 来修改字符串，速度更快</span><br><span class="line">        // StringBuilder res = new StringBuilder();</span><br><span class="line">        StringBuffer res = new StringBuffer();</span><br><span class="line">        // top为 res 的长度</span><br><span class="line">        int top = -1;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            char c = s.charAt(i);</span><br><span class="line">            // 当 top &gt; 0,即栈中有字符时，当前字符如果和栈中字符相等，弹出栈顶字符，同时 top--</span><br><span class="line">            if (top &gt;= 0 &amp;&amp; res.charAt(top) == c) &#123;</span><br><span class="line">                res.deleteCharAt(top);</span><br><span class="line">                top--;</span><br><span class="line">            // 否则，将该字符 入栈，同时top++</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res.append(c);</span><br><span class="line">                top++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String removeDuplicates(String s) &#123;</span><br><span class="line">        char[] ch = s.toCharArray();</span><br><span class="line">        int fast = 0;</span><br><span class="line">        int slow = 0;</span><br><span class="line">        while(fast &lt; s.length())&#123;</span><br><span class="line">            // 直接用fast指针覆盖slow指针的值</span><br><span class="line">            ch[slow] = ch[fast];</span><br><span class="line">            // 遇到前后相同值的，就跳过，即slow指针后退一步，下次循环就可以直接被覆盖掉了</span><br><span class="line">            if(slow &gt; 0 &amp;&amp; ch[slow] == ch[slow - 1])&#123;</span><br><span class="line">                slow--;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(ch,0,slow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>有效括号</title>
      <link href="/posts/42010.html"/>
      <url>/posts/42010.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://leetcode.cn/problems/valid-parentheses/"></a></p><p><img src="/posts/42010/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230127030449.png"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>1.匹配问题，计算机处理左右括号似乎也是用栈来处理的我们逐个扫描字符串，如果是左括号，压入右括号，如果是做括号，判断栈顶元素与该括号是否匹配，如果匹配，出栈，如果不匹配，则字符串无效（括号搭配错了），如果在匹配到右括号时栈已空（多了右括号），则字符串无效，如果字符串扫描完毕，但栈不为空栈（多了左括号），则字符串无效</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        Deque&lt;Character&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line">        char ch;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            ch = s.charAt(i);</span><br><span class="line">            //碰到左括号，就把相应的右括号入栈</span><br><span class="line">            if (ch == &#x27;(&#x27;) &#123;</span><br><span class="line">                deque.push(&#x27;)&#x27;);</span><br><span class="line">            &#125;else if (ch == &#x27;&#123;&#x27;) &#123;</span><br><span class="line">                deque.push(&#x27;&#125;&#x27;);</span><br><span class="line">            &#125;else if (ch == &#x27;[&#x27;) &#123;</span><br><span class="line">                deque.push(&#x27;]&#x27;);</span><br><span class="line">            &#125; else if (deque.isEmpty() || deque.peek() != ch) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                deque.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return deque.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>用队列实现栈</title>
      <link href="/posts/24266.html"/>
      <url>/posts/24266.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/"></a></p><p><img src="/posts/24266/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230127020709.png"></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>1.队列的规则是先进后出，栈的规则是先进先出（可以直接用双端队列，把操作限制在一段，虽然这样感觉不太高明）我们可以使用两个队列，在添加元素时我们可以先将元素添加到辅助队列中，然后再将主队列里的元素依次全部转移给辅助队列，这时出栈只要控制主队列正常出列即可，栈顶元素就是队头的元素，主队列空则栈空</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line">    Queue&lt;Integer&gt; q1;</span><br><span class="line">    Queue&lt;Integer&gt; q2;</span><br><span class="line"></span><br><span class="line">    public MyStack() &#123;</span><br><span class="line">        q1 =  new LinkedList&lt;&gt;();</span><br><span class="line">        q2 = new LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        q2.offer(x);</span><br><span class="line">        while (!q1.isEmpty()) &#123;</span><br><span class="line">            q2.offer(q1.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //主辅队列交换</span><br><span class="line">        Queue&lt;Integer&gt; qTemp;</span><br><span class="line">        qTemp = q1;</span><br><span class="line">        q1 = q2;</span><br><span class="line">        q2 = qTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        return q1.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return q1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return q1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.简化，使用一个队列实现，依然主要是对元素进入队列时进行处理，每次都把元素加到栈顶就可以</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; q;</span><br><span class="line"></span><br><span class="line">    public MyStack() &#123;</span><br><span class="line">        q = new LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        //先将元素加入队列</span><br><span class="line">        q.offer(x);</span><br><span class="line">        //求队列长度</span><br><span class="line">        int size = q.size();</span><br><span class="line">        //这个过程挺有意思的，感觉就像贪吃蛇</span><br><span class="line">        while (size-- &gt; 1) &#123;</span><br><span class="line">            q.offer(q.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        return q.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return q.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return q.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.使用一个双端队列实现，这次我们对出队列的时候进行处理，设置一个主队列，一个辅助队列，每次要出栈的时候，我们将主队列中的所有元素除了第一个以外全部转移到辅助队列中，将辅助队列变为主队列，然后重新new一个辅助队列</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line">    Deque&lt;Integer&gt; q;</span><br><span class="line">    Deque&lt;Integer&gt; q1;</span><br><span class="line"></span><br><span class="line">    public MyStack() &#123;</span><br><span class="line">        q = new ArrayDeque&lt;&gt;();</span><br><span class="line">        q1 = new ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        q.addLast(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        int size = q.size();</span><br><span class="line">        while (size-- &gt; 1) &#123;</span><br><span class="line">            q1.addLast(q.poolFirst());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int res = q.pollFirst();</span><br><span class="line">        //交换引用对象</span><br><span class="line">        q = q1;</span><br><span class="line">        //辅助队列变为空</span><br><span class="line">        q1 = new ArrayDeque&lt;&gt;();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return q.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return q.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.只使用一个双端队列，跟上面思路相差不多，在出栈的时候我们将队列中除最后一个元素之外的元素全部依次从队头移到队尾，直到原本队尾的元素变为队头的元素，队头元素出列，完毕</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; q;</span><br><span class="line"></span><br><span class="line">    public MyStack() &#123;</span><br><span class="line">        q = new ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        q.addLast(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        int size = q.size();</span><br><span class="line">        while (size-- &gt; 1) &#123;</span><br><span class="line">            q.addLast(q.pollFirst());</span><br><span class="line">        &#125;</span><br><span class="line">        int res = q.pollFirst();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return q.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return q.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.最简单方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; q;</span><br><span class="line"></span><br><span class="line">    public MyStack() &#123;</span><br><span class="line">        q = new ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        q.addLast(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        return q.pollLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return q.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return q.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>栈实现队列</title>
      <link href="/posts/18433.html"/>
      <url>/posts/18433.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​<a href="https://leetcode.cn/problems/implement-queue-using-stacks/"></a></p><p><img src="/posts/18433/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126225518.png"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>栈是先进后出，并且进出只能从一端进行</p><p>队列是先进先出，一端进一段出，如果要用栈去模拟队列，创建两个开口方向不同的栈来实现，一个负责进一个负责出</p><p>进栈的时候</p><p><img src="/posts/18433/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126225911.png"></p><p>出栈的时候先把元素全部转移到出栈里</p><p><img src="/posts/18433/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126230028.png"></p><p>然后通过出栈实现pop</p><p><img src="/posts/18433/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126230123.png"></p><p><strong>必须保证出栈为空才可转移进栈中的元素，否则会导致元素错位从而出栈顺序混乱</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">class MyQueue &#123;</span><br><span class="line">    //队列是先进先出，栈是先进后出</span><br><span class="line"></span><br><span class="line">    //进栈，只负责进</span><br><span class="line">    Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    //出栈，只负责出</span><br><span class="line">    Stack&lt;Integer&gt; stackOut;</span><br><span class="line"></span><br><span class="line">    public MyQueue() &#123;</span><br><span class="line">        stackIn = new Stack&lt;&gt;();</span><br><span class="line">        stackOut = new Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        //正常压入即可</span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        //出栈的时候如果出栈不为空，则出栈继续出，如果出栈为空，把进栈里的东西全部转移到出栈里</span><br><span class="line">        pd();</span><br><span class="line">        return stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int peek() &#123;</span><br><span class="line">        //获取队头的元素</span><br><span class="line">        pd();</span><br><span class="line">        return stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        //空的情况为两个队列都空才算空</span><br><span class="line">        return stackOut.isEmpty() &amp;&amp; stackIn.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void pd() &#123;</span><br><span class="line">        //如果出栈为空，把进栈的东西全部装到出栈里</span><br><span class="line">        if (!stackOut.isEmpty()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            while (!stackIn.isEmpty()) &#123;</span><br><span class="line">                stackOut.push(stackIn.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>KMP</title>
      <link href="/posts/31301.html"/>
      <url>/posts/31301.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="KMP匹配模式算法"><a href="#KMP匹配模式算法" class="headerlink" title="KMP匹配模式算法"></a>KMP匹配模式算法</h1><p>本来以为串的知识点应该很简单，没想到，在最后两页栽了大跟头！！</p><p>克努特——莫里斯——普拉斯算法</p><p>串是由零个或多个字符组成的有序序列。对与串的基本操作有一部分与线性表十分相似，但是线性表更关注单个元素的操作，比如查找一个元素，插入或者删除一个元素，但是串中更多的是查找子串的位置，得到指定位置的字串，替换字串等。其中查询指定位置的子串相对而言比较重要，而KMP算法就是对一般查询字串位置的一种改进。</p><h2 id="朴素的匹配模式算法"><a href="#朴素的匹配模式算法" class="headerlink" title="朴素的匹配模式算法"></a>朴素的匹配模式算法</h2><p>查询子串位置的一般暴力解法——对主串做大循环，对每个字符开头做T的长度的小循环，直到匹配成功或者全部遍历完成为止</p><p>时间复杂度为O(（n-m+1）*m)</p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126212543.png"></p><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>这个算法。。。。。。我讲不明白。。。。。把我理解的图画一下吧，有时间再回炉重造。。。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>如果在子串中存在一部分相等的字符串，我们可通过修改短循环的起始位置来达到减少回溯次数作用，从而减少匹配所需的时间消耗</p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126213334.png"></p><p>如上图，在5位置匹配失败（这代表前面部分全部相等），果我们用暴力算法，那么下一步主串将会重新从子串的第一个开始继续匹配，但是我们研究子串中的前面部分，存在着两个完全相等的前后缀（ab），那么我们下一次匹配的时候完全可以从与后缀相等的前缀之后开始匹配从而达到减少操作次数的目的</p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126213834.png"></p><p>那么，我们在匹配失败的时候应该怎样知道应该回溯到什么地方呢？——构造next[], 最长相等前缀表</p><h3 id="前缀表"><a href="#前缀表" class="headerlink" title="前缀表"></a>前缀表</h3><p>图</p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126215218.png"></p><p>怎么理解j &#x3D; next[j]</p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126220704.png"></p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126220850.png"></p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126221114.png"></p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126221632.png"></p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126221646.png"></p><p>改进版本该怎么理解（右端空格里的东西应该也是A）</p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126221702.png"></p><p>一图值千言！！！！</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p>这个怎么说呢。。。。。这个思路，我理解了这么久，但是，最后就只有这几行代码，确实非常震撼</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int kmp(String s, String t) &#123;</span><br><span class="line">    //细节，多次使用的数据先获取</span><br><span class="line">    int sl = s.length();</span><br><span class="line">    int tl = t.length();</span><br><span class="line">    //特判</span><br><span class="line">    if (sl &lt; tl) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取next数组</span><br><span class="line">    int[] next = kmpNext(t);</span><br><span class="line"></span><br><span class="line">    //开始匹配</span><br><span class="line">    int i = 0, j = 0;</span><br><span class="line">    while(i &lt; sl &amp;&amp; j &lt; tl) &#123;</span><br><span class="line">        //这里的位置不能换，要么在j为-1的时候可能会出错</span><br><span class="line">        if (j == -1 || s.charAt(i) == t.charAt(j)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (j == tl) &#123;</span><br><span class="line">        return i - j;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return  -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int[] kmpNext(String t) &#123;</span><br><span class="line">    int len = t.length();</span><br><span class="line">    int[] next = new int[len];</span><br><span class="line">    //这里必须初始化数组</span><br><span class="line">    next[0] = -1;</span><br><span class="line">    int i = 0, j = -1;</span><br><span class="line">    while (i &lt; len - 1) &#123;</span><br><span class="line">        if (j == -1 || t.charAt(j) == t.charAt(i)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            i++;</span><br><span class="line">            //此处为改进版本</span><br><span class="line">            if (t.charAt(j) == t.charAt(i)) &#123;</span><br><span class="line">                next[i] = next[j];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                next[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>拼图游戏知识点整理</title>
      <link href="/posts/63503.html"/>
      <url>/posts/63503.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一个简单的拼图游戏"><a href="#一个简单的拼图游戏" class="headerlink" title="一个简单的拼图游戏"></a>一个简单的拼图游戏</h1><p>最近看网课跟着网课老师写了一个简单的拼图游戏，感觉自己对平时常用的这些软件有了全新的认识，原来图片的移动不是移动，原来关闭窗口不用真的关闭。。。。。总之有点。。。难受。</p><p>学到的东西也很多，但还是自己整理一遍比较好，纸上得来终觉浅，深知此事要躬行。</p><p>对对象，跟方法的使用和程序设计有了更深的理解</p><h3 id="一些知识点"><a href="#一些知识点" class="headerlink" title="一些知识点"></a>一些知识点</h3><p>（初步认识）</p><p><strong>JFrame</strong>-Java的GUI程序的基本思路是以JFrame为基础，它是屏幕上window的对象，通过这个对象我们能给程序设计各种窗口，通过一些方法我们可以实现窗口的最大化，最小化，选择关闭模式等基础功能</p><p><em><strong>这是一个容器，允许程序员把其他组件添加到它里面，把他们组织起来并把他们呈现给用户。</strong></em></p><p>包含方法</p><p><img src="/posts/63503/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230121013051.png"></p><p><img src="/posts/63503/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230121013134.png"></p><p><img src="/posts/63503/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230121013148.png"></p><p><strong>JPanel</strong>-Java图形用户界面工具包swing中的面板容器类，包含在javax.swing包中可以进行嵌套，功能是<em><strong>对窗体中具有相同逻辑功能的组件进行组合</strong></em>，是一种轻量级容器，可以加到JFrame窗体中。</p><p>是一种面板容器类，是一种轻量级容器，可以加到JFrame窗体中，自身可以嵌套组合，在不同子容器中可以包含其他组件如JButton、JTextArea、JTextField 等，功能是对窗体上的这些控件进行组合</p><p><strong>JLabel</strong>-该对象可以显示文本、图像，或同时显示二者。可以通过设置垂直和水平对齐方式，制定标签显示区中标签内容在何处对其。默认情况下，标签在其显示区域内居中对齐。默认情况下，只显示文本的标签是开始边对齐；而只显示图像的标签则水平居中对齐（需要注意的是，添加对象的顺序会导致我们设置的一些东西失效，比如文字位置，先加的在上面，后加的在下面，如果出现设置失效的情况可以试着改变添加的顺序）</p><p>用于管理显示图片或文本</p><p><strong>JMenuBar</strong>菜单栏JMenuBar，菜单JMenu，菜单项JMenuItem,一旦A有子菜单项，则A为菜单JMenu，而不是菜单项JMenuItem,菜单可以互相包含</p><p><strong>JDialog</strong>-对话框（<em>Jdialog</em>）与框架（JFrame）有一些相似，但它一般是一个临时的窗口，主要用于显示提示信息或接受用户输入。</p><p><strong>JTextField</strong>-一个轻量级组件，它允许编辑单行文本。</p><p><strong>JPasswordField</strong>-允许我们输入一行字像输入框，大师隐藏星号或点创建密码</p><p><strong>JButton</strong>-JButton类的实例。用于创建按钮</p><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>先说游戏的实现思路，初始化一个二维数组，根据数组中的值显示对应图片，此时记录空白图片的位置，根据用户的输入与记录的空白图片位置去对数组中的值进行改变，然后根据新数组中的值再去打印对应的图片实现移动图片的操作，如果每次移动对数组中的值进行判断，符合一定规律结束程序</p><p>游戏主要针对三个窗口进行设计，登录界面，注册界面，游戏界面，所以需要设计三个窗口类，我们直接新建class文件继承Java中原有的窗口类JFrame即可，通过添加新的方法或者对父类中的方法进行修改来设计我们自己的窗口，并且我们还需要通过键盘或者鼠标来对这些窗口中的组件进行操作所以还要实现鼠标监听接口或者键盘监听接口，然后在重写的方法中实现我们希望它实现的逻辑</p><h3 id="游戏界面"><a href="#游戏界面" class="headerlink" title="游戏界面"></a>游戏界面</h3><p>成员变量</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//图片位置</span><br><span class="line">int data[][] = new int[4][4];</span><br><span class="line"></span><br><span class="line">int win[][] =  new int[][]&#123;</span><br><span class="line">        &#123;1,2,3,4&#125;,</span><br><span class="line">        &#123;5,6,7,8&#125;,</span><br><span class="line">        &#123;9,10,11,12&#125;,</span><br><span class="line">        &#123;13,14,15,0&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">//记录空白方块在二维数组中的位置</span><br><span class="line">int x = 0,y = 0;</span><br><span class="line">//记录步数</span><br><span class="line">int count = 0;</span><br><span class="line">//隐藏功能</span><br><span class="line">public int flag;</span><br><span class="line"></span><br><span class="line">//考验字符串操作，通过修稿字符串中的特定内容我们可以让软件显示不同的图片</span><br><span class="line">String path = &quot;image/animal/animal2/&quot;;</span><br><span class="line"></span><br><span class="line">//因为actionlistener需要获取这些对象（用于判断该实现什么逻辑），所以不把他们单独写在菜单初始化方法中</span><br><span class="line">//创建菜单下条目的对象</span><br><span class="line">JMenuItem replayItem = new JMenuItem(&quot;重新游戏&quot;);</span><br><span class="line">JMenuItem reLoginItem = new JMenuItem(&quot;重新登录&quot;);</span><br><span class="line">JMenuItem closeItem = new JMenuItem(&quot;关闭游戏&quot;);</span><br><span class="line">JMenuItem girlItem = new JMenuItem(&quot;美女&quot;);</span><br><span class="line">JMenuItem animalItem = new JMenuItem(&quot;动物&quot;);</span><br><span class="line">JMenuItem sportItem = new JMenuItem(&quot;运动&quot;);</span><br><span class="line">JMenuItem textItem = new JMenuItem(&quot;游戏说明&quot;);</span><br><span class="line"></span><br><span class="line">JMenuItem accountItem = new JMenuItem(&quot;微信&quot;);</span><br></pre></td></tr></table></figure><p>初始化容器</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public GameJFrame(int flag) &#123;</span><br><span class="line">    //在创建界面的时候顺带创建了一个隐藏的管理容器（根容器），我们可以把图片，按钮，菜单这些东西交给他，但要使用getContentPane方法</span><br><span class="line"></span><br><span class="line">//这里下面的一些步骤，比如初始化图片需要在其他方法中多次使用，所以直接写成方法，逻辑不可改变</span><br><span class="line">    //初始化界面</span><br><span class="line">    initJFrame();</span><br><span class="line">    //初始化菜单</span><br><span class="line">    initJMenuBur();</span><br><span class="line">    //初始化数据</span><br><span class="line">    initData();</span><br><span class="line">    //初始化,添加图片（根据初始化后的数据打印图片）</span><br><span class="line">    initImage();</span><br><span class="line">    this.flag = flag;</span><br><span class="line"></span><br><span class="line">    //界面默认隐藏，设置是否可见（放最后）</span><br><span class="line">    this.setVisible(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化游戏数据</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void initData() &#123;</span><br><span class="line">    int num[] = &#123;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15&#125;;</span><br><span class="line">    Random r = new Random();</span><br><span class="line">    for (int i = 0; i &lt; num.length; i++) &#123;</span><br><span class="line">        int index = r.nextInt(num.length);</span><br><span class="line">        int temp = num[i];</span><br><span class="line">        num[i] = num[index];</span><br><span class="line">        num[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; 4; j++) &#123;</span><br><span class="line">            if (num[count] == 0) &#123;</span><br><span class="line">                x = i;</span><br><span class="line">                y = j;</span><br><span class="line">            &#125;</span><br><span class="line">            data[i][j] = num[count++];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化图像</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void initImage() &#123;</span><br><span class="line"></span><br><span class="line">    //因为我们会多次调用这个方法，所以每次调用这个方法前都先清空所有组件</span><br><span class="line">    //容器中的内容是是先添加的在上面，后添加的在下面，每次都先清空这些组件然后再添加内容保证新内容不被覆盖</span><br><span class="line">    this.getContentPane().removeAll();</span><br><span class="line">//添加顺序比较重要</span><br><span class="line">//如果胜利，显示胜利的图片</span><br><span class="line">    if (victory()) &#123;</span><br><span class="line">        JLabel win = new JLabel(new ImageIcon(&quot;image/win.png&quot;));</span><br><span class="line">        win.setBounds(203,283,197,73);//设置边界</span><br><span class="line">        通过这个对象，获取他的默认容器，添加窗口</span><br><span class="line">        this.getContentPane().add(win);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//添加步数窗口</span><br><span class="line">    JLabel stepCount = new JLabel(&quot;步数：&quot;+count);</span><br><span class="line">    stepCount.setBounds(50,30,100,20);</span><br><span class="line">    this.getContentPane().add(stepCount);</span><br><span class="line"></span><br><span class="line">    //添加背景图片（先加载的图片在上方,后加载的图片在下方）</span><br><span class="line">    //所以背景图片最后加</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; 4; j++) &#123;</span><br><span class="line">            //创建一个管理容器</span><br><span class="line">            JLabel jLabel = new JLabel(new ImageIcon(path+data[i][j]+&quot;.jpg&quot;));</span><br><span class="line">            //指定图片位置</span><br><span class="line">            jLabel.setBounds(105*j+83,105*i+134,105,105);</span><br><span class="line">            //给图片添加边框</span><br><span class="line">            //参数为斜面方向</span><br><span class="line">            jLabel.setBorder(new BevelBorder(0));</span><br><span class="line">            //把管理容器添加到界面中</span><br><span class="line">            this.getContentPane().add(jLabel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ImageIcon bg = new ImageIcon(&quot;image/background.png&quot;);</span><br><span class="line">    JLabel backGround = new JLabel(bg);</span><br><span class="line">    backGround.setBounds(40,40,508,560);</span><br><span class="line">    //把图片添加到控制容器中</span><br><span class="line">    this.getContentPane().add(backGround);</span><br><span class="line"></span><br><span class="line">    //刷新界面（显示新的界面）</span><br><span class="line">    this.getContentPane().repaint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化游戏菜单</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void initJMenuBur() &#123;</span><br><span class="line">    //初始化菜单</span><br><span class="line">    //创建整个菜单的对象</span><br><span class="line">    JMenuBar jMenuBar = new JMenuBar();</span><br><span class="line">    //创建菜单上两个选项的对象（功能  关于我们）</span><br><span class="line">    JMenu functionJMenu = new JMenu(&quot;功能&quot;);</span><br><span class="line">    JMenu aboutJMenu = new JMenu(&quot;关于我们&quot;);</span><br><span class="line">    JMenu changeImage = new JMenu(&quot;更换图片&quot;);</span><br><span class="line">    changeImage.add(girlItem);</span><br><span class="line">    changeImage.add(animalItem);</span><br><span class="line">    changeImage.add(sportItem);</span><br><span class="line"></span><br><span class="line">    //将选项组合,添加条目</span><br><span class="line">    //一级整合</span><br><span class="line">    functionJMenu.add(replayItem);</span><br><span class="line">    functionJMenu.add(reLoginItem);</span><br><span class="line">    functionJMenu.add(closeItem);</span><br><span class="line">    functionJMenu.add(changeImage);</span><br><span class="line"></span><br><span class="line">    aboutJMenu.add(accountItem);</span><br><span class="line"></span><br><span class="line">    //给条目绑定事件</span><br><span class="line">    replayItem.addActionListener(this);</span><br><span class="line">    reLoginItem.addActionListener(this);</span><br><span class="line">    closeItem.addActionListener(this);</span><br><span class="line">    accountItem.addActionListener(this);</span><br><span class="line">    girlItem.addActionListener(this);</span><br><span class="line">    animalItem.addActionListener(this);</span><br><span class="line">    sportItem.addActionListener(this);</span><br><span class="line">    textItem.addActionListener(this);</span><br><span class="line"></span><br><span class="line">    //二级整合</span><br><span class="line">    jMenuBar.add(functionJMenu);</span><br><span class="line">    jMenuBar.add(aboutJMenu);</span><br><span class="line">    jMenuBar.add(textItem);</span><br><span class="line"></span><br><span class="line">    //给整个界面设置菜单</span><br><span class="line">    this.setJMenuBar(jMenuBar);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化主界面</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void initJFrame() &#123;</span><br><span class="line">    //设置窗口</span><br><span class="line">    //设置界面宽高</span><br><span class="line">    this.setSize(603,680);</span><br><span class="line">    //设置界面标题</span><br><span class="line">    this.setTitle(&quot;拼图单机版 v1.0&quot;);</span><br><span class="line">    //设置界面置顶</span><br><span class="line">    this.setAlwaysOnTop(true);</span><br><span class="line">    //设置界面居中</span><br><span class="line">    this.setLocationRelativeTo(null);</span><br><span class="line">    //设置关闭模式</span><br><span class="line">    //关闭模式0，啥都不干 1，默认 2，多个界面，只有关掉最后一个界面才会关闭虚拟机（所有界面都要这样设置） 3，关掉一个，虚拟机结束</span><br><span class="line">    this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">    //取消默认居中放置，取消之后才能按照我的想法(xy轴形式)放置图片</span><br><span class="line">    this.setLayout(null);</span><br><span class="line">    //给整个界面添加监听事件</span><br><span class="line">    //这样this.getContentPane().addKeyListener(this);为什么错了，中间那一段到底是什么意思</span><br><span class="line">    //这个窗口的管理容器中添加了一个监听对象？</span><br><span class="line">    </span><br><span class="line">    //在当前对象上添加键盘监听</span><br><span class="line">    this.addKeyListener(this);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>游戏说明，这里添加顺序比较重要</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void showJDialog() &#123;</span><br><span class="line">    //创建一个弹框对象</span><br><span class="line">    JDialog dialog = new JDialog();</span><br><span class="line">    //设置弹框大小</span><br><span class="line">    dialog.setSize(600, 500);</span><br><span class="line">    //让弹框制定</span><br><span class="line">    dialog.setAlwaysOnTop(true);</span><br><span class="line">    //让弹框居中</span><br><span class="line">    dialog.setLocationRelativeTo(null);</span><br><span class="line">    //弹框不关闭无法操作下面界面</span><br><span class="line">    dialog.setModal(true);</span><br><span class="line"></span><br><span class="line">    //创建管理文字对象并添加到弹框中</span><br><span class="line">    JLabel text = new JLabel(new ImageIcon(&quot;image/img.png&quot;));</span><br><span class="line">    text.setBounds(0,0,500,400);</span><br><span class="line">    dialog.getContentPane().add(text);</span><br><span class="line">    //显示弹框</span><br><span class="line">    dialog.setVisible(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否胜利（可优化，节省储存正确答案的空间）</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean victory() &#123;</span><br><span class="line">    for (int i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; data[i].length; j++) &#123;</span><br><span class="line">            if (data[i][j] != win[i][j]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写的监听方法</p><p>这里的思路是监听到对应事件后，判断监听源，想写啥写啥，这个时候上面写的方法就十分重要了</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override检测单击</span><br><span class="line">public void actionPerformed(ActionEvent e) &#123;</span><br><span class="line">    Object obj = e.getSource();</span><br><span class="line">    if (obj == replayItem) &#123;//重新开始</span><br><span class="line">        //计步器清零</span><br><span class="line">        count = 0;</span><br><span class="line">        //打乱数据</span><br><span class="line">        initData();</span><br><span class="line">        //加载图片</span><br><span class="line">        initImage();</span><br><span class="line"></span><br><span class="line">    &#125; else if (obj == reLoginItem) &#123;//重新登录，匿名对象知识点</span><br><span class="line">        //返回登录界面</span><br><span class="line">        //关闭界面</span><br><span class="line">        this.setVisible(false);</span><br><span class="line">        //打开登录界面</span><br><span class="line">        new LoginJFrame();</span><br><span class="line"></span><br><span class="line">    &#125; else if (obj == closeItem) &#123;//关闭</span><br><span class="line">        System.exit(0);</span><br><span class="line"></span><br><span class="line">    &#125; else if (obj == accountItem) &#123;//关于我。。。。。。看半天才看出来是啥，直到我看了一眼图片</span><br><span class="line">        //创建一个弹框对象</span><br><span class="line">        JDialog jDialog = new JDialog();</span><br><span class="line">        //创建一个管理图片的容器对象</span><br><span class="line">        JLabel jLabel = new JLabel(new ImageIcon(&quot;image/1673683779539.jpg&quot;));</span><br><span class="line">        //设置位置和宽高</span><br><span class="line">        jLabel.setBounds(0,0,355,431);</span><br><span class="line">        //把图片添加到弹框中</span><br><span class="line">        //弹框只是一个框架，</span><br><span class="line">        jDialog.getContentPane().add(jLabel);</span><br><span class="line">        //给弹框设置大小</span><br><span class="line">        jDialog.setSize(405,481);</span><br><span class="line">        //让弹框指定</span><br><span class="line">        jDialog.setAlwaysOnTop(true);</span><br><span class="line">        //让弹框居中</span><br><span class="line">        jDialog.setLocationRelativeTo(null);</span><br><span class="line">        //弹框不关闭，无法操作下面的界面</span><br><span class="line">        jDialog.setModal(true);</span><br><span class="line">        //让弹框显示出来</span><br><span class="line">        jDialog.setVisible(true);</span><br><span class="line"></span><br><span class="line">    &#125; else if (obj == girlItem) &#123;//改变成员变量path中的内容，考察字符串操作</span><br><span class="line">        System.out.println(&quot;切换美女&quot;);</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        int pictureNumb;</span><br><span class="line">        if (flag == 0) &#123;</span><br><span class="line">            pictureNumb = r.nextInt(11) + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pictureNumb = r.nextInt(2) + 12;</span><br><span class="line">        &#125;</span><br><span class="line">        path = &quot;image/girl/girl&quot;+pictureNumb+&quot;/&quot;;</span><br><span class="line">        count = 0;</span><br><span class="line">        initData();</span><br><span class="line">        initImage();</span><br><span class="line">    &#125; else if (obj == animalItem) &#123;</span><br><span class="line">        System.out.println(&quot;切换动物&quot;);</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        int pictureNumb = r.nextInt(8)+1;</span><br><span class="line">        path = &quot;image/animal/animal&quot;+pictureNumb+&quot;/&quot;;</span><br><span class="line">        count = 0;</span><br><span class="line">        initData();</span><br><span class="line">        initImage();</span><br><span class="line">    &#125; else if (obj == sportItem) &#123;</span><br><span class="line">        System.out.println(&quot;切换运动&quot;);</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        int pictureNumb = r.nextInt(10)+1;</span><br><span class="line">        path = &quot;image/sport/sport&quot;+pictureNumb+&quot;/&quot;;</span><br><span class="line">        count = 0;</span><br><span class="line">        initData();</span><br><span class="line">        initImage();</span><br><span class="line">    &#125; else if (obj == textItem) &#123;</span><br><span class="line">        showJDialog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测键盘输入</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void keyTyped(KeyEvent e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//按下调用</span><br><span class="line">@Override//显示原图</span><br><span class="line">public void keyPressed(KeyEvent e) &#123;</span><br><span class="line">    int code = e.getKeyCode();</span><br><span class="line">    if (code == 65) &#123;</span><br><span class="line">        this.getContentPane().removeAll();</span><br><span class="line">        JLabel all = new JLabel(new ImageIcon(path+&quot;all.jpg&quot;));</span><br><span class="line">        all.setBounds(83,134,420,420);</span><br><span class="line">        this.getContentPane().add(all);</span><br><span class="line"></span><br><span class="line">        ImageIcon bg = new ImageIcon(&quot;image/background.png&quot;);</span><br><span class="line">        JLabel backGround = new JLabel(bg);</span><br><span class="line">        backGround.setBounds(40,40,508,560);</span><br><span class="line">        //把图片添加到根界面中</span><br><span class="line">        this.getContentPane().add(backGround);</span><br><span class="line">        this.getContentPane().repaint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void keyReleased(KeyEvent e) &#123;</span><br><span class="line">    //如果胜利，此方法直接结束,就不能再移动了</span><br><span class="line">    if (victory()) &#123;//胜利之后图片就不应该动了</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果还没胜利</span><br><span class="line">    //左37 右39 上38 下40</span><br><span class="line">    //这里应该是错的，猜测不管按啥都会导致步数++</span><br><span class="line">    count++;</span><br><span class="line">    //获取按键值</span><br><span class="line">    int code = e.getKeyCode();</span><br><span class="line">    if (code == 37) &#123;</span><br><span class="line">        if (y == 3) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;向左移动&quot;);</span><br><span class="line">        data[x][y] = data[x][y + 1];</span><br><span class="line">        data[x][y + 1] = 0;</span><br><span class="line">        y++;</span><br><span class="line">        initImage();</span><br><span class="line">    &#125; else if (code == 38) &#123;</span><br><span class="line">        if (x == 3) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;向上移动&quot;);</span><br><span class="line">        data[x][y] = data[x + 1][y];</span><br><span class="line">        data[x + 1][y] = 0;</span><br><span class="line">        x++;</span><br><span class="line">        initImage();</span><br><span class="line">    &#125; else if (code == 39) &#123;</span><br><span class="line">        if (y == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;向右移动&quot;);</span><br><span class="line">        data[x][y] = data[x][y - 1];</span><br><span class="line">        data[x][y - 1] = 0;</span><br><span class="line">        y--;</span><br><span class="line">        initImage();</span><br><span class="line">    &#125; else if (code == 40) &#123;</span><br><span class="line">        if (x == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;向下移动&quot;);</span><br><span class="line">        data[x][y] = data[x - 1][y];</span><br><span class="line">        data[x - 1][y] = 0;</span><br><span class="line">        x--;</span><br><span class="line">        initImage();</span><br><span class="line">    &#125; else if (code == 65) &#123;//重新开始</span><br><span class="line">        initImage();</span><br><span class="line">    &#125; else if (code == 87) &#123;//作弊代码</span><br><span class="line">        data = new int[][]&#123;</span><br><span class="line">                &#123;1,2,3,4&#125;,</span><br><span class="line">                &#123;5,6,7,8&#125;,</span><br><span class="line">                &#123;9,10,11,12&#125;,</span><br><span class="line">                &#123;13,14,15,0&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        initImage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>跟着网课老师写了大部分，自己补了隐藏功能及更换图片，游戏说明的部分，还有登录部分（最后还是改成老师的代码），首先游戏一开始就创建的登录部分，登录部分包含一个集合，里面包含的初始化的用户信息，如果信息对的上，那么窗口隐身，实现游戏窗口，需要注意的是先判断用户名或密码是否为空，然后判断验证码，最后判断正误，整体还是比较简单，用户注册的功能猜测可以用数据库，主要逻辑是隐藏登录界面，新建注册界面，初始化注册界面，加载组件，判断输入内容，如果合法，添加到数据库中 ，返回登录界面，注册界面隐藏，然而单机版的化估计可以用文件输入输出，可以总结出一些固定操作</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java自带的栈与队列 类</title>
      <link href="/posts/49362.html"/>
      <url>/posts/49362.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作为高级语言，Java肯定是自带了Stack类跟Queue类，学习使用现成的还是有必要的</p><h1 id="Stack-类"><a href="#Stack-类" class="headerlink" title="Stack 类"></a>Stack 类</h1><p>栈是Vector的一个子类，它实现类一个标准的后进先出栈</p><p><strong>构造函数</strong></p><p>Stack()</p><p><strong>包含方法</strong></p><p>除了Vector中定义的所有方法外，自己的方法有</p><p><img src="/posts/49362/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230113162000.jpg"></p><p><strong>实例</strong></p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package stack;</span><br><span class="line"></span><br><span class="line">import java.util.EmptyStackException;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class StackDemo &#123;</span><br><span class="line"></span><br><span class="line">    static void showpush(Stack&lt;Integer&gt; st, int a) &#123;</span><br><span class="line">        st.push(new Integer(a));</span><br><span class="line">        System.out.println(&quot;push(&quot; + a + &quot;)&quot;);</span><br><span class="line">        System.out.println(&quot;stack: &quot; + st);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void showpop(Stack&lt;Integer&gt; st) &#123;</span><br><span class="line">        System.out.print(&quot;pop -&gt; &quot;);</span><br><span class="line">        Integer a = (Integer) st.pop();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(&quot;stack: &quot; + st);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; st = new Stack&lt;Integer&gt;();</span><br><span class="line">        System.out.println(&quot;stack: &quot; + st);</span><br><span class="line">        showpush(st, 42);</span><br><span class="line">        showpush(st, 66);</span><br><span class="line">        showpush(st, 99);</span><br><span class="line">        showpop(st);</span><br><span class="line">        showpop(st);</span><br><span class="line">        showpop(st);</span><br><span class="line">        try &#123;</span><br><span class="line">            showpop(st);</span><br><span class="line">        &#125; catch (EmptyStackException e) &#123;</span><br><span class="line">            System.out.println(&quot;empty stack&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/49362/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230113163206.png" alt="运行结果"></p>]]></content>
      
      
      <categories>
          
          <category> 栈与队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>队列——java</title>
      <link href="/posts/49269.html"/>
      <url>/posts/49269.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>这里是我比较不确定的，感觉不太稳，但是不想测试了，如果真的有错。。。。。。日后再改</p><h2 id="静态队列"><a href="#静态队列" class="headerlink" title="静态队列"></a>静态队列</h2><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Queue;</span><br><span class="line">//现在有两种思路，一种是动态的，一种是静态的，为了巩固静态链表，我在这里只写静态的</span><br><span class="line">//队列各元素之前也具有前驱后继关系</span><br><span class="line">//采用一种取巧的方法，如果后面排满了，前面有位置，那么整体前移</span><br><span class="line">//我上面说的屁话，还是直接用循环队列的好，循环队列多香啊！</span><br><span class="line">class SqQueue&#123;</span><br><span class="line">    int maxSize = 100;</span><br><span class="line">    int data[];</span><br><span class="line">    int front;</span><br><span class="line">    int rear;</span><br><span class="line">    int count;</span><br><span class="line"></span><br><span class="line">    public SqQueue() &#123;</span><br><span class="line">        this.data = new int[maxSize];</span><br><span class="line">        front = 0;</span><br><span class="line">        rear = 1;</span><br><span class="line">        count = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int QueueLength() &#123;</span><br><span class="line">        return count;</span><br><span class="line">        //return (rear - front + maxSize) % maxSize</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void EnQueue(int x) &#123;</span><br><span class="line">        if(rear == maxSize - 1 &amp;&amp; front != 0) &#123;</span><br><span class="line">            data[rear] = x;</span><br><span class="line">            count++;</span><br><span class="line">            rear = 0;</span><br><span class="line">        &#125; else if ((rear + 1) != front) &#123;</span><br><span class="line">            data[rear] = x;</span><br><span class="line">            count++;</span><br><span class="line">            rear++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //感觉比较不太稳的地方</span><br><span class="line">    public int DeQueue() &#123;</span><br><span class="line">        int pos = -1;</span><br><span class="line">        if(front == maxSize - 1 &amp;&amp; count != 0)&#123;</span><br><span class="line">            pos = data[front];</span><br><span class="line">            front = 0;</span><br><span class="line">            count--;</span><br><span class="line">        &#125; else if (count != 0) &#123;</span><br><span class="line">            pos = data[front];</span><br><span class="line">            front++;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        return pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyQueue &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h2><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Queue;</span><br><span class="line"></span><br><span class="line">class QueueNode &#123;</span><br><span class="line">    int data;</span><br><span class="line">    QueueNode next;</span><br><span class="line"></span><br><span class="line">    public QueueNode() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public QueueNode(int data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LinkQueue &#123;</span><br><span class="line">    QueueNode front ;</span><br><span class="line">    QueueNode rear ;</span><br><span class="line">    int count;</span><br><span class="line"></span><br><span class="line">    public LinkQueue() &#123;</span><br><span class="line">        front = new QueueNode();</span><br><span class="line">        rear = front;</span><br><span class="line">        count = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void EnQueue(int x) &#123;</span><br><span class="line">        QueueNode node = new QueueNode(x);</span><br><span class="line">        rear.next = node;</span><br><span class="line">        rear = node;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void DeQueue() &#123;</span><br><span class="line">        if (front.next.next != null) &#123;</span><br><span class="line">            front.next = front.next.next;</span><br><span class="line">            count--;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            rear = front;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 栈与队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈——java</title>
      <link href="/posts/40188.html"/>
      <url>/posts/40188.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>直接上我写的栈的代码，栈其实只是一种特殊的线性表，以下的栈几乎都没有经过测试，如有错误，之后再改吧</p><h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><p>普通的顺序栈</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package stack.SXstack;</span><br><span class="line"></span><br><span class="line">class SElem &#123;</span><br><span class="line">    final int maxSize = 100;</span><br><span class="line">    //储存数据</span><br><span class="line">    public int data[];</span><br><span class="line">    //储存栈顶位置</span><br><span class="line">    int top;</span><br><span class="line"></span><br><span class="line">    public SElem() &#123;</span><br><span class="line">        this.data = new int[maxSize];</span><br><span class="line">        this.top = -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //入栈，返回入栈是否成功</span><br><span class="line">    boolean Push(int x) &#123;</span><br><span class="line">        if (top == maxSize - 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            data[++top] = x;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出栈，返回出栈的元素</span><br><span class="line">    int Pop() &#123;</span><br><span class="line">        if (top == -1) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return data[top--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//栈的操作让我们不必担心数组下标这些多余操作，更加直面问题的本质</span><br><span class="line">public class SXstack &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SElem a = new SElem();</span><br><span class="line">        a.Push(1);</span><br><span class="line">        a.Push(2);</span><br><span class="line">        a.Push(3);</span><br><span class="line">        a.Push(4);</span><br><span class="line">        a.Push(5);</span><br><span class="line">        System.out.println(a.Pop());</span><br><span class="line">        System.out.println(a.Pop());</span><br><span class="line">        System.out.println(a.Pop());</span><br><span class="line">        System.out.println(a.Pop());</span><br><span class="line">        System.out.println(a.Pop());</span><br><span class="line">        System.out.println(a.Pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两栈共用空间</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package stack.SXstack;</span><br><span class="line">/*虽然是两栈共享空间，但是我们不用真的创建两个栈，两个栈一起操作还是会带来很多麻烦的，临界情况不太好考虑</span><br><span class="line">我们只需要用一个栈，来模拟两个栈对接在一起的情况即可，有点类似双向链表</span><br><span class="line">这种结构主要用于解决两个栈的空间需求有相反关系</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class SqDoubleStack &#123;</span><br><span class="line">    int maxSize = 100;</span><br><span class="line">    int data[] = new int[maxSize];</span><br><span class="line">    int top1;</span><br><span class="line">    int top2;</span><br><span class="line"></span><br><span class="line">    public SqDoubleStack() &#123;</span><br><span class="line">        top1 = -1;</span><br><span class="line">        top2 = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean Push(int x, int w) &#123;</span><br><span class="line">        if (top2 + top1 + 1== maxSize) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (w == 1) &#123;</span><br><span class="line">                data[++top1] = x;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                data[--top2] = x;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int Pop(int x, int w) &#123;</span><br><span class="line">        if(w == 1) &#123;</span><br><span class="line">            if(top1 == -1)&#123;</span><br><span class="line">                return -1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return data[top1--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (w == 2) &#123;</span><br><span class="line">            if (top2 == maxSize) &#123;</span><br><span class="line">                return -1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return data[top2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DoubleStack &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;肯定没问题 ，我就不测试了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h2><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package stack.LSstack;</span><br><span class="line"></span><br><span class="line">class StackNode&#123;</span><br><span class="line">    int data;</span><br><span class="line">    StackNode next;</span><br><span class="line"></span><br><span class="line">    public StackNode(int data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LinkStack &#123;</span><br><span class="line">    StackNode top;</span><br><span class="line">    int count;</span><br><span class="line"></span><br><span class="line">    public LinkStack() &#123;</span><br><span class="line">        count = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        if (top == null) &#123;</span><br><span class="line">            top = new StackNode(x);</span><br><span class="line">            count++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            StackNode pos = new StackNode(x);</span><br><span class="line">            pos.next = top;</span><br><span class="line">            top = pos;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        if (top == null) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int pos = top.data;</span><br><span class="line">            top = top.next;</span><br><span class="line">            count--;</span><br><span class="line">            return pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 栈与队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>静态链表</title>
      <link href="/posts/50363.html"/>
      <url>/posts/50363.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><h2 id="静态单链表"><a href="#静态单链表" class="headerlink" title="静态单链表"></a>静态单链表</h2><p>静态单链表是使用数组来模拟链表，静态链表本身是为了让那些没有指针的语言也能使用链表结构，但是对于其他有指针的语言而言，在算法比赛中，静态链表的使用要多得多，因为他用数组模拟，会更快，学长的说法是你不断的去new一个什么东西是很慢的，我的静态链表采用的思路跟动态链表基本相同，两个数组，一个e代表数据域，一个ne代表指针域，相同数组下标为一个结点，通过对应结点的指针域中所储存的值去寻找下一个结点，虽然储存的形式类似于顺序结构，但是因为有额外的空间用于储存该数据的逻辑结构，所以依然是链表。。。感觉好绕。。。。。。。不过重要的是，指针域中储存的是逻辑结构，<strong>只要能通过结点的指针域中的数值去找到下一个结点就可以</strong>，指针域中的数值可能是无序且不连续的，储存的只是相对位置，具体思路见下图，该图演示了一个静态链表在经历头插，插入，删除操作时其中数据的变化情况，我们可以很清楚的看到，静态链表的使用会造成空间的碎片，经过删除操作之后结点的顺序并不连续，所以指针域中所储存的数值根本就没有啥意义，只是相对位置罢了，理解透这一点剩下的操作就跟动态链表的操作完全一样</p><p><img src="/posts/50363/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230112012057.jpg"></p><p>此静态单链表的问题还是相当严重的，完全没有考虑输入错误的情况，默认所有操作完全合法，但是啊。。。。。如果真的要考虑用户输入这些东西的话我更宁愿用动态链表，如果只是比赛的话默认所有操作完全合法应该还是没问题的</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package leetcote;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    static int N = 1000;</span><br><span class="line">    static int e[] = new int[N];</span><br><span class="line">    static int ne[] = new int[N];</span><br><span class="line">    static int head = -1;</span><br><span class="line">    static int idx = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">            addToHead(i);</span><br><span class="line">        &#125;</span><br><span class="line">        print();</span><br><span class="line">        remove(2);</span><br><span class="line">        print();</span><br><span class="line">        addAtIndex(6,3);</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //头插法</span><br><span class="line">    //链表的逻辑顺序是不会变的，就是说永远能根据当前元素找到下一个元素，所以尾插法只是头指针的数值变不变而已</span><br><span class="line">    //绝对不要把idx当成判断链表大小的条件</span><br><span class="line">    static void addToHead(int x) &#123;</span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = head;</span><br><span class="line">        head = idx;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据下标返回数据</span><br><span class="line">    static int searchNum(int k) &#123;</span><br><span class="line">        int pos = head;</span><br><span class="line">        for (int i = 1; i &lt; k; i++)&#123;</span><br><span class="line">            pos = ne[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        return e[pos];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找数据返回下标（直接遍历？？？，不行，就算遍历你也不知道这到底是第几个元素，指针域的数据不能当作判断的标准）</span><br><span class="line">    static int searchIdx(int x) &#123;</span><br><span class="line">        int pos = head;</span><br><span class="line">        int num = -1;</span><br><span class="line">        do&#123;</span><br><span class="line">            num++;</span><br><span class="line">            if(e[pos] == x) &#123;</span><br><span class="line">                return num;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                pos = ne[pos];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;while(pos != -1);</span><br><span class="line"></span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //插入，先找前驱，再进行插入，可以直接使用上面的查找方法</span><br><span class="line">    //现在我更加怀疑学长的代码是有问题的</span><br><span class="line">    //现在可以十分确定我已经完全理解了静态链表，还是得靠自己实操画图~~~~~~，虽然过程真TM头疼</span><br><span class="line"></span><br><span class="line">    static void addAtIndex(int x, int k) &#123;</span><br><span class="line">        if (k == 0) &#123;</span><br><span class="line">            addToHead(x);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int pos = head;</span><br><span class="line">        for (int i = 0; i &lt; k - 1; i++) &#123;</span><br><span class="line">            pos = ne[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = ne[pos];</span><br><span class="line">        ne[pos] = idx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void remove(int k) &#123;</span><br><span class="line">        if (k == 0) &#123;</span><br><span class="line">            head = ne[head];</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int pos = head;</span><br><span class="line">            for (int i = 0; i &lt; k - 1; i++) &#123;</span><br><span class="line">                pos = ne[pos];</span><br><span class="line">            &#125;</span><br><span class="line">            ne[pos] = ne[ne[pos]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //打印数组中元素</span><br><span class="line">    static void print() &#123;</span><br><span class="line">        int pos = head;</span><br><span class="line">        while (pos != -1) &#123;</span><br><span class="line">            System.out.println(e[pos]);</span><br><span class="line">            pos = ne[pos];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ps:学长的代码是头插法，然后头插完之后的数据是5 4 3 2 1，插完之后再remove一个2，移除第二个元素，移除完之后的数据是5 4 3 1，感觉不对，如果是如果是移除第二个元素那么结构应该要么是5 3 2 1 要么是5 4 2 1 </p><p>这里附上学长的代码以供参考，万一是我错了嘞？？？</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">        using namespace std;</span><br><span class="line">        int n;</span><br><span class="line">        const int N = 1e5+10;</span><br><span class="line">        int head,e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line">        void init()</span><br><span class="line">        &#123;</span><br><span class="line">        head = -1;</span><br><span class="line">        idx = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void add_to_head(int x)</span><br><span class="line">        &#123;</span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = head;</span><br><span class="line">        head = idx;</span><br><span class="line">        idx++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void add(int k, int x)</span><br><span class="line">        &#123;</span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = ne[k];</span><br><span class="line">        ne[k] = idx;</span><br><span class="line">        idx++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void remove(int k)</span><br><span class="line">        &#123;</span><br><span class="line">        ne[k] = ne[ne[k]];</span><br><span class="line">        &#125;</span><br><span class="line">        int main()</span><br><span class="line">        &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        init();</span><br><span class="line">        for(int i = 1; i &lt;= n ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">        int x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        add_to_head(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = head ; i != -1; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">        cout &lt;&lt; e[i] &lt;&lt; &#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        puts(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">        remove(2);</span><br><span class="line"></span><br><span class="line">        for(int i = head ; i != -1; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">        cout &lt;&lt; e[i] &lt;&lt; &#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="静态双链表"><a href="#静态双链表" class="headerlink" title="静态双链表"></a>静态双链表</h2><p>这里我不再重新写一个静态双链表，用一个题目说明一切</p><p>[题目连接](<a href="https://www.luogu.com.cn/record/99490970">记录详情 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a>)</p><p><img src="/posts/50363/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230112161708.jpg"></p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class P1160 &#123;</span><br><span class="line">    static final int N = 101100;</span><br><span class="line">    static int e[] = new int[N];</span><br><span class="line">    static int l[] = new int[N];</span><br><span class="line">    static int r[] = new int[N];</span><br><span class="line">    static int head, tail, size, idx;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        inIt();</span><br><span class="line">        int n = sc.nextInt();</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            int k = sc.nextInt();</span><br><span class="line">            int p = sc.nextInt();</span><br><span class="line">            cr(i,k,p);</span><br><span class="line">        &#125;</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            int k = sc.nextInt();</span><br><span class="line">            remove(k);</span><br><span class="line">        &#125;</span><br><span class="line">        int s = 2;</span><br><span class="line">        int pos = r[head];</span><br><span class="line">        for (int i = 0; pos != 1; i++) &#123;</span><br><span class="line">            System.out.print(e[pos]+&quot; &quot;);</span><br><span class="line">            pos = r[pos];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static void inIt() &#123;</span><br><span class="line">        l[0] = -1;</span><br><span class="line">        r[0] = 2;</span><br><span class="line">        l[1] = 2;</span><br><span class="line">        r[2] = -1;</span><br><span class="line">        e[2] = 1;</span><br><span class="line">        l[2] = 0;</span><br><span class="line">        r[2] = 1;</span><br><span class="line">        head = 0;</span><br><span class="line">        tail = 1;</span><br><span class="line">        size = 1;</span><br><span class="line">        idx = 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void cr(int num, int x, int w) &#123;</span><br><span class="line">        //num = 2, x = 1, w = 1</span><br><span class="line">        e[idx] = num;</span><br><span class="line">        if (w == 1) &#123;</span><br><span class="line">            l[idx] = x+1;</span><br><span class="line">            r[idx] = r[x+1];</span><br><span class="line">            l[r[x+1]] = idx;</span><br><span class="line">            r[x+1] = idx;</span><br><span class="line">            size++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            r[idx] = x+1;</span><br><span class="line">            l[idx] = l[x+1];</span><br><span class="line">            r[l[x+1]] = idx;</span><br><span class="line">            l[x+1] = idx;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void remove(int x) &#123;</span><br><span class="line">        if((l[x + 1] == -1 &amp;&amp; r[x + 1] == -1) || x &lt;= 0 || x &gt; size) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            r[l[x+1]] = r[x+1];</span><br><span class="line">            l[r[x+1]] = l[x+1];</span><br><span class="line">            l[x+1] = -1;</span><br><span class="line">            r[x+1] = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及到链表，最好画图，除非熟练度够，这个题目特殊的地方在于元素与地址是一一对应的，我们将元素1<del>n,依次储存在数组的2</del>n+1,而且我们是添加完所有元素之后才对数组进行删除操作，也就是说，只要知道元素的值我们可以马上知到它位于链表的什么位置，一般对链表元素进行操作的时候都要找到他的前驱，通过前驱对元素进行操作，这个题目特殊就在于，我们只要知道元素的值，就能直接推出他在链表中的位置，所以删除操作是非常简单的，这应该也算是一种特殊情况，元素的值竟然跟他所处的位置一一对应，话说这个题目感觉也不太像真正的双链表。。。。。。。。总之，这是一种特殊情况，不需要找前驱的特殊情况</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>环形链表</title>
      <link href="/posts/51245.html"/>
      <url>/posts/51245.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h1><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/"></a></p><p><img src="/posts/51245/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102210240.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>我们定义一个快指针，定义一个慢指针，快指针走两步，慢指针走一步，如果链表中存在环，那么这两个指针一定会相遇，这时候我们再让快指针跟慢指针开始一步一步走，那么相遇的地方就是进入循环的地方（需要数学证明）</p><p>当两个指针相遇后，让快指针从头开始跟慢指针一起一步一步走，那么相遇的点一定是入口</p><p><img src="/posts/51245/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102212216.png"></p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode detectCycle(ListNode head) &#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            if (slow == fast) &#123;</span><br><span class="line">                ListNode index1 = fast;</span><br><span class="line">                ListNode index2 = head;</span><br><span class="line">                while (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                return index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希集合"><a href="#哈希集合" class="headerlink" title="哈希集合"></a>哈希集合</h3><p>施工中</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表相交</title>
      <link href="/posts/31522.html"/>
      <url>/posts/31522.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/"></a></p><p><img src="/posts/31522/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102204219.png" alt="微信截图_20230102204219"></p><p><img src="/posts/31522/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102204240.png"></p><p><img src="/posts/31522/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102204248.png"></p><p><img src="/posts/31522/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102204256.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>关键还是要明确这个相交链表的形状，如果相交，那么形状只有可能是一个y形，并且开口只能朝左，如果方向不一样我就要怀疑他是二叉树了，所以如果两个相交链表不一样长，那么只有可能是开头的部分不一样长，从相交点到尾部的长度一定一样（感觉自己在说一堆废话但是道理就是这个道理）</p><p>按照这个道理，我们可以先确定两个链表的长度，然后让长的链表先走，直到长链表剩下的长度跟短链表一样长，然后让长链表跟短链表一起走，（相交点只可能出现于这个部分），如果有交点，返回，如果没有交点，结束</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">        ListNode cur1 = headA;</span><br><span class="line">        int a = 0;</span><br><span class="line">        ListNode cur2 = headB;</span><br><span class="line">        int b = 0;</span><br><span class="line">        //确定a长度</span><br><span class="line">        while (cur1 != null) &#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">        //确定b长度</span><br><span class="line">        while (cur2 != null) &#123;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">            b++;</span><br><span class="line">        &#125;</span><br><span class="line">        //为了不改变链表结构</span><br><span class="line">        cur1 = headA;</span><br><span class="line">        cur2 = headB;</span><br><span class="line">        //确定差值</span><br><span class="line">        int cz = Math.abs(a-b);</span><br><span class="line">        //让长链表先走</span><br><span class="line">        if (a &gt; b) &#123;</span><br><span class="line">            for (int i = 0; i &lt; cz; i++) &#123;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (a &lt; b) &#123;</span><br><span class="line">            for (int i = 0; i &lt; cz; i++) &#123;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">//一起走，找交点</span><br><span class="line">        while (cur1 !=  cur2 &amp;&amp; cur2 != null &amp;&amp; cur1 != null) &#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">            if (cur1 == cur2 &amp;&amp; cur1 != null) &#123;</span><br><span class="line">                return cur1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur1;</span><br><span class="line">        //这个地方不可以改成null你可能会想，上面负责找交点的部分都没找到，为什么不可以返还null嘞？</span><br><span class="line">        //关键在于上面找焦点的部分工作的前提条件是第一个点，不是交点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希集合"><a href="#哈希集合" class="headerlink" title="哈希集合"></a>哈希集合</h3><p>施工中</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除链表的倒数第N个节点</title>
      <link href="/posts/52002.html"/>
      <url>/posts/52002.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="删除倒数第N个结点"><a href="#删除倒数第N个结点" class="headerlink" title="删除倒数第N个结点"></a>删除倒数第N个结点</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/"></a></p><p><img src="/posts/52002/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102202508.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="一般"><a href="#一般" class="headerlink" title="一般"></a>一般</h3><p>先确定链表长度，然后根据n的值在从前往后遍历，只不过这样就进行了两次扫描</p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><blockquote><p>&#96;&#96;</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummyhead = new ListNode();</span><br><span class="line">        dummyhead.next = head;</span><br><span class="line">        ListNode fast = dummyhead.next;</span><br><span class="line">        ListNode slow = dummyhead;</span><br><span class="line">        for (int i = 0; i &lt; n; i++ ) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(fast != null) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        return dummyhead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义两个指针一个fast，一个slow</p><p><img src="/posts/52002/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102203334.png"></p><p>先让快指针走n+1步</p><p><img src="/posts/52002/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102203342.png"></p><p>再让两个指针一起走直到快指针为null</p><p><img src="/posts/52002/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102203349.png"></p><p>这时满指针就是倒数第n个元素的前驱，进行标准操作即可</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>施工中ing</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两两交换链表中的结点</title>
      <link href="/posts/45642.html"/>
      <url>/posts/45642.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/"></a></p><p><img src="/posts/45642/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102190556.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>为啥我要先写递归法嘞，因为我自己最先写的就是递归法，渐渐发现递归的一些规律</p><p>首先现在发现的递归有两种，循环到最后一次就结束，还有一种是循环到最后一次后还要再往回走一遍，其实应该是都要往回走一遍的，毕竟函数进栈之后还要出栈对吧，但是我说的最后一次就结束是指往回的过程中没有操作，只是出栈，但是第二种的主要操作是在出栈的时候再执行，两种的区别是，一种在压栈的时候进行主要操作，一种是在出栈的时候进行主要操作，我写的是第一种</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">    //特判空链表和只有一个元素的链表</span><br><span class="line">        if (head == null || head.next == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建虚拟头节点，使用虚拟头节点对链表进行操作</span><br><span class="line">        ListNode dummyhead = new ListNode();</span><br><span class="line">        dummyhead.next = head;</span><br><span class="line">        swap(dummyhead, head);</span><br><span class="line">        return dummyhead.next;</span><br><span class="line">        //不能返回head，head已经被修改返回虚拟头节点的下一个节点也就是链表第一个节点</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ListNode swap(ListNode pre, ListNode now) &#123;</span><br><span class="line">    //如果当前节点为空，或者当前节点的下一个节点为空，返回前一个节点</span><br><span class="line">    //当前节点的下一个节点为空则说明该链表为奇数链表</span><br><span class="line">        if (now == null || now.next == null) &#123;</span><br><span class="line">            return pre;</span><br><span class="line">        &#125;</span><br><span class="line">        //关键，防止断链</span><br><span class="line">        ListNode temp = now.next.next;</span><br><span class="line">        //保证pre节点连接正确</span><br><span class="line">        ListNode cur = pre;</span><br><span class="line">        pre = pre.next.next;</span><br><span class="line">        pre.next = now;</span><br><span class="line">        now.next = temp;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        return swap(now, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉我的递归更像是循环，把整个操作看成许多个小节，每个小节的操作相同，关键是控制进入下一个循环的变量是啥谁是pre，谁是now。循环到最后一个小结修改完成，出栈<img src="/posts/45642/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102193133.png"></p><p>这个就是明显的主要操作在出栈时候的</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">//这里的head是头节点不是头指针</span><br><span class="line">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">    //特判空链表和单元素链表</span><br><span class="line">        if (head == null || head.next == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        //用new节点来记录当前节点处理完之后要连接的结点。</span><br><span class="line">        ListNode newNode = swapPairs(next.next);</span><br><span class="line">        next.next = head;</span><br><span class="line">        head.next = newNode;</span><br><span class="line"></span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/45642/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102201650.png"></p><p>用new来记录当前节点要连接的节点</p><h3 id="指针法"><a href="#指针法" class="headerlink" title="指针法"></a>指针法</h3><p>&#96;&#96;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虚拟头结点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummyNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (prev.next != <span class="literal">null</span> &amp;&amp; prev.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next.next; <span class="comment">// 缓存 next</span></span><br><span class="line">      prev.next = head.next;          <span class="comment">// 将 prev 的 next 改为 head 的 next</span></span><br><span class="line">      head.next.next = head;          <span class="comment">// 将 head.next(prev.next) 的next，指向 head</span></span><br><span class="line">      head.next = temp;               <span class="comment">// 将head 的 next 接上缓存的temp</span></span><br><span class="line">      prev = head;                    <span class="comment">// 步进1位</span></span><br><span class="line">      head = head.next;               <span class="comment">// 步进1位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/45642/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102202128.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻转链表</title>
      <link href="/posts/9249.html"/>
      <url>/posts/9249.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h1><p><a href="https://leetcode.cn/problems/reverse-linked-list/"></a></p><p><img src="/posts/9249/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102175824.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="指针法"><a href="#指针法" class="headerlink" title="指针法"></a>指针法</h3><p>​这个题目总体来说还是不难的，使用双指针法进行操作，但是不知道其他语言是咋样的，Java要使用三指针，要不然会断链。</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        if (head == null) &#123;//特判头节点为空的情况</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        ListNode now = head;</span><br><span class="line">        ListNode pre = null;</span><br><span class="line">        while (next != null) &#123;</span><br><span class="line">            now.next = pre;</span><br><span class="line">            pre = now;</span><br><span class="line">            now = next;</span><br><span class="line">            next = next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //循环完之后的情况见下图，还要对now进行一次操作之后再返回，因为执行循环结束之后now是独立的</span><br><span class="line">        now.next = pre;</span><br><span class="line">        head = now;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/9249/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102180554.png"></p><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>第一种递归，分小段进行类似循环的处理，在没有到最后一个的时候继续压栈，到最后一个的时候全部释放，链表在压栈的时候就已经修改完毕</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        return reverse(null, head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ListNode reverse(ListNode now, ListNode next) &#123;</span><br><span class="line">        if(next == null) &#123;</span><br><span class="line">            return now;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode temp = next.next;</span><br><span class="line">        next.next = now;</span><br><span class="line">        return reverse(next, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/9249/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102182630.png"></p><p>第二种递归</p><p>这种递归的方式给我的感觉像是子弹上膛，我们先从前往后把子弹一颗一颗的塞到弹匣里，塞满之后再从后往前的一颗一颗的对子弹进行操作，直到打完所有弹匣，</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        //递归终止条件是当前为空，或者下一个节点为空</span><br><span class="line">        //如果链表为空或者链表只有一个元素不会递归</span><br><span class="line">        if(head==null || head.next==null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = reverseList(head.next);</span><br><span class="line">        //cur永远是最后一个节点</span><br><span class="line">        //一次递归就对一个节点进行操作</span><br><span class="line">        //跟上一个递归解法不同的是，上个递归在到最后一个元素时链表便已经完成修改</span><br><span class="line">        //让当前节点下一个节点的下一个节点为当前节点，当前节点的下一个节点改为空节点</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = null;</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/9249/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102184955.png"></p><p><img src="/posts/9249/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102190324.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>707.设计链表</title>
      <link href="/posts/61137.html"/>
      <url>/posts/61137.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h1><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>[设计链表](<a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表 - 力扣（LeetCode）</a>)</p><p><img src="/posts/61137/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221222193145.jpg"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>经常用到的操作，<strong>设置中间变量</strong>，<strong>找前驱</strong>，<strong>标准操作</strong>（使用虚拟节点也是为了方便找前驱）</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//节点类</span><br><span class="line">class ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode()&#123;&#125;</span><br><span class="line">    ListNode(int val)&#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//单向链表</span><br><span class="line">//链表元素下标为[0-index)</span><br><span class="line">//链表大小为（0-index]  [1-index]</span><br><span class="line">class MyLinkedList &#123;</span><br><span class="line">    int size;</span><br><span class="line">    ListNode head;</span><br><span class="line">//构造方法</span><br><span class="line">    public MyLinkedList() &#123;</span><br><span class="line">        int size = 0;</span><br><span class="line">        head = new ListNode();</span><br><span class="line">    &#125;</span><br><span class="line">//获取节点元素</span><br><span class="line">    public int get(int index) &#123;//获取数值</span><br><span class="line">    //判断下标是否合法</span><br><span class="line">        if(index &lt; 0 || index &gt;= size)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        //设置中间变量</span><br><span class="line">            ListNode cur = head;</span><br><span class="line">            //寻找该节点</span><br><span class="line">//头节点——头指针，指向的下一个元素才是第一个节点，我们要找下标为0的节点其实就是头节点的下一个节点</span><br><span class="line">//时刻记住我们是在对头节点进行操作</span><br><span class="line">//这里的head节点相当于dummyhead,如果要查看n位置的节点，就移动n+1次</span><br><span class="line">            for(int i = 0; i &lt;= index; i++)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            return cur.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addAtHead(int val) &#123;//头插</span><br><span class="line">        addAtIndex(0,val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addAtTail(int val) &#123;//尾插</span><br><span class="line">        addAtIndex(size,val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addAtIndex(int index, int val) &#123;//根据下标插入</span><br><span class="line">        if(index &gt; size)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(index &lt; 0)&#123;//我觉得这里可以return</span><br><span class="line">            index = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        //只要下标合法，size++,所以链表大小为（0-index]  [1-index]</span><br><span class="line">        size++;</span><br><span class="line">        ListNode pred = head;</span><br><span class="line">//找前驱</span><br><span class="line">//这里的head节点相当于虚拟头节点，在第n个位置插入就移动n次</span><br><span class="line">        for(int i = 0; i &lt; index; i++)&#123;//细节，只要找到前一个就可以</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //需要插入的节点</span><br><span class="line">        ListNode toAdd = new ListNode(val);</span><br><span class="line">        //对前驱进行标准操作</span><br><span class="line">        toAdd.next = pred.next;</span><br><span class="line">        pred.next = toAdd;</span><br><span class="line">    &#125;</span><br><span class="line">//删除某位置的节点</span><br><span class="line">    public void deleteAtIndex(int index) &#123;</span><br><span class="line">    //判断是否合法</span><br><span class="line">        if(index &lt; 0 || index &gt;= size)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果合法，链表大小--；</span><br><span class="line">        size--;</span><br><span class="line">        //如果为0，则让头节点向前移动一位</span><br><span class="line">        //如果是循环链表，直接让头节点向前移动估计不行</span><br><span class="line">        if(index == 0)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果是头节点之外的其他节点，找前驱，进行标准操作</span><br><span class="line">        ListNode pred = head;</span><br><span class="line">        for(int i = 0; i &lt; index; i++)&#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pred.next = pred.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//节点类</span><br><span class="line">class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next,prev;//下一个上一个</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//双向链表（双向链表！=循环链表）</span><br><span class="line">class MyLinkedList &#123;</span><br><span class="line">    ListNode head,tail;//前驱，后继，相当于dummyhead</span><br><span class="line">    int size;//链表长度</span><br><span class="line"></span><br><span class="line">//构造方法</span><br><span class="line">    public MyLinkedList() &#123;</span><br><span class="line">        this.size = 0;</span><br><span class="line">        this.head = new ListNode(0);</span><br><span class="line">        this.tail = new ListNode(0);</span><br><span class="line">        //这一步非常关键，否则在加入头结点的操作中会出现null.next的错误！！！</span><br><span class="line">        //让头的后继，尾的前驱不为空，让两个节点相连形成一个双向链</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">//获取某位置的元素</span><br><span class="line">    public int get(int index) &#123;</span><br><span class="line">    //不合法返回-1</span><br><span class="line">        if(index &lt; 0 || index &gt;= size) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    //设置中间变量，对中间变量进行操作，毕竟头节点不能变对吧</span><br><span class="line">        ListNode cur = this.head;</span><br><span class="line">    //优化，如果离头近就从头往前找，如果离尾近就从头往后找</span><br><span class="line">        if (index &gt;= size / 2) &#123;</span><br><span class="line">            cur = tail;</span><br><span class="line">            for (int i = 0; i &lt; size - index; i++) &#123;</span><br><span class="line">                cur = cur.prev;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt;= index; i++) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">//头插法</span><br><span class="line">    public void addAtHead(int val) &#123;</span><br><span class="line">        addAtIndex(0,val);</span><br><span class="line">    &#125;</span><br><span class="line">//尾插法</span><br><span class="line">    public void addAtTail(int val) &#123;</span><br><span class="line">        addAtIndex(size,val);</span><br><span class="line">    &#125;</span><br><span class="line">//在对应位置插入节点</span><br><span class="line">    public void addAtIndex(int index, int val) &#123;</span><br><span class="line">    //判断下标是否合法</span><br><span class="line">        if (index &gt; size) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (index &lt; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    //如果下标合法</span><br><span class="line">        size++;</span><br><span class="line">    //设置中间变量</span><br><span class="line">        ListNode pre = this.head;</span><br><span class="line">    //寻找index的前驱，第一个节点的前驱就是头节点</span><br><span class="line">        for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">    //需要插入的节点</span><br><span class="line">        ListNode node = new ListNode(val);</span><br><span class="line">    //标准操作</span><br><span class="line">    //先让当前节点与两边节点产生联系</span><br><span class="line">        node.prev = pre;</span><br><span class="line">        node.next = pre.next;</span><br><span class="line">    //前驱下一个节点的前驱设置为当前节点</span><br><span class="line">        pre.next.prev = node;</span><br><span class="line">    //前驱的下一个节点设置为当前节点</span><br><span class="line">        pre.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">//删除指定位置的元素</span><br><span class="line">    public void deleteAtIndex(int index) &#123;</span><br><span class="line">    //判断下标是否合法</span><br><span class="line">        if (index &lt; 0 || index &gt;= size) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果下标合法</span><br><span class="line">        size--;</span><br><span class="line">        //设置中间变量</span><br><span class="line">        ListNode pre = this.head;</span><br><span class="line">        //寻找该位置前驱</span><br><span class="line">        for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">            pre =pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //标准操作</span><br><span class="line">        pre.next.next.prev = pre;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="line"> * MyLinkedList obj = new MyLinkedList();</span><br><span class="line"> * int param_1 = obj.get(index);</span><br><span class="line"> * obj.addAtHead(val);</span><br><span class="line"> * obj.addAtTail(val);</span><br><span class="line"> * obj.addAtIndex(index,val);</span><br><span class="line"> * obj.deleteAtIndex(index);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>收获还是挺大，事实再次证明只有真正动手实操才能真正掌握一门技术，光懂原理不实操是完全不行的</p><p>在对链表的操作中有很多都要涉及到对范围的判断，所以以后统一链表长度为[1-index]，链表元素的下标为[0-index)</p><p>重点理解，头指针跟头节点的区别，因为Java没有指针，只有引用数据类型，而且head还是用节点类进行创建的，但head并不是头节点，里面是没有数据的，他的的下一个节点才是头节点，而head相当于dummyhead或者头指针</p><p>而且我们的操作几乎都是建立在头指针上的，所以用了许多创建中间变量的方法保证头指针始终指向头节点</p><p>双向链表不等于循环链表，只要一直保证头指针指向第一个节点，尾指针指向最后一个节点就行，关于查找的优化操作需要注意范围的限制</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>203.移除链表元素</title>
      <link href="/posts/10614.html"/>
      <url>/posts/10614.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/posts/10614/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221222175350.png"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeElements(ListNode head, int val) &#123;</span><br><span class="line">        ListNode mid = new ListNode();</span><br><span class="line">        if(head == null)&#123;//似乎多余？？？</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        while(head.val == val &amp;&amp; head != null)&#123;</span><br><span class="line">            head = head.next;//转移头节点</span><br><span class="line">            if(head == null)&#123;</span><br><span class="line">                return head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = head;</span><br><span class="line">        while(mid.next != null)&#123;</span><br><span class="line">            if(mid.next.val == val)&#123;</span><br><span class="line">                mid.next = mid.next.next;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = mid.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缝缝补补做出</p><p>关键在第一个节点的操作上，因为我们删除一个节点是对这个节点的上一个节点进行操作</p><p>ps</p><p>1.如果节点头为空，直接返回</p><p>2.在第一节点特判时，如果为空，直接返回</p><p>3.创建中间变量对中间变量进行操作保证头节点一直是头节点</p><p>4.中间变量只是引用数据类型，会改变实际的值，但是head不变就可以</p><h2 id="大佬的思路——虚拟头节点"><a href="#大佬的思路——虚拟头节点" class="headerlink" title="大佬的思路——虚拟头节点"></a>大佬的思路——虚拟头节点</h2><p><strong>优势</strong>：在一般操作的情况下，我们删除或者增添节点的时候对头节点和其他节点的操作不同，如果使用头节点，那么我们可以使增删头节点的方式与其他节点相同，起到统一操作的作用</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeElements(ListNode head, int val) &#123;</span><br><span class="line">    //重要操作</span><br><span class="line">        ListNode dummyHead = new ListNode();</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode cur = dummyHead;</span><br><span class="line">        while(cur.next != null)&#123;</span><br><span class="line">            if(cur.next.val == val)&#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps:</p><p>不能返回原来的头节点，因为可能已经被删除（这里应该具体研究一下），<strong>返回cur.next</strong></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>让所有值不等于val的节点连接成一个新的节点</p><p>有点考逻辑，但是如果用一句话来形容的话——我来组成下一个节点，感觉像拼火车？？？</p><p>这个程序给我的感觉是先全部展开，再依次收拢</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeElements(ListNode head, int val) &#123;</span><br><span class="line">        if(head==null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next=removeElements(head.next,val);//</span><br><span class="line">        if(head.val==val)&#123;//特判头节点，返回的值一定为head,只不过主体部分已经修改完毕，不对</span><br><span class="line">        //判断当前节点的值是否等于val，如果是返回下一个节点，否则返回当前节点</span><br><span class="line">            return head.next;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/posts/54862.html"/>
      <url>/posts/54862.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="线性表的顺序储存结构"><a href="#线性表的顺序储存结构" class="headerlink" title="线性表的顺序储存结构"></a>线性表的顺序储存结构</h2><h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><p>​<img src="/posts/54862/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221222165127.png"></p><p>元素之间有序，不存在空位，第一个元素无前驱，最后一个元素无后继，其他每个元素有且只有一个前驱和后记，并且有限</p><h3 id="关键操作"><a href="#关键操作" class="headerlink" title="关键操作"></a>关键操作</h3><p><strong>赋值&amp;&amp;扩容</strong></p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void InitList(int data) &#123;//给线性表从0开始依次赋值</span><br><span class="line">    if(size==L.length)&#123;//如果满容，进行扩容</span><br><span class="line">        this.L= Arrays.copyOf(this.L,this.L.length*2);</span><br><span class="line">    &#125;</span><br><span class="line">    L[size++]=data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入元素，删除元素</strong></p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void remove(int key) &#123;//删除链表中的某个值</span><br><span class="line">    int index=this.search(key);</span><br><span class="line">    if(index==-1)&#123;</span><br><span class="line">        System.out.println(&quot;没找到要删除的数字&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=index;i&lt;size-1;i++)&#123;//将pos之后的元素集体左移</span><br><span class="line">        this.L[i]=this.L[i+1];</span><br><span class="line">    &#125;</span><br><span class="line">    this.size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void add(int pos, int data) &#123;//插入元素</span><br><span class="line">    if(pos&lt;0||pos&gt;=size)&#123;//如果插入坐标不在线性表坐标之内，抛出异常</span><br><span class="line">        System.out.println(&quot;坐标不合法&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        for(int i=size-1;i&gt;pos;i--)&#123;//坐标合法，将pos之后的（包括pos）元素右移，然后给pos位置的元素赋值</span><br><span class="line">            L[i]=L[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        L[pos]=data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优</strong></p><p>无需为元素之间的逻辑关系额外增加储存空间</p><p>科快速存取任意位置的表中元素</p><p><strong>缺</strong></p><p>插入和删除操作需要移动大量元素</p><p>容易造成储存空间的”碎片“</p><h3 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package List.shunxulist;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class MyArrylist implements SeqList&#123;</span><br><span class="line">    public int L[];</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    public MyArrylist()&#123;//构造函数，先构造一个长度为10的数组，如果长度不够，可以扩容</span><br><span class="line">        this.L=new int[10];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;//打印线性表中的所有元素</span><br><span class="line">        for(int i=0;i&lt;size;i++)&#123;</span><br><span class="line">            System.out.print(L[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void InitList(int data) &#123;//给线性表从0开始依次赋值</span><br><span class="line">        if(size==L.length)&#123;//如果满容，进行扩容</span><br><span class="line">            this.L= Arrays.copyOf(this.L,this.L.length*2);</span><br><span class="line">        &#125;</span><br><span class="line">        L[size++]=data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void add(int pos, int data) &#123;//插入元素</span><br><span class="line">        if(pos&lt;0||pos&gt;=size)&#123;//如果插入坐标不在线性表坐标之内，抛出异常</span><br><span class="line">            System.out.println(&quot;坐标不合法&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            for(int i=size-1;i&gt;pos;i--)&#123;//坐标合法，将pos之后的（包括pos）元素右移，然后给pos位置的元素赋值</span><br><span class="line">                L[i]=L[i-1];</span><br><span class="line">            &#125;</span><br><span class="line">            L[pos]=data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean contains(int toFind) &#123;//查找是否含有某个元素</span><br><span class="line">        for(int i=0;i&lt;this.size;i++)&#123;</span><br><span class="line">            if(toFind==L[i])&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int search(int toFind) &#123;//查找某个对应元素的坐标</span><br><span class="line">        for(int i=0;i&lt;this.size;i++)&#123;</span><br><span class="line">            if(toFind==L[i])&#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getPos(int pos) &#123;//查找某个坐标上的值</span><br><span class="line">        if(pos&lt;0||pos&gt;=size)&#123;</span><br><span class="line">            System.out.println(&quot;数组下标错误&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return this.L[pos];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stePos(int pos, int value) &#123;//将某个位置的值替换为某个值</span><br><span class="line">        if(pos&lt;0||pos&gt;=size)&#123;</span><br><span class="line">            System.out.println(&quot;数组下标错误&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        this.L[pos] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void remove(int key) &#123;//删除链表中的某个值</span><br><span class="line">        int index=this.search(key);</span><br><span class="line">        if(index==-1)&#123;</span><br><span class="line">            System.out.println(&quot;没找到要删除的数字&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=index;i&lt;size-1;i++)&#123;//将pos之后的元素集体左移</span><br><span class="line">            this.L[i]=this.L[i+1];</span><br><span class="line">        &#125;</span><br><span class="line">        this.size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int size() &#123;//获取链表长度</span><br><span class="line">        return this.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void clear() &#123;//重置链表</span><br><span class="line">        this.size=0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性表的链式储存结构"><a href="#线性表的链式储存结构" class="headerlink" title="线性表的链式储存结构"></a>线性表的链式储存结构</h2><p><img src="/posts/54862/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221222170215.png"></p><p>在链式储存中，每个元素除了储存该元素本身的信息之外，还需储存下一个元素的地址</p><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><p>头指针：链表中第一个节点的存储位置</p><p>头结点：单链表的第一个节点前附设一个结点，可不储存任何信息，头节点的指针域指向第一个节点的指针</p><p>ps:</p><p>1.头指针</p><p>头指针是指向链表的第一个节点的指针，若链表有头节点，则是指向头节点的指针</p><p>头指针具有表示作用，常用链表的名字作为头指针的名字</p><p>无论链表是否为空，头指针均不为空，头指针是链表的必要元素</p><p>2.头节点</p><p>存在头节点时，对第一元素节点前插入节点和删除第一节点与其他操作就统一了</p><p>头节点不一定是链表的必要元素</p><h3 id="关键操作-1"><a href="#关键操作-1" class="headerlink" title="关键操作"></a>关键操作</h3><p>&#96;&#96;</p><p>添加</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//头插法</span><br><span class="line">public void addFirst(int data)&#123;</span><br><span class="line">    Node node = new Node(data);//创建新节点</span><br><span class="line">    //注意理解我们这里是在什么对象的角度去进行操作的</span><br><span class="line">    if(this.head==null)&#123;//如果第一个节点是空的，复制给第一个节点</span><br><span class="line">        this.head = node;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //如果第一个节点不空，执行标准化操作</span><br><span class="line">        node.next = this.head;//新节点的指针域指向旧节点</span><br><span class="line">        this.head = node;//现在我们是下一个操作对象的新节点</span><br><span class="line">    &#125;</span><br><span class="line">    //跟C的思路好像有点不同</span><br><span class="line">    //开始回忆，C是创建新节点，把新节点的指针域赋值为旧节点的指针域（换屁股），然后把就节点的指针域赋值为当前节点（头插进屁股里）</span><br><span class="line">    this.usedSize++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>//为了节约时间直接把尾插法写在这里//这个尾插法不存粹，不够快，好处是可以跟这个头插法的代码一起用//原理是从第一个遍历到最后一个，然后再插入，比起存粹的尾插速度要慢很多，在数据大的时候public void addLast(int data)&#123;    //创建新节点    Node node = new Node(data);    if(this.head == null)&#123;        this.head = node;    &#125;else&#123;        Node cur = this.head;        while(cur.next!=null)&#123;            cur = cur.next;        &#125;        cur.next = node;    &#125;    this.usedSize++;&#125;`</code></pre><p>&#96;&#96;</p><p>插入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void addLast(int data)&#123;</span><br><span class="line">    //创建新节点</span><br><span class="line">    Node node = new Node(data);</span><br><span class="line">    if(this.head == null)&#123;</span><br><span class="line">        this.head = node;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        Node cur = this.head;</span><br><span class="line">        while(cur.next!=null)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    this.usedSize++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package List.lianshilist;</span><br><span class="line"></span><br><span class="line">public class Node &#123;</span><br><span class="line">    public int value;//储存数据</span><br><span class="line">    public Node next;//-&gt;next，储存下一个节点的地址</span><br><span class="line"></span><br><span class="line">    public Node (int value)&#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package List.lianshilist;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* 这个对象只用创建一次，为链表中的第一个元素，头指针为这个对象的对象名</span><br><span class="line">* 之后不断往里面添加节点类就可以，头节点不变（头插法的话）</span><br><span class="line">* 所以获取其他值很难，只能从第一个开始往后循环去找，时间复杂度为O（n）</span><br><span class="line">* 但是插入跟删除异常方便，而且不用担心内存问题</span><br><span class="line">* */</span><br><span class="line"></span><br><span class="line">import java.nio.channels.Pipe;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedList &#123;</span><br><span class="line">    public Node head;//head永远是第一个</span><br><span class="line">    public int usedSize;</span><br><span class="line"></span><br><span class="line">    //头插法</span><br><span class="line">    public void addFirst(int data)&#123;</span><br><span class="line">        Node node = new Node(data);//创建新节点</span><br><span class="line">        //注意理解我们这里是在什么对象的角度去进行操作的</span><br><span class="line">        if(this.head==null)&#123;//如果第一个节点是空的，复制给第一个节点</span><br><span class="line">            this.head = node;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //如果第一个节点不空，执行标准化操作</span><br><span class="line">            node.next = this.head;//新节点的指针域指向旧节点</span><br><span class="line">            this.head = node;//现在我们是下一个操作对象的新节点</span><br><span class="line">        &#125;</span><br><span class="line">        //跟C的思路好像有点不同</span><br><span class="line">        //开始回忆，C是创建新节点，把新节点的指针域赋值为旧节点的指针域（换屁股），然后把就节点的指针域赋值为当前节点（头插进屁股里）</span><br><span class="line">        this.usedSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //为了节约时间直接把尾插法写在这里</span><br><span class="line">    //这个尾插法不存粹，不够快，好处是可以跟这个头插法的代码一起用</span><br><span class="line">    //原理是从第一个遍历到最后一个，然后再插入，比起存粹的尾插速度要慢很多，在数据大的时候</span><br><span class="line">    public void addLast(int data)&#123;</span><br><span class="line">        //创建新节点</span><br><span class="line">        Node node = new Node(data);</span><br><span class="line">        if(this.head == null)&#123;</span><br><span class="line">            this.head = node;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            Node cur = this.head;</span><br><span class="line">            while(cur.next!=null)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        this.usedSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //打印单链表</span><br><span class="line">    public void myToString()&#123;</span><br><span class="line">        Node cur = this.head;//从第一个开始遍历</span><br><span class="line">        while(cur != null)&#123;</span><br><span class="line">            System.out.print(cur.value+&quot; &quot;);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //单链表的查找</span><br><span class="line">    public boolean contains(int key)&#123;</span><br><span class="line">        Node cur = this.head;</span><br><span class="line">        while(cur!=null)&#123;</span><br><span class="line">            if(cur.value == key)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取单链表的长度</span><br><span class="line">    public int length()&#123;</span><br><span class="line">        return this.usedSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获得插入位置的前区节点</span><br><span class="line">    //为什么要获取前驱节点，因为我们只有通过前驱节点的指针域才能访问我们要的那个节点</span><br><span class="line">    public Node getIndex(int pos)&#123;</span><br><span class="line">        Node cur = this.head;</span><br><span class="line">        int index = 0;</span><br><span class="line">        while(index++ != pos-1)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //插入节点任意位置插入，第一个数据节点为0号下标</span><br><span class="line">    public void insert(int pos,int data)&#123;</span><br><span class="line">        if(pos&lt;0||pos&gt;this.usedSize)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;插入位置不合法&quot;);</span><br><span class="line">            //这是一条我没学过的代码，异常抛出？为啥不用return勒</span><br><span class="line">            //猜测，如果return，那么会接着执行主程序的吓一条代码，这里是直接结束程序</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(pos == 0)&#123;</span><br><span class="line">            addFirst(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(pos == this.usedSize)&#123;</span><br><span class="line">            addLast(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node node = new Node(data);</span><br><span class="line">        Node prev = getIndex(pos);//获得插入位置的前驱节点</span><br><span class="line">        node.next = prev.next;</span><br><span class="line">        prev.next = node;</span><br><span class="line">        this.usedSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //清空链表</span><br><span class="line">    public void clear()&#123;</span><br><span class="line">        this.head = null;</span><br><span class="line">        //当head设置为null后，之后的节点对象都变成未被引用的对象，垃圾回收器会自动回收这些未被引用的对象</span><br><span class="line">        //C要创建两个指针，一个一个的释放内存一个储存当前位置，一个储存下一位置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>单链表机构在有频繁插入跟删除元素的条件下表现非常优秀，时间复杂度仅为O(1)，但查找比较费时，而且用了多余的储存空间去储存了元素之间的逻辑结构，但是不用担心储存空间的分配，元素个数不被限制</p><p>需要理解的是，<strong>单链表结构的操作对象是当前的元素</strong>，类比和尚滚佛珠，还有插入删除操作的顺序一定不可以错</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>剪刀石头布</title>
      <link href="/posts/18553.html"/>
      <url>/posts/18553.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剪刀石头布"><a href="#剪刀石头布" class="headerlink" title="剪刀石头布"></a>剪刀石头布</h1><p>​跟我这种垃圾想出来的代码完全不一样，我的思路是用循环链表存储人类输入的数据然后根据根据人类前几次输入的结果去进行输出，如果前面出的布多，就增加出现剪刀的可能性，如果出现的石头多，就增加出现布的可能性</p><p>​不得不说，我的可能太低级了，只不过这确实是我的第一思路，但是老师的思路显然也有缺陷，太过死板，如果知道背后逻辑肯定可以100%取胜，不过对不知道的人的赢面还是不错的，<strong>他的代码，是通过判断人类下一步更可能出什么</strong>，就是人出了剪刀之后更可能会出什么，人出了石头之后更可能会出什么，人出了布之后更可能会出什么，虽然我们只需要统计数据计算然后让计算机去执行计算就可以，我们可以用九个变量去储存计算机的逻辑部分，分别统计人出拳之后再出拳的概率即可，但是老师的代码在数据结构的安排上显然“更有意思”</p><p>​<img src="/posts/18553/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221222005836.jpg"></p><p>​但是在知道数据库时，人在不出错并且知道底层逻辑的情况下依然可以完胜计算机（没错，就是我）</p><p>​我想，如果让我改进这个算法我会保留随机性，如果出剪刀之后出石头的可能性大，就增加出布的可能性，把二维数组换成由结构体组成的二维数组，一个储存次数（int），一个储存可能性（double），需要解决的问题是，如何根据可能性去生成计算机要出的结果（这个属于实现方面比较简单），还有一个是怎么去计算每次人出拳后计算机出拳的可能性，这个是数学问题，不太好想（人出拳的可能性是多少，那我下一局出布的可能性是多少？人出拳的概率对我下一回合出拳胜率的影响，似乎涉及到统计学跟概率学。。。。。。cao）</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package computer;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class text &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        int memory[][] = new int[3][3];</span><br><span class="line">        int counter=0;//记录猜拳的回合数</span><br><span class="line">        int human;//记录人类本次出拳</span><br><span class="line">        int computer;//记录计算机出拳</span><br><span class="line">        int id;//记录人类上次出拳后，出拳次数最多的是那种</span><br><span class="line">        int max;//记录根据id推出的计算机出拳</span><br><span class="line">        int prev=0;//记录人类上一次出拳</span><br><span class="line"></span><br><span class="line">        while(true)&#123;</span><br><span class="line">            counter++;</span><br><span class="line">            System.out.printf(&quot;该你出拳了！请输入:0-石头；1-剪刀；2-布\n&quot;);</span><br><span class="line">            human= sc.nextInt();</span><br><span class="line">            if(human!=0&amp;&amp;human!=1&amp;&amp;human!=2)&#123;</span><br><span class="line">                System.out.println(&quot;输入不合法，请重新输入&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;//输入012以外的数据退出循环</span><br><span class="line">            //此处代码可让学生优化，若非合理输入，用户循环实现合理输入为止</span><br><span class="line">            if(counter&lt;=12) &#123;//前十回合，计算机随机出拳，统计数据</span><br><span class="line">                computer = (int)(Math.random()*3);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                id=0;//我出剪刀的几率高</span><br><span class="line">                if(memory[prev][id]&lt;memory[prev][1])id=1;//我出石头的几率高</span><br><span class="line">                if(memory[prev][id]&lt;memory[prev][2])id=2;//我出布的几率高</span><br><span class="line">                if(id==0)max=2;//出布</span><br><span class="line">                else if(id==1)max=0;//出剪刀</span><br><span class="line">                else max=1;//出石头</span><br><span class="line">                computer=max;</span><br><span class="line">            &#125;</span><br><span class="line">            output(human,computer);//输出出拳信息和胜负信息</span><br><span class="line">            memory[prev][human]++;</span><br><span class="line">            for(int i=0;i&lt;3;i++)&#123;</span><br><span class="line">                for(int j=0;j&lt;3;j++)&#123;</span><br><span class="line">                    System.out.print(memory[i][j]+&quot; &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">            prev=human;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void output(int human,int computer)&#123;</span><br><span class="line">        if(human==computer)&#123;</span><br><span class="line">            System.out.println(&quot;你和计算机本局打平啦！&quot;);</span><br><span class="line">            switch(human)&#123;</span><br><span class="line">                case 0:</span><br><span class="line">                System.out.println(&quot;你和计算机都出了石头！&quot;);break;</span><br><span class="line">                case 1:</span><br><span class="line">                System.out.println(&quot;你和计算机都出了剪刀！&quot;);break;</span><br><span class="line">                case 2:</span><br><span class="line">                System.out.println(&quot;你和计算机都出了布！&quot;);break;</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(human==0)//你出了石头，计算机不是石头</span><br><span class="line">        &#123;</span><br><span class="line">            if(computer==1)</span><br><span class="line">                System.out.printf(&quot;你赢啦!你的出拳是石头，计算机出拳是剪刀！\n&quot;);</span><br><span class="line">            else</span><br><span class="line">                System.out.printf(&quot;计算机赢啦！你的出拳是石头，计算机出拳是布！\n&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(human==1)//你出了剪刀，计算机不是剪刀</span><br><span class="line">        &#123;</span><br><span class="line">            if(computer==2)</span><br><span class="line">                System.out.printf(&quot;你赢啦!你的出拳是剪刀，计算机出拳是布！\n&quot;);</span><br><span class="line">            else</span><br><span class="line">                System.out.printf(&quot;计算机赢啦！你的出拳是剪刀，计算机出拳是石头！\n&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(human==2)//你出了布，计算机不是布</span><br><span class="line">        &#123;</span><br><span class="line">            if(computer==0)</span><br><span class="line">                System.out.printf(&quot;你赢啦!你的出拳是布，计算机出拳是石头！\n&quot;);</span><br><span class="line">            else</span><br><span class="line">                System.out.printf(&quot;计算机赢啦！你的出拳是布，计算机出拳是剪刀！\n&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 有趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/posts/46132.html"/>
      <url>/posts/46132.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式，是一种类型的<strong>设计模式</strong>，是一种<strong>创建型模式</strong>，提供了一种创建对象的方式</p><p>这种模式涉及到一个单一的类，<strong>该类负责创建自己的对象</strong>，同时<strong>确保只有单个对象被创建</strong>，这个类<strong>提供了一种访问其唯一对象的方式</strong>，可以直接访问，<strong>不需要实例化该类的对象</strong></p><p>注意</p><p>单例类只能有一个实例</p><p>单例类必须自己创建自己的唯一实例</p><p>单例类必须给其他所有对象提供这一实例</p><p>要保证一个类仅有一个实例，并提供一个访问它的全局访问点</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><strong>主要解决</strong>：一个全局使用的类频繁的创建与销毁</p><p><strong>何时使用</strong>：当你想控制实例数目，节省系统资源的时候</p><p><strong>主要方法</strong>：判断系统是否已经有这个单例，如果有则返回，如果没有则创建</p><p><strong>关键代码</strong>：构造函数是私有的</p><p><strong>应用实例</strong>：</p><p>一个班级只有一个班主任</p><p>多线程程序操作一个文件的时候会不可避免的出现多个进程或者线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行</p><p>一些设备管理器常常设计为单例模式，比如一个电脑的两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件</p><p><strong>使用场景</strong>：</p><p>要求生产唯一的序列号</p><p>WEB中的技术器，不用每次刷新都在数据库里加一次，先用单例缓存起来</p><p>创建的一个对象需要消耗的资源过多，比如I&#x2F;O与数据库的连接</p><p><strong>优点</strong>：</p><p>内存里只有一个实例，减少内存的开销</p><p>避免对资源的多重占用</p><p>缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们创建一个a类，a类有它的私有构造函数和本身的一个静态实例，a类提供了一个静态方法，供外界获取它的静态实例</p><p>&#96;&#96;&#x2F;&#x2F;创建一个Singleton类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SingleObject &#123;</span><br><span class="line">    //创建 SingleObject 的一个对象</span><br><span class="line">    private static SingleObject instance = new SingleObject();</span><br><span class="line">    //让构造函数为 private，这样该类就不会被实例化</span><br><span class="line">    private SingleObject()&#123;&#125;</span><br><span class="line">    //获取唯一可用的对象</span><br><span class="line">    public static SingleObject getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    public void showMessage()&#123;</span><br><span class="line">        System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SingletonPatternDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //不合法的构造函数</span><br><span class="line">        //编译时错误：构造函数 SingleObject() 是不可见的</span><br><span class="line">        //SingleObject object = new SingleObject();</span><br><span class="line">        //获取唯一可用的对象</span><br><span class="line">        SingleObject object = SingleObject.getInstance();            //显示消息</span><br><span class="line">        object.showMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过类中公有的静态方法调用该类的私有构造函数并返回该类从而达成只生成唯一可用对象的目的，并可通过该对象调用该类中的方法</p><h2 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h2><p>1.懒汉式，线程不安全</p><p><strong>是否lazy初始化</strong>：是</p><p><strong>是否多线程安全</strong>：否</p><p><strong>实现难度</strong>：易</p><p>描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁synchronized所以严格意义上它并不算单例模式</p><p>这种方式lazy loading很明显，不要求多线程安全，在多线程不能正常工作</p><p>实例</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance;//私有静态属性</span><br><span class="line">    private Singleton ()&#123;&#125;//私有构造方法</span><br><span class="line">    public static Singleton getInstance() &#123;//共有静态方法</span><br><span class="line">        if (instance == null) &#123;//如果没有就创建一个对象并返回</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;//返回现有对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.懒汉式，线程安全</p><p><strong>是否lazy初始化</strong>：是</p><p><strong>是否多线程安全</strong>：是</p><p><strong>实现难度</strong>：易</p><p>描述：这种方式具备很好的lazy loading，能够在多线程中很好的工作，但是效率很低，99%情况下不需要同步，优点，第一次调用才初始化，避免内存浪费，缺点，必须加锁synchronized才能保证单例，但是加锁会影响效率，getlnstance()的性能对应用程序不是很关键（该方法使用不太频繁）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance;//静态私有属性</span><br><span class="line">    private Singleton ()&#123;&#125;//私有构造方法</span><br><span class="line">    public static synchronized Singleton getInstance() &#123;//这一行的那个关键字我不懂</span><br><span class="line">        if (instance == null) &#123;//如果没有对象就创建一个并返回</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;//直接返回现有对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.饿汉式</p><p><strong>是否lazy初始化</strong>：否</p><p><strong>是否多线程安全</strong>：是</p><p><strong>实现难度</strong>：易</p><p>描述：这种方式比较常用，但容易产生垃圾对象。</p><p>优点：没有加锁，执行效率会提高。</p><p>缺点：类加载时就初始化，浪费内存</p><p>它基于class loader机制避免了多线程的同步问题，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式种大多时调用getlnstance方法，但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到lazy loading的效果</p><p>实例</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = new Singleton();//加载类是就进行初始化</span><br><span class="line">    private Singleton ()&#123;&#125;//私有构造方法</span><br><span class="line">    public static Singleton getInstance() &#123;静态共有方法，返回创建的对象</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…………………………………………这一段跟后面的一大段看不懂，不抄了，感觉够用了——目前</p><p>4.双检锁&#x2F;双重校验锁（DLC,即double-checked locking）</p><p><strong>JDK 版本：</strong>JDK1.5 起</p><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>较复杂</p><p><strong>描述：</strong>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance() 的性能对应用程序很关键。</p><p>………………………………………</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象工厂模式</title>
      <link href="/posts/56455.html"/>
      <url>/posts/56455.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式，是<strong>围绕一个超级工厂创建其他工厂</strong>，该超级工厂又称为其他工厂的工厂，属于创建型模式</p><p>在抽象工厂模式中，<strong>接口是负责创建一个相关对象的工厂</strong>，不需要显示指定他们的类，每个工厂都能按照工厂模式提供对象</p><p>个人理解：抽象工厂模式可以使用一个工厂创造器根据传递的信息创造出实现了超级工厂的子类工厂，子类工厂再根据传递的信息生成具体的类</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图</strong>：提供一个<strong>创建一系列相关或互相依赖对象的接口，而无需指定他们具体的类</strong></p><p><strong>主要解决</strong>：主要解决接口选择问题</p><p><strong>何时使用</strong>：在一个产品族里面，定义多个产品</p><p><strong>关键代码</strong>：在一个工厂里聚合多个同类产品</p><p><strong>优点</strong>：当一个产品族中的多个对象被设计成一起工作时，他能保证客户端始终只使用同一个产品族中的对象</p><p><strong>缺点</strong>：产品族扩展非常困难，要增加一个系列的某一产品时，既要在抽象的creator中加代码，又要在具体的类里加代码</p><p><img src="/posts/56455/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221220170600.jpg"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>1.为形状创建一个接口</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Shape &#123;</span><br><span class="line">    //为形状创建的接口</span><br><span class="line">    void draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.创建实现接口的实体类</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Circle implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;circle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Square implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;square&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Rectangle implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;retangle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.为颜色创建一个接口</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Color &#123;</span><br><span class="line">    public abstract void fill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.创建实现接口的实体类</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Blue implements Color&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fill() &#123;</span><br><span class="line">        System.out.println(&quot;blue&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Red implements Color &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void fill() &#123;</span><br><span class="line">        System.out.println(&quot;red&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Green implements Color&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void fill() &#123;</span><br><span class="line">        System.out.println(&quot;green&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.为两个颜色和对象创建抽象类来获取工厂</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractFactory &#123;</span><br><span class="line">//其实这里是否抽象无所谓，但是你不希望别人直接创建超级工厂吧，没意义对不对</span><br><span class="line">    //为Color和Shape对象创建抽象类来获取工厂</span><br><span class="line">    public abstract Color getColor(String color);</span><br><span class="line">    public abstract Shape getShape(String shape);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.创建抽象工厂类，急于给定信息生成实体类的对象</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ColorFactory extends AbstractFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Color getColor(String color) &#123;</span><br><span class="line">        if(color == null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if(color.equalsIgnoreCase(&quot;RED&quot;))&#123;</span><br><span class="line">            return new Red();</span><br><span class="line">        &#125; else if(color.equalsIgnoreCase(&quot;GREEN&quot;))&#123;</span><br><span class="line">            return new Green();</span><br><span class="line">        &#125; else if(color.equalsIgnoreCase(&quot;BLUE&quot;))&#123;</span><br><span class="line">            return new Blue();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Shape getShape(String shape) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ShpeFactory extends AbstractFactory&#123;</span><br><span class="line">    //创建扩展超级工厂类的工厂类，基于给定信息生成实体类的对象</span><br><span class="line">    @Override</span><br><span class="line">    public Color getColor(String color) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Shape getShape(String shape) &#123;</span><br><span class="line">        if(shape == null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;if(shape.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123;</span><br><span class="line">            return new Circle();</span><br><span class="line">        &#125; else if(shape.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123;</span><br><span class="line">            return new Rectangle();</span><br><span class="line">        &#125; else if(shape.equalsIgnoreCase(&quot;SQUARE&quot;))&#123;</span><br><span class="line">            return new Square();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.创建一个工厂创造器&#x2F;生成器类，通过传递形状或颜色信息来获取工厂</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FactoryProducer &#123;</span><br><span class="line">    //根据传递的信息去生产超级工厂的子类</span><br><span class="line">    public static AbstractFactory getFactory(String choice)&#123;</span><br><span class="line">        if(choice.equalsIgnoreCase(&quot;SHAPE&quot;))&#123;</span><br><span class="line">            return new ShpeFactory();</span><br><span class="line">        &#125; else if(choice.equalsIgnoreCase(&quot;COLOR&quot;))&#123;</span><br><span class="line">            return new ColorFactory();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8.使用工厂创造器来获取抽象工厂，通过传递类型信息来获取实体类的对象</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class text &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //获取形状工厂</span><br><span class="line">        AbstractFactory shapeFactory = FactoryProducer.getFactory(&quot;SHAPE&quot;);</span><br><span class="line">        //超级工厂类型可以接收所有实现他的子类，这里使用FactoryProducer，根据传递的信息返回实现了超级工厂的子类，用超级工厂接收由工厂制造器返回的子类工厂</span><br><span class="line">        //获取形状为 Circle 的对象</span><br><span class="line">        Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);</span><br><span class="line">//传递信息给子类工厂，获取相应对象</span><br><span class="line">        //调用 Circle 的 draw 方法</span><br><span class="line">        shape1.draw();</span><br><span class="line"></span><br><span class="line">        //获取形状为 Rectangle 的对象</span><br><span class="line">        Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);</span><br><span class="line"></span><br><span class="line">        //调用 Rectangle 的 draw 方法</span><br><span class="line">        shape2.draw();</span><br><span class="line"></span><br><span class="line">        //获取形状为 Square 的对象</span><br><span class="line">        Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);</span><br><span class="line"></span><br><span class="line">        //调用 Square 的 draw 方法</span><br><span class="line">        shape3.draw();</span><br><span class="line"></span><br><span class="line">        //获取颜色工厂</span><br><span class="line">        AbstractFactory colorFactory = FactoryProducer.getFactory(&quot;COLOR&quot;);</span><br><span class="line"></span><br><span class="line">        //获取颜色为 Red 的对象</span><br><span class="line">        Color color1 = colorFactory.getColor(&quot;RED&quot;);</span><br><span class="line"></span><br><span class="line">        //调用 Red 的 fill 方法</span><br><span class="line">        color1.fill();</span><br><span class="line"></span><br><span class="line">        //获取颜色为 Green 的对象</span><br><span class="line">        Color color2 = colorFactory.getColor(&quot;GREEN&quot;);</span><br><span class="line"></span><br><span class="line">        //调用 Green 的 fill 方法</span><br><span class="line">        color2.fill();</span><br><span class="line"></span><br><span class="line">        //获取颜色为 Blue 的对象</span><br><span class="line">        Color color3 = colorFactory.getColor(&quot;BLUE&quot;);</span><br><span class="line"></span><br><span class="line">        //调用 Blue 的 fill 方法</span><br><span class="line">        color3.fill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9.输出结果</p><p><img src="/posts/56455/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221220170447.jpg"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>光看还是不行，要自己实际操作才能掌握其中细节</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/posts/6013.html"/>
      <url>/posts/6013.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式，属于创建型模式，提供了一种创建对象的方式</p><p>在工厂模式中，我们在创建对象是不会对客户端暴露创建模式逻辑，并且通过<strong>使用一个共同接口来指向新创建的对象</strong></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图</strong>：定义一个创建对象的接口，<strong>让其子类自己决定实例化哪一个工厂类</strong>，工厂模式使其创建过程延迟到子类进行</p><p><strong>主要解决</strong>：接口的选择问题</p><p><strong>如何解决</strong>：让其子类实现工厂接口，返回的也是一个抽象的产品</p><p><strong>关键代码</strong>：创建过程在其子类执行</p><p><strong>优点</strong>：1.知道名字就可以创建对象2.扩展性高，向增加一个产品，只要增加一个工厂类就可以3.屏蔽产品的具体实现，调用者只关心产品的接口</p><p><strong>缺点</strong>：1.每次增加产品，都需要增加一个具体类和对象的实现工厂，使系统中的类成倍增加，一定程度上增加了系统的复杂度，同时也增加了系统对具体类的依赖</p><p><strong>注意事项</strong>：作为一种创建类的模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式，负载的对象适合使用工厂模式，而简单的对象只需要使用new即可，会增加系统的复杂度</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>将创建一个pizz接口，和实现pizz接口的实体类，下一步是定义工厂类pizzafactory ，text类使用该工厂来获取pizza对象，text将向工厂传递信息，以便获取它所需对象的类型</p><p><img src="/posts/6013/image-20221214144758004.png" alt="类图"></p><p>1.创建一个接口</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Pizza &#123;</span><br><span class="line">    public abstract void prepare();</span><br><span class="line">    public abstract void bake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.创建实现接口的实体类</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ChessePizza implements Pizza&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void prepare() &#123;</span><br><span class="line">        System.out.println(&quot;准备面饼\n准备奶酪&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void bake() &#123;</span><br><span class="line">        System.out.println(&quot;烤奶酪披萨\n20分钟后可以使用 奶酪披萨&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FruitPizza implements Pizza&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void prepare() &#123;</span><br><span class="line">        System.out.println(&quot;准备面饼\n准备水果&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void bake() &#123;</span><br><span class="line">        System.out.println(&quot;烤水果披萨\n20分钟后可以使用 水果披萨&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.创建一个工厂，生成基于给定信息的实体类的对象</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PizzaFactory &#123;</span><br><span class="line">    public Pizza creat(String type)&#123;</span><br><span class="line">        if(type.equals(&quot;水果披萨&quot;))&#123;</span><br><span class="line">            return new ChessePizza();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return new FruitPizza();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.使用该工厂，通过传递类型信息来获取实体类的对象</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PizzaFactory &#123;</span><br><span class="line">    public Pizza creat(String type)&#123;</span><br><span class="line">        if(type.equals(&quot;水果披萨&quot;))&#123;</span><br><span class="line">            return new ChessePizza();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return new FruitPizza();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子数组和</title>
      <link href="/posts/60313.html"/>
      <url>/posts/60313.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/posts/60313/20221219131354.jpg"></p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>施工中</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>施工中</p>]]></content>
      
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deemo</title>
      <link href="/posts/42771.html"/>
      <url>/posts/42771.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>top_img: <img src="/posts/42771/deemo.jpg"></p><h1 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h1><p><img src="/posts/42771/deemo.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java static 关键字</title>
      <link href="/posts/36808.html"/>
      <url>/posts/36808.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>static关键字</p><p>​写作业的时候出错了，原因是对static的理解有问题（或者说是根本没有理解），今天就来整理一下static的作用跟用法</p><p>​static作用，修饰类的成员变量，成员方法以及代码块，被修饰的成员被成为静态成员</p><p>​<strong>静态变量</strong>：<strong>使用static修饰的成员变量</strong>，成为静态变量或类变量，<strong>他被类的所有对象共享</strong>（类似全局变量，不被某个对象所独有，每个对象都可对其进行修改）</p><p>​<strong>静态方法</strong>：使用static修饰的在某个类中的方法可以被<strong>直接调用而不需要创建某个具体的对象</strong>（不需依附实例即可使用）。作用，不需要创建对象就可以使用的方法</p><p>​在静态方法中不能访问类的非静态成员变量和非静态类成员方法，但在非静态成员方法中是可以访问静态成员方法和变量</p><p>​<strong>静态代码块</strong>（优化程序性能）：代码块可分为普通代码块，构造代码块，和同步代码块（在多线程部分）执行的优先级高于非静态的初始代码块，他会在<strong>类的初始化时执行一次，执行完成便销毁</strong>，仅能初始化类变量，static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来依次执行每个static块，并且只会执行一次。无论类的对象被创建多少次，由于Java虚拟机只加载一次类，所以静态代码只会执行一次</p><p>我的误区：java中的变量不会影响到被修饰的东西的作用域，在Java中能影响访问权限的只有private，public，protect。虽然对于静态方法来说没有this，但是我们在非静态方法中能够通过this访问静态方法成员变量。</p><p>​this 关键字（指向调用对象本身）</p><p>​作用，解决成员变量和局部变量名称相同的问题</p><p>1.通过this关键字调用成员变量解决与局部变量名称冲突的问题</p><p>2.通过this关键字调用成员方法，方法用static修饰则不能用this（静态方法没有this，可随处调用，并不依附与某个对象）</p><p>3.this关键字调用的构造方法可以在一个构造方法中使用”this（[参数]，[参数],……）“的形式来调用构造方法S</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>为了让同学们能更加理解static关键字，特此更新</p><p>首先回忆，Java程序的内存划分</p><p>Java程序在执行的时候内存区被划分为</p><h4 id="Java内存划分"><a href="#Java内存划分" class="headerlink" title="Java内存划分"></a>Java内存划分</h4><p>1.本地方法栈<br>本地方法栈用于支持执行本地（Native）方法，即使用其他编程语言（如C、C++）编写的方法。它保存了本地方法的调用和执行信息，包括方法参数、局部变量以及调用本地方法所需的相关数据。本地方法栈与Java虚拟机栈（栈）是分开的，专门用于处理本地方法的调用。</p><p>2.<strong>Java虚拟机栈</strong>——方法调用和执行的内存区——联系递归</p><p>我们程序在执行的时候会首先将main方法加载进栈，如果有其他方法依次加载进栈，方法执行完毕后出栈，main方法出栈后，程序执行完毕</p><p>Java虚拟机栈也称为栈，用于支持Java方法的调用和执行。<strong>每个线程在执行过程中都会有一个对应的栈</strong>，<strong>栈中保存了方法调用的状态信息，包括局部变量、方法参数、返回值以及方法执行过程中的临时数据</strong>。栈的大小在程序启动时可以预先设置，当线程调用的方法层次过多时，栈可能会发生溢出。</p><p>3.<strong>方法区</strong></p><p>方法区是用于存储类的元数据、常量池、静态变量、字节码等信息的区域。它是所有线程共享的内存区域，用于存储加载的类的结构信息和运行时常量池。方法区在较早的Java版本中也被称为永久代（Permanent Generation），但在Java 8及以后的版本中被移除或替换为元空间（Metaspace）。</p><p>4.寄存器</p><p>寄存器是位于CPU内部的一小块高速存储器，用于存储指令执行过程中的临时数据。寄存器对于程序执行速度非常重要，它可以提供快速的数据访问和处理能力。在Java中，我们不能直接控制和访问寄存器，它是由JVM和CPU来管理和使用的。</p><p>5.<strong>堆</strong></p><p>堆是用于存储对象实例和动态分配的内存区域。在Java中，<strong>所有的对象都被分配在堆中</strong>。堆是一个<strong>动态分配的内存区域</strong>（所有通过new关键字创建的对象都储存在里面），用于存储创建的对象和数组。堆的管理由Java虚拟机负责，它提供了垃圾回收机制来自动释放不再使用的对象内存。</p><h4 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h4><p><img src="/posts/36808/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230523171523.png"></p><p>我们主要关注三个区域，一个是栈，程序主要的运行空间。方法区，我们编译好的class文件储存在这个地方。堆区，我们创建好的对象都在这里。在程序进行编译的时候，Java会自动帮我们把写好的代码转换成.class文件，加载进方法区中，这里比如说我写了一个学生类</p><p><img src="/posts/36808/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230523172049.png"></p><p>在程序进行编译时，Java会将我们编写的代码转换成 <code>.class</code> 文件并加载到方法区中。但此时我们无法直接使用该类，因为其中的属性尚未进行初始化（没有给他们分配内存）。只有通过使用 <code>new</code> 关键字创建对象并对其进行初始化后，我们才能访问对象的属性和方法。例如，对于学生类，我们只有在创建学生对象并为其属性赋值后，该学生才真正存在，我们才能调用其属性和方法。而被static修饰的属性或方法则在.class文件被加载进方法区的时候就已经被初始化完毕。</p><p><img src="/posts/36808/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230523173635.png"></p><p>比如在这里，给学生添加了一个静态属性”种族“ &#x3D; 人类 因为我们在.class文件加载进栈的时候就已经完成了初始化，所以我们在这里可以通过类名直接进行调用，而同样的，被static方法修饰的方法同样也会直接在方法区中被分配内存（给局部变量分配内存），所以我们也可以直接通过类名进行调用。且被static修饰的属性属于该类本身（种族为人类肯定是所有学生共有的，不可能有学生不是人吧），而不是类的对象（实例）中，在创建该类的对象时被static修饰的属性或方法不会被复制到每个对象的内存空间中，而是直接从方法区中获取所以说被static修饰的内容会被该类的所有成员所共有，无论创建多少个对象，他们都共享一个static属性值，（如果上面学生类中的种族属性被修改，那么所有学生的种族都会被修改）在初始化时，被静态修饰的属性不会被分配给每个对象。，它们在方法区内分配了一块独立的内存空间，供所有对象共享。所有对象在使用该属性或者方法的时候，都会访问那个空间无论创建多少个对象，它们都使用同一块静态属性的内存空间。</p><p>总结，被静态修饰符修饰的东西——1.无需创建对象便可通过类名直接调用（因为已经被初始化了），所以可以通过类名去直接访问他们 2. 被该类所创建的所有对象所共有，而不是类的每个对象所拥有的。它们在类加载时就被初始化，并在方法区内分配了空间。因此，所有通过该类创建的对象共享同一个静态属性的值，修改一个对象的静态属性会影响到其他对象。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
