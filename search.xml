<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>泛型</title>
      <link href="/posts/2053.html"/>
      <url>/posts/2053.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="泛型（generic）"><a href="#泛型（generic）" class="headerlink" title="泛型（generic）"></a>泛型（generic）</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>泛型是一种在编程中用于增强类型安全性和代码重用性的概念。它允许我们在类或方法的定义中使用一种或多种未知类型，这些未知类型在实际使用时可以由开发者指定具体的类型。</p><p><strong>作用</strong>：泛型可以让我们在编译时就检测出错误</p><p>泛型是使用一种称为类型消除的方法实现的，编译器使用类型信息来编译代码，但是随后会消除它，一旦编译器确定泛型类型是安全使用的，就会将它转为原始类型（Object）。如果一个泛型类型是受限的，那么编译器就会用该受限类型来替换它。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="定义泛型类"><a href="#定义泛型类" class="headerlink" title="定义泛型类"></a>定义泛型类</h3><p>指定与该类一起工作的类，如果不符合条件，编译器在编译阶段报错</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的&lt;T&gt;表示形式泛型类型（Formal generic type）,随后可以使用一个实际具体类型来替换他，替换泛型类型被称为泛型实例化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&lt;E&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟栈</span></span><br><span class="line"><span class="comment">// 可有多个参数，定义为&lt;E,T,U&gt;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;E&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意此处方法不为 Stack&lt;E&gt;()，虽然我们在下面这样使用它</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stack = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义泛型接口"><a href="#定义泛型接口" class="headerlink" title="定义泛型接口"></a>定义泛型接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java中的String 类被定义为实现Comparable接口，并与String类进行比较</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">CompareTo</span><span class="params">(E e)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;string&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">CompareTo</span><span class="params">(string string)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义泛型方法"><a href="#定义泛型方法" class="headerlink" title="定义泛型方法"></a>定义泛型方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义泛型方法打印一个对象数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] a = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">5</span>];</span><br><span class="line">        Character[] b = <span class="keyword">new</span> <span class="title class_">Character</span>[<span class="number">50</span>];</span><br><span class="line">        print(a);</span><br><span class="line">        print(b);</span><br><span class="line">        Main.&lt;Integer&gt;print(a);</span><br><span class="line">        Main.&lt;Character&gt;print(b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(T[] list)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">            System.out.println(list[i].toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="受限的泛型类型"><a href="#受限的泛型类型" class="headerlink" title="受限的泛型类型"></a>受限的泛型类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示 T 必须时Number或其子类</span></span><br><span class="line"><span class="comment">// 受限通配</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 表示 T 必须为Number或其父类</span></span><br><span class="line"><span class="comment">// 下限通配</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T <span class="built_in">super</span> Number&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非受限制泛型类 <E> 等于 <E extends object></E></E></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230731025643.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>泛型具有参数化类型的能力。可以定义使用泛型类型的类或方法，编译器会用到具体类型来替换泛型类型。</li><li>泛型的主要又是是能够在编译时而不是运行时检测错误</li><li>泛型或方法语序指定这个类或方法可以带有的对象类型如果试图使用带有不兼容对象的类或方法，编译器会检测出这个错误</li><li>定义在类，接口或静态方法中的泛型被称为形式泛型类型，随后可以用一个实际具体类型来替换它。替换泛型类型的过程被称为泛型实例化</li><li>不适用类型参数的泛型类型被称为原始类型，例如ArrayList。使用原始类型是为了向后兼容Java较早的版本</li><li>使用称为类型消除的方法来实现泛型。编译器使用泛型类型信息来编译代码，但是随后消除它。因此，泛型信息在运行时是不可用的</li><li>不能使用泛型类型参数来创建实例</li><li>不能使用泛型类型参数来创建数组</li><li>不能在静态环境中使用类的泛型类型参数</li><li>在异常类中不能使用泛型类型参数</li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GO基础进阶</title>
      <link href="/posts/34426.html"/>
      <url>/posts/34426.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="GO基础进阶"><a href="#GO基础进阶" class="headerlink" title="GO基础进阶"></a>GO基础进阶</h1><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><h3 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a>反射的作用</h3><p>反射机制提供了在运行时检查程序结构和变量类型的能力，使得程序能够以一种动态的方式处理类型信息。具体而言，反射的作用包括以下几个方面</p><ol><li>获取类型信息：通过反射，可以获取变量的类型信息，包括变量的底层类型，种类，字段信息，这对于某些情况下无法在编译时确定类型的情况非常有用</li><li>获取和修改变量的值：反射允许我们在运行时获取变量的值，并且可以修改变量的值。这为实现一些通用的操作提供了遍历，例如序列化和反序列化数据，根据变量的类型动态执行某些操作等。</li><li>动态调用函数：反射允许我们根据函数名称动态地调用函数。这在需要根据运行时条件选择执行不同函数的情况下很有用，或者在某些情况下我们只有函数名称的字符串，而不是函数类型。</li><li>创建新的对象和实例：通过反射，可以在运行时动态地创建新的对象或实例，而无需在编译时明确指定类型。</li><li>检查接口的类型和实现：反射可以用于检查一个类型的接口是否实现了某个接口，并且可以获取类型实现的方法信息</li></ol><h3 id="为什么要使用反射和不使用的理由"><a href="#为什么要使用反射和不使用的理由" class="headerlink" title="为什么要使用反射和不使用的理由"></a>为什么要使用反射和不使用的理由</h3><p><strong>为什么要使用反射</strong></p><ol><li>有时你需要编写一个函数，但是并不知道传给你的参数类型是什么，可能是没约定好；也可能是传入的类型很多，这些类型并不能统一表示。</li><li>有时候需要根据某些条件决定调用哪个函数，比如根据用户的输入来决定，这时就需要对函数和函数的参数进行反射，在运行期间动态的执行函数</li></ol><p><strong>为什么不使用反射</strong></p><ol><li>与反射相关的代码，难以阅读</li><li>GO语言作为一门静态语言，编码过程中，不能发现反射代码的错误</li><li>反射对于性能的影响比较大</li></ol><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><p>认识反射</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num <span class="type">int</span> = <span class="number">42</span></span><br><span class="line">    <span class="comment">// 使用reflect.TypeOf()函数可以获取任意变量的类型信息。</span></span><br><span class="line">    fmt.Println(reflect.TypeOF(num))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用reflect.ValueOf()函数可以获取变量的值。</span></span><br><span class="line">    fmt.Println(reflect.ValueOf(num))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用反射修改变量的值</span></span><br><span class="line">     v := reflect.ValueOf(&amp;num) <span class="comment">// 需要传递指针才能修改变量</span></span><br><span class="line">    <span class="keyword">if</span> v.Elem().CanSet() &#123;</span><br><span class="line">        v.Elem().SetInt(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(num) <span class="comment">// 输出：100</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态调用函数</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHello</span><span class="params">(name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hello, %s!\n&quot;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    funcValue := reflect.ValueOf(SayHello)</span><br><span class="line">    args := []reflect.Value&#123;reflect.ValueOf(<span class="string">&quot;Alice&quot;</span>)&#125;</span><br><span class="line">    funcValue.Call(args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>获取结构体字段名，字段类型等信息</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;Name: <span class="string">&quot;John&quot;</span>, Age: <span class="number">30</span>&#125;</span><br><span class="line">    v := reflect.ValueOf(p)</span><br><span class="line">    t := v.Type()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class="line">        field := v.Field(i)</span><br><span class="line">        fieldName := t.Field(i).Name</span><br><span class="line">        fieldType := t.Field(i).Type</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s: %v (Type: %v)\n&quot;</span>, fieldName, field, fieldType)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GO文档学习</title>
      <link href="/posts/42594.html"/>
      <url>/posts/42594.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="GO文档学习"><a href="#GO文档学习" class="headerlink" title="GO文档学习"></a>GO文档学习</h1><h2 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h2><p>fmt包实现了类似C语言的printf和scanf的格式化I&#x2F;O。主要分为向外输出内容和获取输入内容</p><p>向外输出</p><ul><li><p>Print</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><ol><li><p>Print函数直接输出内容</p></li><li><p>Printf函数支持格式化输出字符串</p></li><li><p>Println函数会在输出内容的结尾添加一个换行符</p></li></ol></li><li><p>Fprint</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprint</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintln</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>Fprint系列函数会将内容输出到一个io.Writer接口类型的变量w中，我们通常用这个函数往文件中写入内容。</p></li><li><p>Sprint系列函数会把传入的数据生成并返回一个字符串。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprint</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintf</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintln</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure></li><li><p>Errorf</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Errorf</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure><p>Errorf函数根据format参数生成格式化字符串并返回一个包含该字符串的错误。</p></li></ul><p><strong>PS</strong>:</p><p><code>a ...interface&#123;&#125;</code> 是 Go 语言中的一个变参（Variadic）参数，用于接收任意数量的参数。这种参数允许你在函数调用时传入可变数量的参数，而不限制参数的个数。在函数内部，你可以像操作切片一样处理这个变参参数。</p><p>在声明函数时，使用 <code>...</code> 表示参数是变参的，而 <code>interface&#123;&#125;</code> 表示这个变参可以接收任意类型的参数。<code>interface&#123;&#125;</code> 是 Go 语言的空接口类型，它可以表示任意类型的值。</p><p>获取输入</p><ul><li><p>Scan</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scan</span><span class="params">(a...<span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;n <span class="type">int</span>, err <span class="type">error</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>Scan从标准输入扫描文本，读取由空白符分隔的值保存到传递给本函数的参数中，换行符视为空白符。</li><li>本函数返回成功扫描的数据个数和遇到的任何错误。如果读取的数据个数比提供的参数少，会返回一个错误报告原因。</li></ul></li><li><p>Scanf</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scanf</span><span class="params">(format <span class="type">string</span>, a...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><ul><li>Scanf从标准输入扫描文本，根据format参数指定的格式去读取由空白符分隔的值保存到传递给本函数的参数中。</li><li>本函数返回成功扫描的数据个数和遇到的任何错误。</li></ul></li><li><p>Scanln</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scanln</span><span class="params">(a...<span class="keyword">interface</span>&#123;&#125;)</span></span>(n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><ul><li>Scanln类似Scan，它在遇到换行时才停止扫描。最后一个数据后面必须有换行或者到达结束位置。</li><li>本函数返回成功扫描的数据个数和遇到的任何错误。</li></ul></li><li><p>Fscan</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscan</span><span class="params">(r io.Reader, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscanln</span><span class="params">(r io.Reader, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscanf</span><span class="params">(r io.Reader, format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>这几个函数功能分别类似于fmt.Scan、fmt.Scanf、fmt.Scanln三个函数，只不过它们不是从标准输入中读取数据而是从io.Reader中读取数据。</p></li><li><p>Sscan</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscan</span><span class="params">(str <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscanln</span><span class="params">(str <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscanf</span><span class="params">(str <span class="type">string</span>, format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>这几个函数功能分别类似于fmt.Scan、fmt.Scanf、fmt.Scanln三个函数，只不过它们不是从标准输入中读取数据而是从指定字符串中读取数据。</p></li></ul><h2 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h2><p><strong>时间类型</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    now := time.Now() <span class="comment">//获取当前时间</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;current time:%v\n&quot;</span>, now)</span><br><span class="line"></span><br><span class="line">    year := now.Year()     <span class="comment">//年</span></span><br><span class="line">    month := now.Month()   <span class="comment">//月</span></span><br><span class="line">    day := now.Day()       <span class="comment">//日</span></span><br><span class="line">    hour := now.Hour()     <span class="comment">//小时</span></span><br><span class="line">    minute := now.Minute() <span class="comment">//分钟</span></span><br><span class="line">    second := now.Second() <span class="comment">//秒</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d\n&quot;</span>, year, month, day, hour, minute, second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间戳</strong></p><p>时间戳是自1970年1月1日（08:00:00GMT）至当前时间的总毫秒数。它也被称为Unix时间戳（UnixTimestamp）。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timestampDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    now := time.Now()            <span class="comment">//获取当前时间</span></span><br><span class="line">    timestamp1 := now.Unix()     <span class="comment">//时间戳</span></span><br><span class="line">    timestamp2 := now.UnixNano() <span class="comment">//纳秒时间戳</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;current timestamp1:%v\n&quot;</span>, timestamp1)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;current timestamp2:%v\n&quot;</span>, timestamp2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将时间戳转换成具体时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timestampDemo2</span><span class="params">(timestamp <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    timeObj := time.Unix(timestamp, <span class="number">0</span>) <span class="comment">//将时间戳转为时间格式</span></span><br><span class="line">    fmt.Println(timeObj)</span><br><span class="line">    year := timeObj.Year()     <span class="comment">//年</span></span><br><span class="line">    month := timeObj.Month()   <span class="comment">//月</span></span><br><span class="line">    day := timeObj.Day()       <span class="comment">//日</span></span><br><span class="line">    hour := timeObj.Hour()     <span class="comment">//小时</span></span><br><span class="line">    minute := timeObj.Minute() <span class="comment">//分钟</span></span><br><span class="line">    second := timeObj.Second() <span class="comment">//秒</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d\n&quot;</span>, year, month, day, hour, minute, second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间操作</strong></p><ul><li><p>Add：两个时间相加</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Add(d Duration) Time</span><br></pre></td></tr></table></figure></li><li><p>Sub：两个时间相减</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Sub(u Time) Duration</span><br></pre></td></tr></table></figure></li><li><p>Equal：两个时间是否相同</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Equal(u Time) <span class="type">bool</span></span><br></pre></td></tr></table></figure></li><li><p>Before, After：A是否在B  之前&#x2F;之后</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Before(u Time) <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> After(u Time) <span class="type">bool</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>定时器</strong></p><p>使用time.Tick(时间间隔)来设置定时器，定时器的本质上是一个通道（channel）。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tickDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ticker := time.Tick(time.Second) <span class="comment">//定义一个1秒间隔的定时器</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> ticker &#123;</span><br><span class="line">        fmt.Println(i)<span class="comment">//每秒都会执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间格式化</strong></p><p>时间类型有一个自带的方法Format进行格式化，需要注意的是Go语言中格式化时间模板不是常见的Y-m-d H:M:S而是使用Go的诞生时间2006年1月2号15点04分（记忆口诀为2006 1 2 3 4）。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    now := time.Now()</span><br><span class="line">    <span class="comment">// 格式化的模板为Go的出生时间2006年1月2号15点04分 Mon Jan</span></span><br><span class="line">    <span class="comment">// 24小时制</span></span><br><span class="line">    fmt.Println(now.Format(<span class="string">&quot;2006-01-02 15:04:05.000 Mon Jan&quot;</span>))</span><br><span class="line">    <span class="comment">// 12小时制</span></span><br><span class="line">    fmt.Println(now.Format(<span class="string">&quot;2006-01-02 03:04:05.000 PM Mon Jan&quot;</span>))</span><br><span class="line">    fmt.Println(now.Format(<span class="string">&quot;2006/01/02 15:04&quot;</span>))</span><br><span class="line">    fmt.Println(now.Format(<span class="string">&quot;15:04 2006/01/02&quot;</span>))</span><br><span class="line">    fmt.Println(now.Format(<span class="string">&quot;2006/01/02&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析字符串格式的时间</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line"><span class="comment">// 加载时区</span></span><br><span class="line">loc, err := time.LoadLocation(<span class="string">&quot;Asia/Shanghai&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照指定时区和指定格式解析字符串时间</span></span><br><span class="line">timeObj, err := time.ParseInLocation(<span class="string">&quot;2006/01/02 15:04:05&quot;</span>, <span class="string">&quot;2019/08/04 14:15:20&quot;</span>, loc)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(timeObj)</span><br><span class="line">fmt.Println(timeObj.Sub(now))</span><br></pre></td></tr></table></figure><h2 id="net-x2F-Http"><a href="#net-x2F-Http" class="headerlink" title="net&#x2F;Http"></a>net&#x2F;Http</h2><p>提供了实现HTTP客户端和服务器的功能，net&#x2F;http库具有简单易用的API和灵活的设计，能够快速搭建Web应用程序和处理HTTP请求。</p><p><strong>Http客户端</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GO基础</title>
      <link href="/posts/9364.html"/>
      <url>/posts/9364.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="GO基础"><a href="#GO基础" class="headerlink" title="GO基础"></a>GO基础</h1><h2 id="变量的声明和初始化"><a href="#变量的声明和初始化" class="headerlink" title="变量的声明和初始化"></a>变量的声明和初始化</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;initial&quot;</span></span><br><span class="line"><span class="keyword">var</span> b, c <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> e <span class="type">float64</span></span><br><span class="line">e = <span class="number">5.0</span></span><br><span class="line"></span><br><span class="line">f := <span class="type">float64</span>(<span class="number">5.0004</span>)</span><br><span class="line">g := a + <span class="string">&quot;foo&quot;</span></span><br><span class="line">fmt.Println(a, b, c, d, e, f, g)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s <span class="type">string</span> = <span class="string">&quot;aaaa&quot;</span></span><br><span class="line"><span class="keyword">const</span> h = <span class="number">50000</span></span><br><span class="line"><span class="keyword">const</span> i = <span class="number">3e20</span> / h</span><br><span class="line">fmt.Println(s, h, i, math.Sin(h), math.Abs(i))</span><br></pre></td></tr></table></figure><p><strong>变量声明格式</strong></p><p>在函数内声明的变量就是局部变量，在函数外声明的变量就是全局变量</p><p>局部变量遵循就近原则</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ange <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> isStudent <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> x, y, z <span class="type">int</span></span><br></pre></td></tr></table></figure><p><strong>赋值操作</strong></p><ul><li>:&#x3D; ：（短变量声明）<ol><li>只能在函数内部使用，不能由于全局变量的声明</li><li>在使用:&#x3D;声明变量是，GO会根据右侧的表达式自动推断变量类型</li><li>如果变量已经在同一代码块中声明过，则不能使用（只能在第一次的时候使用）</li></ol></li><li>&#x3D; ：普通赋值符号</li></ul><p><strong>变量交换</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span> = <span class="number">20</span></span><br><span class="line">a, b = b, a</span><br><span class="line">fmt.Println(a,b)</span><br></pre></td></tr></table></figure><h2 id="流程语句"><a href="#流程语句" class="headerlink" title="流程语句"></a>流程语句</h2><p>GO中的分支与C和Java非常相似，唯一的不同就是没有小括号，并且在switch语句中，默认每个选项最后自带break</p><p><strong>if - else</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> pwd <span class="type">int</span> = <span class="number">20230715</span></span><br><span class="line">fmt.Scan(&amp;a) </span><br><span class="line"><span class="keyword">if</span> a == pwd &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;YES&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;NO&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>goto</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    LOOP:<span class="keyword">for</span> a &lt; <span class="number">20</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">15</span>) &#123;</span><br><span class="line">            a = a + <span class="number">1</span></span><br><span class="line">            <span class="keyword">goto</span> LOOP</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(a)</span><br><span class="line">        a++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>循环</strong></p><p>跟if - else 一样没有小括号</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 循环<span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123; <span class="comment">// 什么都不写就是一个死循环</span></span><br><span class="line">fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="number">5</span>; n++ &#123;</span><br><span class="line"><span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">3</span> &#123;</span><br><span class="line">i = i + <span class="number">1</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h3><p>GO中的函数也算是一种类型可以作为参数传递</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">形式</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionName</span><span class="params">(value)</span></span>(returnType) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">可以有多个形参和，多个返回值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(a, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    sum := a + b</span><br><span class="line">    difference := a - b</span><br><span class="line">    <span class="keyword">return</span> sum, difference</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">//调⽤函数</span></span><br><span class="line">getSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">89</span>, <span class="number">6</span>, <span class="number">5</span>) <span class="comment">// 函数名加括号(括号⾥⾯是实际参数)进⾏</span></span><br><span class="line">调⽤</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义⼀个 有参数⽆返回值的函数 </span></span><br><span class="line"><span class="comment">//函数名后⾯就是形式参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(num ...<span class="type">int</span>)</span></span> &#123; </span><br><span class="line"> <span class="comment">//三点代表的就是可变参数 可以传⼊多个数值</span></span><br><span class="line"> <span class="comment">//注意： 可变参数必须要放在参数列表的最后且⼀个函数只有⼀个可变参数！！</span></span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(num); i++ &#123;</span><br><span class="line">fmt.Println(num[i])</span><br><span class="line">sum += num[i]</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>匿名函数</strong></p><p>也称闭包，匿名函数可以在定义之后立刻调用，或者将其作为值传递给其他函数</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例：定义一个匿名函数并立即执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;This is an anonymous function.&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 末尾的小括号表示立刻执行此函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例：将匿名函数赋值给变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;This is another anonymous function.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    myFunc() <span class="comment">// 调用匿名函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例：带有返回值和形参的匿名函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    add := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result := add(<span class="number">10</span>, <span class="number">5</span>) <span class="comment">// 调用匿名函数，并将返回值赋给 result，result 的值为 15</span></span><br><span class="line">    fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>defer</strong></p><p>在函数的前面加上defer这个程序会在程序最后执行，但是该函数传入的参数是当时传入的参数（怀疑跟并发有关）</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">&quot;start :a&quot;</span>, a)</span><br><span class="line"><span class="keyword">defer</span> num2(a) <span class="comment">//这⾥是先调，⽤后执⾏ 程序⾛到这⾥时a已经传到⾥⾯了</span></span><br><span class="line">a++</span><br><span class="line">fmt.Println(<span class="string">&quot;end: a&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">num2</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;函数中的： a&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h3><p><strong>本质</strong></p><p>函数本身就是一种数据类型，如果函数名加括号就代表调用这个函数，如果不加，就表示这是一个变量</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, function)</span><br><span class="line">    <span class="keyword">var</span> function(a, b <span class="type">int</span>)</span><br><span class="line">    f = function</span><br><span class="line">    f(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匿名函数</strong></p><p>定义一个匿名函数，直接调用，通常只能使用一次，也可以使用匿名函数赋值给某个函数变量，就可以调用多次</p><p>作用</p><ul><li><p>将匿名函数作为另一个函数的参数，回调函数，在把一个函数作为另一个函数的参数的时候，接收函数变量的函数为高价函数，作为参数的则为回调函数</p></li><li><p>将匿名函数作为另一个函数的返回值，可以形成闭包结构</p><p>闭包就是，在一个外层函数中，有内层函数，<strong>内层函数会操纵外层函数的局部变量</strong>，并且该<strong>外层函数的返回值就是这个内层函数</strong>。这个内层函数和外层函数的局部变量，则统称为闭包结构，且局部变量的生命周期会发生改变，正常局部变量会随着函数的调用而创建，随着函数的结束而销毁，但是<strong>闭包结构中的外层函数的局部变量并不会随着外层函数的结束而销毁</strong>，因为内层函数还要继续使用</p></li></ul><p><strong>回调函数的使用案例</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示定义回调函数，相当于定义一个新类型</span></span><br><span class="line"><span class="keyword">type</span> Callback <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收一个函数作为回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(a, b <span class="type">int</span>, callback Callback)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> callback(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    add := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    result := calculate(<span class="number">10</span>, <span class="number">5</span>, add)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Result:&quot;</span>,result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不显示定义的话</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(a, b <span class="type">int</span>, callback <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> callback(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">add := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result := calculate(<span class="number">10</span>, <span class="number">5</span>, add)</span><br><span class="line">fmt.Println(<span class="string">&quot;Result:&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>闭包的作用和使用场景</strong></p><ol><li>封装状态：闭包允许我们创建一个函数，该函数可以持有并访问其创建时所在的上下文状态（局部变量）。这样可以实现一种类似对象的封装方式，将状态信息隐藏在闭包中，从而创建私有变量并暴露一组公共函数来操作这些变量。可以用于模拟面向对象的编程模式</li><li>保存状态：闭包能够在函数调用之间保留状态。当一个函数被多次调用时，它可以保持其内部的状态不变</li><li>回调函数：闭包常常被作为回调函数，这是一种常见的模式。通过将函数传递给其他函数，我们可以将某些逻辑封装到闭包中，并在需要的时候进行回调。</li><li>函数工厂：闭包可以用于创建函数工厂</li><li>避免全局变量：闭包可以减少对全局变量的使用</li></ol><p><strong>闭包的使用案例</strong></p><ol><li><p>封装状态</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createCounter</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    count := <span class="number">0</span> <span class="comment">// 这个变量会被闭包函数捕获</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回一个闭包函数，该函数访问并修改了外部作用域中的 count 变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        count++</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个计数器闭包函数</span></span><br><span class="line">    counter := createrCounter()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 多次调用闭包函数，它会保持状态</span></span><br><span class="line">fmt.Println(counter()) <span class="comment">// 输出：1</span></span><br><span class="line">fmt.Println(counter()) <span class="comment">// 输出：2</span></span><br><span class="line">fmt.Println(counter()) <span class="comment">// 输出：3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>回调函数</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Callback <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callCallback</span><span class="params">(callback Callback)</span></span> &#123;</span><br><span class="line">    fm.Println(<span class="string">&quot;Calling callback fucntion&quot;</span>)</span><br><span class="line">    callback(<span class="number">42</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    printNumber := <span class="function"><span class="keyword">func</span><span class="params">(num <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(nul)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    callCallback(printNumber)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数工厂</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createAdder</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    add := createAdder(<span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">    result := add(<span class="number">5</span>)</span><br><span class="line">    fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>避免全局变量</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        message := <span class="string">&quot;aaa&quot;</span></span><br><span class="line">        printMessage := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(message)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        printMessage()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// message 此处不可见，避免了全局变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>创建和初始化</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接声明</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接声明并初始化</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="type">int</span> = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">//使用短语法声明并初始化数组</span></span><br><span class="line">arr := [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动推导数组长度</span></span><br><span class="line">arr := [...]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用索引列表初始化</span></span><br><span class="line">arr := [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="number">1</span>:<span class="string">&quot;aaa&quot;</span>, <span class="number">2</span>:<span class="string">&quot;bbb&quot;</span>&#125; </span><br></pre></td></tr></table></figure><p><strong>一些操作</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过下标获得值</span></span><br><span class="line">fmt.Println(nums[<span class="number">0</span>])</span><br><span class="line"><span class="comment">// 得到数组类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T&quot;</span>, nums)</span><br><span class="line"><span class="comment">// 修改元素值</span></span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">100</span> </span><br><span class="line"><span class="comment">// 获取数组长度</span></span><br><span class="line"><span class="built_in">len</span>(nums)</span><br><span class="line"><span class="comment">// 获取数组容量</span></span><br><span class="line"><span class="built_in">cap</span>(nums)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的遍历</span></span><br><span class="line">nums := [...]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    fmt.Println(nums[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>细节</strong></p><p>GO中的数组是值类型，Java中的数组是引用类型，Java中如果将一个数组赋值给另一个数组，则因为这两个引用相同，所以共享同样的底层数据，但是GO在将一个数组赋值给另一个数组，或者将数组作为函数参数传递的时候，会进行数组的拷贝，而不是共享底层的数据</p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片是一个动态数组，是对数组的一个引用，能够动态调整长度</p><p><strong>定义和初始化</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用make函数创建一个切片，并将其赋值给一个已声明的切片变量，make函数的第一个变量为切片类型，第二个参数是切片的长度</span></span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line"><span class="comment">// 使用短语法声明和初始化一个切片变量，这种方式切片的类型不需要显示指定</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">type</span>,<span class="built_in">len</span>)</span><br><span class="line"><span class="comment">// 切片函数的完整形式，第一个参数是切片类型，第二个参数是切片长度，第三个参数是切片容量，切片容量用于预分配切片的内部数组大小，可以提高切片操作的性能</span></span><br><span class="line"><span class="built_in">make</span>([]T, length, capacity)</span><br></pre></td></tr></table></figure><p>在使用make函数初始化切片的时候，切片会被分配内存，且切片的元素会被初始化为元素类型的零值，如果不写第三个参数那么切片容量将与长度相同</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">s :=[] <span class="type">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125; <span class="comment">// 括号内什么都没有就是切片</span></span><br><span class="line">s := arr[startIndex:endIndex] <span class="comment">//根据数组（也可以是切片或字符串）创建一个切片，左闭右开</span></span><br><span class="line">s := arr[startIndex:]</span><br><span class="line">s := arr[:endIndex]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>常用操作</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// 添加元素 </span></span><br><span class="line">s = <span class="built_in">append</span>(s,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="comment">// 获取单个元素并打印</span></span><br><span class="line">fmt.Println(s[<span class="number">0</span>])</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">    fmt.Println(s[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>切片的扩容</strong></p><p>append函数会改变切片所引用的数组的内容从而影响到引用同一数组的其他切片，但是当切片中没有剩余空间的时候，此时将动态分配新的数组空间，返回的切片数组指针将指向这个空间，而原数组的内容将保持不变，其他引用此数组的切片则不受影响</p><ol><li>当使用<code>append</code>函数向<code>slice1</code>添加元素时，如果原数组容量足够（没有超过底层数组的长度），则会直接在底层数组的末尾添加新元素，并返回一个指向原底层数组的新切片。这时，原数组的内容会发生改变，并且其他引用同一底层数组的切片（如<code>slice2</code>）也会看到这个改变。</li><li>如果原数组的容量不足，即原切片的长度等于其底层数组的长度，<code>append</code>函数会动态地为切片分配新的底层数组，并将原来的数据复制到新的底层数组中。此时，<code>append</code>函数返回一个指向新底层数组的切片，并且原底层数组的内容保持不变。这意味着原切片和其他引用同一底层数组的切片（如<code>slice2</code>）不会受到影响，它们仍然引用原来的底层数组，而<code>slice1</code>引用的是新的底层数组。</li></ol><p><strong>append() 和copy() 函数</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Pintf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numbers []<span class="type">int</span></span><br><span class="line">printSlice(numbers)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 允许追加空切片 */</span></span><br><span class="line">numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)\</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建切片 a 是之前切片的两倍容量 */</span></span><br><span class="line">a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(numbers), <span class="built_in">cap</span>(numbers)*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 拷贝 numbers 的内容到a */</span></span><br><span class="line"><span class="built_in">copy</span>(numbers, a)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在一个切片中添加另一个切片 */</span></span><br><span class="line">s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">s2 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">s3 = <span class="built_in">append</span>(s1, s2...) <span class="comment">//使⽤...可以将切⽚中的数据解出来</span></span><br><span class="line">fmt.Println(s4)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>深浅拷贝</strong></p><ul><li><p>浅拷贝（Shallow Copy）</p><p>浅拷贝是指对数据的顶层进行拷贝，对于引用类型的数据如（切片，映射，和指针），智慧复制引用而不会复制引用指向的数据。这意味着新的数据结构和原始数据结构仍然共享同一块内存，修改其中一个数据结构的值可能会影响另一个数据结构</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">s1 = s</span><br><span class="line">s1[<span class="number">0</span>] = <span class="number">100</span></span><br></pre></td></tr></table></figure></li><li><p>深拷贝（Deep Copy）</p><p>深拷贝是指对数据结构及其引用的所有层级进行拷贝，完全复制数据结构中的每一个元素和引用指向的数据。可以获得两个完全独立的数据结构，在GO中，需要自己实现深拷贝，因为GO标准库中没有直接提供深拷贝函数。可以使用JSON编码和解码的方式实现简单的深拷贝，但对于复杂的数据结构，需要使用其他方法</p></li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现切⽚深拷⻉ 深拷⻉：类似于值类型 浅拷⻉：类似于引⽤类型</span></span><br><span class="line">arr1 := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">arr2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">fmt.Println(arr1)</span><br><span class="line">fmt.Println(arr2)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr1); i++ &#123;</span><br><span class="line">arr2 = <span class="built_in">append</span>(arr2, arr1[i])</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(arr1)</span><br><span class="line">fmt.Println(arr2)</span><br><span class="line">arr1[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(arr1) <span class="comment">//[100 2 3 4]</span></span><br><span class="line">fmt.Println(arr2) <span class="comment">//[1 2 3 4]</span></span><br><span class="line"><span class="comment">//copy 简易实现切⽚的深拷⻉ 切⽚没有数组⼤⼩</span></span><br><span class="line">arr3 := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="built_in">copy</span>(arr2, arr3)</span><br><span class="line"><span class="comment">//将arr3赋值给arr2后 由于arr3只有三个数 所以也就只改变arr2中前三个数</span></span><br><span class="line">fmt.Println(arr2) <span class="comment">//[2 3 4 4]</span></span><br><span class="line">fmt.Println(arr3) <span class="comment">//[2 3 4]</span></span><br></pre></td></tr></table></figure><h2 id="集合（Map）-key-value"><a href="#集合（Map）-key-value" class="headerlink" title="集合（Map）[key, value]"></a>集合（Map）[key, value]</h2><p>Map是使用 hash 实现的一种数据结构，无序，是引用类型，使用的时候需要注意</p><ul><li>map 是无序的，不能通过下标获取元素，只能通过键获取</li><li>map 长度是不固定的，和切片一样，是一种引用类型</li><li>内置的len函数同样适用于 map, 返回map 拥有的key数量</li><li>map 的key可以是所有可比较的类型，如布尔，整数，浮点，复杂，字符串</li></ul><p><strong>初始化</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明形式</span></span><br><span class="line"><span class="keyword">var</span> mapName <span class="keyword">map</span>[KeyType]valueType</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个变量但没有初始化 默认值为 nil 一个特殊0值</span></span><br><span class="line"><span class="keyword">var</span> map1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span></span><br><span class="line"><span class="comment">// 使用make函数进行初始化 分配底层hash表</span></span><br><span class="line">map1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span><br><span class="line"><span class="comment">// 创建并赋值</span></span><br><span class="line"><span class="keyword">map</span> := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>,<span class="string">&quot;b&quot;</span>:<span class="number">1</span>,<span class="string">&quot;c&quot;</span>:<span class="number">1</span>&#125;</span><br><span class="line">maps := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float32</span>&#123;&#125;<span class="comment">// 已被分配内存，可正常操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在使用var关键字声明映射时，只是进行了变量的声明，并没有对其进行初始化，因此，需要在后续代码中使用make函数对映射进行初始化，才使用映射并进行插入键值对等操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>常用操作</strong></p><p>delete(map,key)函数用于删除集合元素，参数为 map 和它对应的 key 删除函数不返回任何值</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// delete(map,key)函数用于删除集合元素，参数为 map 和它对应的 key 删除函数不返回任何值</span></span><br><span class="line"><span class="built_in">delete</span>(map1, <span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取其中一个元素</span></span><br><span class="line"><span class="comment">//逗号前⾯的是值，后⾯的是boolean类型的true/false</span></span><br><span class="line"><span class="comment">//这个叫做 ok-idiom 它可以⽤来判断key value是否存在</span></span><br><span class="line">value, ok := map1[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;存在&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;不存在&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改数据，如果key存在就是修改，不存在就是新增</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">2</span>] = <span class="string">&quot;aaa&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针是储存另一个变量的内存地址的变量 </p><p>简单回忆（&amp;取址符， * 取值符）</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span>= <span class="number">20</span> <span class="comment">/* 声明实际变量 */</span></span><br><span class="line"><span class="keyword">var</span> ip *<span class="type">int</span> <span class="comment">/* 声明指针变量 */</span></span><br><span class="line"></span><br><span class="line">ip = &amp;a <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;a 变量的地址是: %x\n&quot;</span>, &amp;a )</span><br><span class="line"><span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;ip 变量的存储地址: %x\n&quot;</span>, ip )</span><br><span class="line"><span class="comment">/* 使⽤指针访问值 * 用于火炮去指针变量所指向的值，获取实际数据 */</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;*ip 变量的值: %d\n&quot;</span>, *ip )</span><br></pre></td></tr></table></figure><p><strong>指针的嵌套使用</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组指针</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">var</span> p1 *[<span class="number">4</span>]<span class="type">int</span></span><br><span class="line">p1 = &amp;arr1</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;p1 的地址：%p\n&quot;</span>, p1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;p1 ⾃⼰的地址：%p\n&quot;</span>, &amp;p1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;p1 所指向的地址的值：%p\n&quot;</span>, *p1)</span><br><span class="line"></span><br><span class="line">(*p1)[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(arr1)</span><br><span class="line">fmt.Println(*p1)</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化写法 因为p1是⼀个指针⼜是⼀个数组就可以这么写</span></span><br><span class="line">p1[<span class="number">0</span>] = <span class="number">200</span></span><br><span class="line">fmt.Println(arr1)</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针数组</span></span><br><span class="line">a := <span class="number">1</span></span><br><span class="line">b := <span class="number">2</span></span><br><span class="line">c := <span class="number">3</span></span><br><span class="line">d := <span class="number">4</span></span><br><span class="line"></span><br><span class="line">arr2 := [<span class="number">4</span>]*<span class="type">int</span>&#123;&amp;a, &amp;b, &amp;c, &amp;d&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(arr2)</span><br><span class="line"></span><br><span class="line">*arr2[<span class="number">0</span>] = <span class="number">500</span> <span class="comment">//这⾥取出的是数组中下标是0的值</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"></span><br><span class="line">a = <span class="number">200</span></span><br><span class="line">fmt.Println(*arr2[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针数组</span></span><br><span class="line">a := <span class="number">1</span></span><br><span class="line">b := <span class="number">2</span></span><br><span class="line">c := <span class="number">3</span></span><br><span class="line">d := <span class="number">4</span></span><br><span class="line"></span><br><span class="line">arr2 := [<span class="number">4</span>]*<span class="type">int</span>&#123;&amp;a, &amp;b, &amp;c, &amp;d&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(arr2)</span><br><span class="line"></span><br><span class="line">*arr2[<span class="number">0</span>] = <span class="number">500</span> <span class="comment">//这⾥取出的是数组中下标是0的值</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"></span><br><span class="line">a = <span class="number">200</span></span><br><span class="line">fmt.Println(*arr2[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p><strong>指针函数 &amp; 指针作为参数</strong></p><p>指针函数：返回的是一个指针</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ptr := f1()</span><br><span class="line">fmt.Printf(<span class="string">&quot;ptr类型：%T\n&quot;</span>, ptr)</span><br><span class="line">fmt.Println(&amp;ptr) <span class="comment">//⾃⼰的地址</span></span><br><span class="line">fmt.Println(*ptr) <span class="comment">//指向的数值</span></span><br><span class="line"><span class="comment">//可以通过指针去修改⼀个变量的值⼜不会开辟⼀块新的内存空间</span></span><br><span class="line">a := <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">&quot;a=&quot;</span>, a)</span><br><span class="line">f2(&amp;a)</span><br><span class="line">fmt.Println(<span class="string">&quot;a调⽤函数之后的值：&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指针函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> *[<span class="number">4</span>]<span class="type">int</span> &#123;</span><br><span class="line">arr := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指针作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(ptr *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;ptr&quot;</span>, ptr)</span><br><span class="line">fmt.Println(<span class="string">&quot;*ptr&quot;</span>, *ptr)</span><br><span class="line">*ptr = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构体是值类型</p><p><strong>定义</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用type关键字</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">    Address <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用匿名结构体</span></span><br><span class="line">person := <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">    Address <span class="type">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    Name: <span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">    Age: <span class="number">30</span>,</span><br><span class="line">    Address: <span class="string">&quot;bbb&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>初始化</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">    Address <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字面量初始化 - 按照定义字段进行赋值</span></span><br><span class="line">p1 := Person&#123;<span class="string">&quot;aaa&quot;</span>, <span class="number">30</span>, <span class="string">&quot;bbb&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键值对初始化 - 不受定义字段顺序影响</span></span><br><span class="line">p2 := Person &#123;</span><br><span class="line">    Name: <span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">    Address: <span class="string">&quot;bbb&quot;</span>,</span><br><span class="line">    Age: <span class="number">25</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 关键字初始化</span></span><br><span class="line"><span class="comment">// 创建一个指向已初始化所有字段为零值的新结构体指针</span></span><br><span class="line">p3 := <span class="built_in">new</span>(Person)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用取址符进行初始化</span></span><br><span class="line">p4 := &amp;Person&#123;<span class="string">&quot;aaa&quot;</span>, <span class="number">28</span>, <span class="string">&quot;ccc&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>结构体指针的应用</p><p>new(T)函数是⼀个分配内存的内建函数。 （在结构体中出现的） 我们都知道，对于⼀个已经存在变量，可对其指针进⾏赋值。 make不仅可以开辟⼀个内存，还能给这个内存的类型初始化其零值。 make和new都是golang⽤来分配内存的內建函数，且在堆上分配内存，make 即分配内存，也初始化内 存。new只是将内存清零，并没有初始化内存。 make返回的还是引⽤类型本身；⽽new返回的是指向类型的指针。 make只能⽤来分配及初始化类型为slice，map，channel的数据；new可以分配任意类型的数据。</p><ul><li><code>new</code>函数用于分配内存并返回一个指向该类型零值的指针，适用于各种数据类型。</li><li><code>make</code>函数用于创建切片、映射和通道，并返回初始化后的引用类型实例，适用于引用类型（Slice、Map和Channel）。</li><li><code>new</code>函数只分配内存，不进行初始化，得到的指针指向零值。</li><li><code>make</code>函数分配内存并进行初始化，返回引用类型的实例。</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体是值类型，值传递</span></span><br><span class="line">user1 := User1&#123;<span class="string">&quot;qinjiang&quot;</span>, <span class="number">18</span>, <span class="string">&quot;nan&quot;</span>&#125;</span><br><span class="line">fmt.Println(user1)</span><br><span class="line">user2 := user1</span><br><span class="line">user2.name = <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">fmt.Println(user1)</span><br><span class="line">fmt.Println(user2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针</span></span><br><span class="line"><span class="keyword">var</span> user3 *User1</span><br><span class="line">user3 = &amp;user1</span><br><span class="line">(*user3).name = <span class="string">&quot;feige&quot;</span></span><br><span class="line">fmt.Println(user1)</span><br><span class="line"></span><br><span class="line"><span class="comment">//new ⽅法 跟指针的效果⼀样</span></span><br><span class="line"><span class="comment">//new ⽅法 跟指针的效果⼀样</span></span><br><span class="line">user4 := <span class="built_in">new</span>(User1)</span><br><span class="line">user4.name = <span class="string">&quot;aaa&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, user4) <span class="comment">// 以指针的形式</span></span><br><span class="line">fmt.Println(user4)</span><br><span class="line">fmt.Println(*user4)</span><br><span class="line">fmt.Println(user1)</span><br></pre></td></tr></table></figure><p><strong>匿名结构体</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匿名结构体</span></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">string</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f1 := Student&#123;name: <span class="string">&quot;xioawang&quot;</span>, age: <span class="number">14</span>&#125;</span><br><span class="line">fmt.Println(f1)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//完全匿名结构体 和匿名字段 都是⽤于嵌套</span></span><br><span class="line">f2 := <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age <span class="type">int</span></span><br><span class="line">&#125;&#123;<span class="string">&quot;qinjiang&quot;</span>, <span class="number">18</span>&#125;</span><br><span class="line">    </span><br><span class="line">fmt.Println(f2)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//也可以不⽤定义字段的名字 不过不建议这样做</span></span><br><span class="line">f3 := <span class="built_in">new</span>(Teacher)</span><br><span class="line">t1 := Teacher&#123;<span class="string">&quot;⼩王&quot;</span>, <span class="number">27</span>&#125;</span><br><span class="line"><span class="comment">//匿名字段 默认使⽤字段数据类型当字段名称</span></span><br><span class="line">fmt.Println(t1.<span class="type">string</span>)</span><br><span class="line">f3.<span class="type">string</span> = <span class="string">&quot;xiaowang&quot;</span></span><br><span class="line">fmt.Println(f3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结构体嵌套</strong></p><p>在一个结构体中嵌套另一个结构体作为他的字段</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义Person结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Address结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">City  <span class="type">string</span></span><br><span class="line">State <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Student结构体中嵌套Person和Address结构体</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Person</span><br><span class="line">Address</span><br><span class="line">Grade <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个Student实例</span></span><br><span class="line">student := Student&#123;</span><br><span class="line">Person: Person&#123;Name: <span class="string">&quot;Alice&quot;</span>, Age: <span class="number">18</span>&#125;,</span><br><span class="line">Address: Address&#123;City: <span class="string">&quot;New York&quot;</span>, State: <span class="string">&quot;NY&quot;</span>&#125;,</span><br><span class="line">Grade:  <span class="number">12</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问Student的字段</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Name:&quot;</span>, student.Name)          <span class="comment">// 访问Person结构体的字段</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Age:&quot;</span>, student.Age)            <span class="comment">// 访问Person结构体的字段</span></span><br><span class="line">fmt.Println(<span class="string">&quot;City:&quot;</span>, student.City)          <span class="comment">// 访问Address结构体的字段</span></span><br><span class="line">fmt.Println(<span class="string">&quot;State:&quot;</span>, student.State)        <span class="comment">// 访问Address结构体的字段</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Grade:&quot;</span>, student.Grade)        <span class="comment">// 访问Student自身的字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>导出结构体和字段</strong></p><p>如果结构体类型以大写字母开头（public），那么他是一个可导出类型，可以从其他包访问它</p><h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a><strong>类继承</strong></h4><p>继承就是在一个类中使用匿名字段，该字段也是一个结构体</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义⼀个⽗&quot;类&quot;结构体</span></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义⼀个⼦&quot;类&quot;结构体</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">person <span class="comment">//匿名变量，继承的作⽤</span></span><br><span class="line">school <span class="type">string</span> <span class="comment">//⼦类⾃⼰的属性字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建</span></span><br><span class="line">p1 := Student&#123;</span><br><span class="line">person: person&#123;<span class="string">&quot;⼩王&quot;</span>, <span class="number">18</span>&#125;,</span><br><span class="line">school: <span class="string">&quot;清华&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是通过⼦类的对象调⽤⽗类再点名字。</span></span><br><span class="line">fmt.Println(p1.person.name)</span><br></pre></td></tr></table></figure><p><strong>方法和方法重写</strong>：</p><p>方法：在函数中加入指定类型就是方法，方法只能通过指定对象进行调用</p><p>方法重写：子类可以重写父类的方法，子类可以新增自己的属性和方法，子类可以直接访问父类的属性和方法</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类 人</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(person Person)</span></span> learn () &#123;</span><br><span class="line">    fmt.Println(person.name + <span class="string">&quot;eating&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person</span><br><span class="line">    <span class="comment">// 子类可以新增自己的属性</span></span><br><span class="line">    id <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 学生重写 人的 learn 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu Student)</span></span> learn &#123;</span><br><span class="line">    fmt.Println(stu.name + stu.id + <span class="string">&quot;learning&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu Student)</span></span> play &#123;</span><br><span class="line">     fmt.Println(stu.name + stu.id + <span class="string">&quot;playing&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stu := Student&#123;</span><br><span class="line">        Person &#123;</span><br><span class="line">            name:<span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">            age:<span class="number">15</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;111&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    stu.learn()</span><br><span class="line">    stu.play()</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a><strong>接口的继承</strong></h4><p>当一个接口（称为前接口）通过嵌套方式继承了另外一个接口（称为继承的接口），实现这个前接口的具体类必须不仅实现前接口中的方法，还必须实现继承的接口中的方法。</p><p>将前一个接口的实现类赋值给他的继承接口时，该接口的对象只能调用他自己的方法。（在接口嵌套中，嵌套的接口默认继承了被嵌套接口的所有方法）</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">interface</span> &#123;</span><br><span class="line">test2()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> C <span class="keyword">interface</span> &#123;</span><br><span class="line">test3()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> D <span class="keyword">interface</span> &#123;</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">test4()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Dog5 <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dog Dog5)</span></span> test2() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;test2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dog Dog5)</span></span> test3() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;test3&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dog Dog5)</span></span> test4() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;test4&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">dog := Dog5&#123;&#125;</span><br><span class="line">dog.test2()</span><br><span class="line">dog.test3()</span><br><span class="line">dog.test4()</span><br><span class="line"><span class="comment">//再接⼝嵌套中，嵌套的接⼝默认继承了被嵌套接⼝的所有⽅法</span></span><br><span class="line"><span class="comment">//将dog赋值给接⼝ 该接⼝只能调⽤⾃⼰的⽅法</span></span><br><span class="line"><span class="keyword">var</span> b1 B = dog</span><br><span class="line">b1.test2()</span><br><span class="line"><span class="comment">//由于d是继承了 B和C 所以他还是可以调⽤⾥⾯的⽅法</span></span><br><span class="line"><span class="keyword">var</span> d1 D = dog</span><br><span class="line">d1.test4()</span><br><span class="line">d1.test3()</span><br><span class="line">d1.test2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口：它把所有具有共性的方法定义在一起，任何其他类型只要实现接口定义的全部方法就是实现了这个接口，接口只做定义，不做具体的方法实现，具体实现交给实现方法</p><p>形式：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口名 <span class="keyword">interface</span> &#123;</span><br><span class="line">    方法名<span class="number">1</span>(参数列表) 返回值列表</span><br><span class="line">    方法名<span class="number">2</span>(参数列表) 返回值列表</span><br><span class="line">    <span class="comment">// 更多方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>接口是一组方法签名的集合，表示对象的行为。</li><li>一个类型只要实现了接口中定义的所有方法，就被认为实现了该接口。</li><li>接口变量可以持有任意实现了接口的类型的值。</li><li>接口的实现是隐式的，不需要显式地声明一个类型实现了某个接口。</li><li>接口可以嵌套定义，一个接口可以包含其他接口。</li><li>空接口<code>interface&#123;&#125;</code>表示不包含任何方法，所有类型都实现了空接口，因此可以表示任意类型的值。</li></ol><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用步骤</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义一个接口，并在其中声明所需方法。</span></span><br><span class="line"><span class="comment">方法签名指定的方法名称，参数列表和返回值列表，但没有具体的实现代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> USB <span class="keyword">interface</span> &#123;</span><br><span class="line">    intput()</span><br><span class="line">    output()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建接口的实现类</span></span><br><span class="line"><span class="keyword">type</span> Mouse <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在GO中，只要一个类型实现了接口中的所有方法，它就被视为实现了该接口</span></span><br><span class="line"><span class="comment">在GO中，接口的实现是隐式的，因此无需显示声明类型实现了某个接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mouse Mouse)</span></span> input() &#123;</span><br><span class="line">    fmt.Println(mouse.name + <span class="string">&quot;⿏标输⼊&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mouse Mouse)</span></span> output() &#123;</span><br><span class="line">    fmt.Println(mouse.name + <span class="string">&quot;⿏标输出&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(u USB)</span></span> &#123;</span><br><span class="line">    u.input()</span><br><span class="line">    u.output()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    m := Mouse&#123;<span class="string">&quot;aaa&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 通过传入接口的实现类，来进行具体方法的调用</span></span><br><span class="line">    test(m) <span class="comment">// 需要结构体完整的实现接口，才可以进行（传入对象的方法的调用）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义接口，将实现类赋值给接口</span></span><br><span class="line">    <span class="keyword">var</span> u USB</span><br><span class="line">    <span class="comment">// 接口对象可以接收实现类的赋值，并调用实现类的方法，但不能访问实现类的属性</span></span><br><span class="line">    u = m</span><br><span class="line">    fmt.Println(u)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口断言</strong></p><p>从接口的具体值中提取具体类型的基础，当一个接口值保存了一个具体类型的值时，我们可以使用接口断言来获取该具体类型的值</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, ok := interfaceVar.(Type)</span><br></pre></td></tr></table></figure><p>其中，<code>interfaceVar</code> 是一个接口类型的变量，<code>Type</code> 是具体的类型。<code>value</code> 是断言后获取到的具体类型的值，而 <code>ok</code> 是一个布尔值，用于表示断言是否成功。</p><ul><li>如果 <code>interfaceVar</code> 中保存的确实是 <code>Type</code> 类型的值，那么断言成功，<code>value</code> 将包含这个具体类型的值，而 <code>ok</code> 将是 <code>true</code>。</li><li>如果 <code>interfaceVar</code> 中保存的不是 <code>Type</code> 类型的值，那么断言失败，<code>value</code> 将是 <code>Type</code> 类型的零值，而 <code>ok</code> 将是 <code>false</code>。</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>一个事物拥有多种形态，例如：学生和老师即是他们本身，又是人类</p><p>只要一个结构体实现了接口（父类）中的所有方法，然后再定义一个函数传入父类接口，用该父类接口调用实现类实现的方法，这就是多态</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 定义形状接口</span></span><br><span class="line"><span class="keyword">type</span> Shape <span class="keyword">interface</span> &#123;</span><br><span class="line">Area() <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形类型</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">Width  <span class="type">float64</span></span><br><span class="line">Height <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> Area() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.Width * r.Height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆形类型</span></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">Radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> Area() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Pi * c.Radius * c.Radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印形状的面积</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintArea</span><span class="params">(shape Shape)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;面积为: %.2f\n&quot;</span>, shape.Area())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建不同形状的对象</span></span><br><span class="line">rect := Rectangle&#123;Width: <span class="number">4</span>, Height: <span class="number">5</span>&#125;</span><br><span class="line">circle := Circle&#123;Radius: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用统一的接口来调用不同形状的方法</span></span><br><span class="line">PrintArea(rect)</span><br><span class="line">PrintArea(circle)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>错误是指可能出现问题的地方出现了问题，而异常不是</p><p>GO中的错误也是以一种类型，错误用内置的error类型表示。错误值可以存储在变量中，从函数中返回</p><p><strong>创建自己的错误信息</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">customFunction</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;发生了自定义错误&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := customFunction(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;发生错误：&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义自己的错误</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义自定义错误类型</span></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Message <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 error 接口的 Error() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e MyError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;自定义错误： %s&quot;</span>, e.Message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义函数，返回自定义错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">customFunction</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MyError&#123;Message: <span class="string">&quot;发生了自定义错误&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调用自定义函数</span></span><br><span class="line">    <span class="keyword">if</span> err := customFunction(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;发生错误：&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义⼀个⾃⼰的错误</span></span><br><span class="line"><span class="keyword">type</span> myDiyError <span class="keyword">struct</span> &#123;</span><br><span class="line">code <span class="type">int</span></span><br><span class="line">msg <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现错误类的⽅法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e myDiyError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprint(<span class="string">&quot;错误信息：&quot;</span>, e.msg, <span class="string">&quot;状态码：&quot;</span>, e.code)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟⼀个错误 返回 类的数值和错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(i <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i, &amp;myDiyError&#123; <span class="comment">//&amp;得到错误的对象</span></span><br><span class="line">code: <span class="number">500</span>,</span><br><span class="line">msg: <span class="string">&quot;⾮0数据&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果输⼊的数不是0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i, err := test(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="comment">//断⾔ 看还不是返回的⼦集设计的错误</span></span><br><span class="line">myerr, ok := err.(*myDiyError)<span class="comment">//取错误⾥⾯的数值</span></span><br><span class="line"><span class="comment">//如果是 输出信息</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(myerr.msg)</span><br><span class="line">fmt.Println(myerr.code)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回输⼊的数值</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="panic-和-recover"><a href="#panic-和-recover" class="headerlink" title="panic 和 recover"></a>panic 和 recover</h2><p>在 Go 语言中，<code>panic</code> 和 <code>recover</code> 是用于处理程序异常的特殊内建函数。</p><ol><li><code>panic</code>：<ul><li><code>panic</code> 是一个内建函数，用于在程序运行时引发运行时错误（panic），并导致程序终止。当发生严重错误时，<code>panic</code> 可以用来中断程序的正常流程，并立即停止程序的执行。</li><li><code>panic</code> 接受一个任意类型的参数，通常是一个字符串，用于表示错误信息。</li><li>一旦 <code>panic</code> 被调用，程序将立即停止执行当前函数的剩余代码，并开始回溯调用栈，执行每个调用函数的 <code>defer</code> 语句，然后打印出 panic 信息，并终止程序。</li><li><code>panic</code> 类似于其他编程语言中的异常（exception），但与其他语言的异常处理不同，Go 推荐在发生错误时使用错误值（error）来处理，而不是过度使用 <code>panic</code>。</li></ul></li><li><code>recover</code>：<ul><li><code>recover</code> 是一个内建函数，用于在发生 <code>panic</code> 后恢复程序的控制流程，避免程序直接终止。</li><li><code>recover</code> 只能在 <code>defer</code> 函数中使用，用于捕获 <code>panic</code> 引发的错误，并进行处理。</li><li>如果在 <code>defer</code> 函数中调用了 <code>recover</code> 并且程序中有 <code>panic</code> 发生，<code>recover</code> 将返回 <code>panic</code> 引发的错误信息，并将程序的执行流程从 <code>panic</code> 状态恢复正常。</li><li>如果没有发生 <code>panic</code>，<code>recover</code> 将返回 <code>nil</code>。</li></ul></li></ol><p>以下是一个示例，演示了 <code>panic</code> 和 <code>recover</code> 的使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">goCopy codepackage main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func recoverFunction() &#123;</span><br><span class="line">defer func() &#123;</span><br><span class="line">if err := recover(); err != nil &#123;</span><br><span class="line">fmt.Println(&quot;捕获到 panic 错误：&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">// 引发 panic</span><br><span class="line">panic(&quot;发生了 panic 错误&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">// 调用 recoverFunction，其中包含 panic 和 recover</span><br><span class="line">recoverFunction()</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;程序继续执行...&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们定义了一个名为 <code>recoverFunction</code> 的函数，并在其中使用了 <code>defer</code> 语句。在 <code>recoverFunction</code> 中，我们调用了 <code>panic</code> 函数，引发了一个 panic 错误。然后，我们使用 <code>recover</code> 函数在 <code>defer</code> 语句中捕获了这个 panic 错误，并输出了错误信息。</p><p>在 <code>main()</code> 函数中，我们调用了 <code>recoverFunction</code>，在其内部进行了 panic 和 recover 的处理。由于 <code>recover</code> 被放置在 <code>defer</code> 语句中，当 panic 发生时，程序会执行 <code>recover</code> 语句块，并捕获了 panic 错误。这样程序将继续正常执行后续代码，不会立即终止。</p><p>需要注意的是，<code>recover</code> 只在 <code>defer</code> 函数中调用才会生效，如果在非 <code>defer</code> 函数中调用 <code>recover</code> 是无效的。另外，<code>recover</code> 只能用于恢复 panic 错误，不能处理其他类型的异常。因此，在 Go 语言中，推荐使用错误值（error）来处理程序中的错误，而将 <code>panic</code> 和 <code>recover</code> 仅用于非常特殊的情况，例如处理不可恢复的程序状态或处理关键错误。</p><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p><strong>介绍</strong></p><p>是系统中数据交互不可缺少的内容</p><ol><li><p>JSON</p><p>json是完全独立于语言的文本格式，是k-v形式的name:zs</p><p>应用场景：前后端交互，系统间数据交互</p><p><img src="/posts/9364/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230727032427.png"></p><p>json使用GO语言内置的encoding&#x2F;json标准库</p><p>编码json使用json.Marshal()函数可以对一组数据进行JSON格式的编码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>JSON编码（序列化）‘</p><p>使用<code>json.Marshal()</code>函数将Go数据结构编码为JSON格式的数据。通常，你可以将Go的struct、slice、map或基本类型数据转换为JSON。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">person := Person&#123;</span><br><span class="line">Name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">Age:  <span class="number">30</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Go结构体编码为JSON</span></span><br><span class="line">jsonData, err := json.Marshal(person)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;编码失败：&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="type">string</span>(jsonData)) <span class="comment">// 输出：&#123;&quot;name&quot;:&quot;John&quot;,&quot;age&quot;:30&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JSON解码（反序列化）</p><p>使用<code>json.Unmarshal()</code>函数将JSON数据解码为Go数据结构。在解码时，需要提供目标数据结构的指针。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">jsonData := []<span class="type">byte</span>(<span class="string">`&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:25&#125;`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将JSON数据解码为Go结构体</span></span><br><span class="line"><span class="keyword">var</span> person Person</span><br><span class="line">err := json.Unmarshal(jsonData, &amp;person)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;解码失败：&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Name:&quot;</span>, person.Name) <span class="comment">// 输出：Name: Alice</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Age:&quot;</span>, person.Age)   <span class="comment">// 输出：Age: 25</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>在Go中，只有导出的（大写字母开头的）字段才会被JSON编码和解码。</li><li>JSON中的字段名和Go结构体字段名之间必须是大小写敏感的。</li><li>对于嵌套结构体，如果字段名冲突，JSON编码会采用“最近者优先”的原则</li></ul></li></ol><h2 id="常用包"><a href="#常用包" class="headerlink" title="常用包"></a>常用包</h2><ol><li>fmt：该包提供了格式化输入输出功能，可以进行控制台打印、格式化输出等。</li><li>os：os包提供了与操作系统交互的功能，例如文件操作、环境变量读取、进程管理等。</li><li>io：该包提供了基本的I&#x2F;O操作功能，例如文件读写、数据流处理等。</li><li>net：net包提供了网络编程相关的功能，例如TCP&#x2F;IP、HTTP、SMTP等协议的支持。</li><li>http：该包提供了HTTP客户端和服务器的实现，方便进行Web开发和HTTP请求处理。</li><li>encoding&#x2F;json：该包提供了JSON数据的编码和解码功能，方便处理JSON格式数据。</li><li>database&#x2F;sql：这是一个数据库接口包，提供了对关系型数据库的操作接口，例如MySQL、PostgreSQL等。</li><li>time：time包提供了时间相关的操作，例如获取当前时间、时间格式化、定时器等功能。</li><li>strconv：该包提供了字符串与基本数据类型之间的转换功能，例如字符串转整数、整数转字符串等。</li><li>math：math包提供了常用的数学函数，例如四舍五入、取绝对值、三角函数等。</li><li>sync：sync包提供了并发编程相关的工具，例如互斥锁、条件变量等。</li><li>context：该包提供了上下文管理，用于在多个Goroutine之间传递请求范围的数据和取消信号。</li><li>testing：testing包用于编写单元测试和性能测试</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/posts/41682.html"/>
      <url>/posts/41682.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="Iterator模式"><a href="#Iterator模式" class="headerlink" title="Iterator模式"></a>Iterator模式</h2><p>Iterate：反复做某事</p><p>Iterator：迭代器</p><p><em><strong>介绍</strong></em></p><p><strong>意图</strong>：提供一种方法顺序访问一个聚合对象中的各个元素，而无需暴露该对象的内部表示，是一种行为模式</p><p><strong>主要解决</strong>：不同的方式来遍历整个整合对象（集合）</p><p><strong>如何解决</strong>：把在元素之间游走的责任交给迭代器，而不是聚合对象</p><p><strong>关键代码</strong>：定义接口：hasNext，next</p><p><strong>应用实例</strong>：java 中的Iterator</p><p><strong>优点</strong>：</p><ol><li>支持以不同的方式遍历一个聚合对象</li><li>迭代器简化了聚合类。</li><li>在同一个聚合上可以有多个遍历</li><li>在迭代器模式中，增加新的聚合类和迭代器类都很方便而无需修改原有代码</li></ol><p><strong>缺点</strong>：</p><ol><li>由于迭代器模式将储存数据和遍历数据的职责分离，增加新的聚合类需要增加新的迭代器类，类的个数成对增加，在一定程度上会增加系统复杂性</li></ol><p><em><strong>实现</strong></em></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合需要实现的接口，集合需要能提供对应的迭代器，真实的结合不止这一个方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Aggregate</span> &#123;</span><br><span class="line">    Iterator <span class="title function_">iteartor</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="comment">// 返回当前元素，并指向下一个元素</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 确认接下来能否调用 next 方法-</span></span><br><span class="line">    Object <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合中的单个元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 书架，实现集合接口，能对外提供对应的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookShelf</span> <span class="keyword">implements</span> <span class="title class_">Aggregate</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Book[] books;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookShelf</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.books = <span class="keyword">new</span> <span class="title class_">Book</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getBookAt</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> books[idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.books[last++] = book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供相应的迭代器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">iteartor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BookShelfIterator</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 书架的迭代器，实现了迭代器接口的功能，能执行迭代器的作用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookShelfIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line">    <span class="comment">// 迭代器中的对象</span></span><br><span class="line">    <span class="keyword">private</span> BookShelf bookShelf;</span><br><span class="line">    <span class="comment">// 下一个下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookShelfIterator</span><span class="params">(BookShelf bookShelf)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookShelf = bookShelf;</span><br><span class="line">        <span class="built_in">this</span>.idx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; bookShelf.getLength()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> bookShelf.getBookAt(idx++);</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/posts/41682/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230721222028.png"></p><p><em><strong>解析</strong></em></p><ul><li><p>Iterator（迭代器）</p><p>负责定义按顺序逐个遍历元素的接口（API）包含hasNext 和 next 方法</p></li><li><p>ConcreteIterator（具体的迭代器）</p><p>负责实现 Iterator 所定义的接口</p></li><li><p>Aggregate（集合）</p><p>负责定义创建 Iterator 角色的接口。这个接口是一个方法，会创建出”按顺序访问保存在我内部元素的人“</p><p>】</p></li><li><p>ConcreteAggregate（具体集合）</p><p>负责实现 Aggregate 所定义的接口。能创建出具体的 Iterator 角色</p></li></ul><p><img src="/posts/41682/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230721222745.png"></p><p><strong>为什么要使用 Iterator 模式</strong></p><p>在我们使用这个模式之后，可以将遍历与实现进行分离，如果我们放弃使用数组来对图书进行管理，不管BookShelf 如何变化，只要BookShelf方法能正确的返回 Iterator （这也是为什么 Iterator 方法的返回值不是BookShelfIterator的原因）的实例，那么我们无需对下面的遍历方法进行任何修改，代码都可以正常工作。</p><p><img src="/posts/41682/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230721223124.png"></p><p>这种设计模式能极大的方便调用者，当程序的一个组件发生改变时，不需要对其他的组件进行修改或者只需要很小的修改即可应对，实现代码的可复用性</p><p>但是我们如果修改集合类，那么我们必须修改他对应的迭代器类</p><h2 id="Adapter模式"><a href="#Adapter模式" class="headerlink" title="Adapter模式"></a>Adapter模式</h2><p><em><strong>介绍</strong></em></p><p><strong>意图</strong>：<strong>将一个类的接口转换成用户希望的另一个接口</strong>。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</p><p><strong>主要解决</strong>：如何将一些现存的对象放到新环境中，而新环境的接口是现对象不能满足（没有，不存在）的</p><p><strong>何时使用</strong>：</p><ol><li>系统需要使用现有的类，而此类的接口不符合系统需要。</li><li>想要建立一个可以重复使用的类，用于一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些类源不一定有一致的接口。</li><li>通过接口转换，将一个类插入另一个类系中</li><li>接口升级：当我们需要修改一个接口，但又不希望影响到已有的客户端代码时，可以使用适配器模式来提供向后兼容的接口</li></ol><p><strong>如何解决</strong>：继承或依赖（推荐）</p><p><strong>关键代码</strong>：如何对API进行包装，继承或依赖已有的对象，实现想要的目标接口</p><p><strong>应用实例</strong>：Java中的JDBC，在LINUX上运行WINDOWS程序</p><p><strong>优点</strong>：</p><ol><li>可以让任何两个没有关联的类一起运行。</li><li>提高了类的复用性</li><li>增加了类的透明度</li><li>灵活性好</li></ol><p><strong>缺点</strong>：</p><ol><li>过多使用适配器，会让系统非常凌乱，不容易整体进行把握。比如，命名看到调用的是A接口，其实内部被适配器改成了B接口的实现，一个系统如果太多出现这种情况，会是一场灾难</li><li>Java最多继承一个类，所以最多只能适配一个适配者类，而且目标必须是抽象类</li></ol><p><strong>使用场景</strong>：有动机的修改一个正常运行的系统接口，这时应该考虑使用适配器模式。</p><p><strong>注意事项</strong>：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题</p><p><em><strong>实现</strong></em></p><ol><li><p>使用继承</p><p><img src="/posts/41682/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230721232316.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Adapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Print</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printWeek</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printStrong</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Adapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Banner</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Banner</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.string = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showWithParen</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(&quot;</span> + string + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showWithAster</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*&quot;</span> + string + <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用继承的适配器，使用继承的适配器</span></span><br><span class="line"><span class="comment"> * 相当于我们把Banner类的API进行了包装让他能被Main类使用</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintBanner</span> <span class="keyword">extends</span> <span class="title class_">Banner</span> <span class="keyword">implements</span> <span class="title class_">Print</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintBanner</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printWeek</span><span class="params">()</span> &#123;</span><br><span class="line">        showWithParen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStrong</span><span class="params">()</span> &#123;</span><br><span class="line">        showWithParen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Adapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个类知道是使用 Print 接口来进行编程的，但是对于Main类代码而言</span></span><br><span class="line"><span class="comment">     * Banner 类，showWithParen方法和showWithAster方法被完全隐藏起来了</span></span><br><span class="line"><span class="comment">     * 这样就可以在不用对Main类进行修改的情况下改变PrintBanner类的具体实现</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Print</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintBanner</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        p.printWeek();</span><br><span class="line">        p.printStrong();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>使用委托</p><p>委托就是指将某个方法中的实际处理交给其他对象的方法</p><p><img src="/posts/41682/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230721232357.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Adapter.委托;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Print</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">printWeek</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">printStrong</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Adapter.委托;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在这里，我们利用Banner实现一个类</span></span><br><span class="line"><span class="comment"> * 该类的方法和Print类相同</span></span><br><span class="line"><span class="comment"> * 在这个类中，banner字段保存了Banner类的实例</span></span><br><span class="line"><span class="comment"> * 然后，这个类的方法会通过banner字段去调用他的方法</span></span><br><span class="line"><span class="comment"> * 本质上也是对接口进行了一个包装，让Main类可以正确的使用他</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintBanner</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Banner banner;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintBanner</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.banner = <span class="keyword">new</span> <span class="title class_">Banner</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printWeek</span><span class="params">()</span> &#123;</span><br><span class="line">        banner.showWithParen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStrong</span><span class="params">()</span> &#123;</span><br><span class="line">        banner.showWithAster();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Adapter.委托;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Adapter.继承.Print;</span><br><span class="line"><span class="keyword">import</span> Adapter.继承.PrintBanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个类知道是使用 Print 接口来进行编程的，但是对于Main类代码而言</span></span><br><span class="line"><span class="comment">     * Banner 类，showWithParen方法和showWithAster方法被完全隐藏起来了</span></span><br><span class="line"><span class="comment">     * 这样就可以在不用对Main类进行修改的情况下改变PrintBanner类的具体实现</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Print</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintBanner</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        p.printWeek();</span><br><span class="line">        p.printStrong();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Adapter.委托;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Banner</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Banner</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.string = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showWithParen</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(&quot;</span> + string + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showWithAster</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*&quot;</span> + string + <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><em><strong>解析</strong></em></p><ul><li><p>Target（对象）</p><p>该角色负责定义所需的方法，可以是接口，也可以是一个抽象类</p></li><li><p>Client（请求者）</p><p>负责使用Target角色所定义的方法进行具体处理，负责使用的一方</p></li><li><p>Adaptee（被适配）</p><p>一个用于被适配的角色，负责提供的一方</p></li><li><p>Adapter（适配）</p><p>主角，负责对被适配者进行修改的地方，让被适配者能满足请求者的需求</p></li></ul><p>通过这个模式，我们很容易根据已有的类去创建我们需要的方法群，当出现Bug时，由于我们明确的知道Bug不在现有的 类（被适配者）中，所以只需调查适配器即可</p><p>通常我们让现有的类适配新的接口时，常常会有只要将这里稍微修改下就可以了的想法，一不留神就会修改现有的代码，但是如果我们对已经测试完毕的现有代码进行修改，就必须在修改后重新进行测试。使用Adapter模式可以在完全不改变现有代码的前提下使用现有代码用于匹配新的API，此外如果没有现有代码，只要知道现有类的功能，就可以编写出新的类</p><p>通过适配器，我们也可以让一个新版本的程序使用旧版本中的方法</p><p><img src="/posts/41682/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230721235350.png"></p><h2 id="Template-模式"><a href="#Template-模式" class="headerlink" title="Template 模式"></a>Template 模式</h2><p><strong>在父类中定义处理流程的框架，在子类中实现具体处理</strong></p><p>在模板模式中，一个抽象类公开定义了执行它的方法的方式&#x2F;模板。他的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。是一种行为模式</p><p><em><strong>介绍</strong></em></p><p><strong>意图</strong>：定义一个操作中算法的骨架，将一些步骤延迟到子类中。模板方法让子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤</p><p><strong>主要解决</strong>：一些方法通用，却在每一个子类都重写了这一方法。</p><p><strong>合时使用</strong>：有一些通用的方法</p><p><strong>如何解决</strong>：将一些通用算法抽象出来</p><p><strong>关键代码</strong>：抽象类，实现类（体会抽象类的作用）</p><p><strong>应用实例</strong>：</p><ol><li>奥特曼的每一集，就是一个顶层的逻辑骨架</li><li>spring 中队 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务，获取Session，关闭 Session等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存</li><li>java.io.InputStream是一个抽象类，子类实现的抽象方法有 read()，availabe()，close()</li></ol><p><strong>优点</strong>：</p><ol><li>封装不变部分，扩展可变部分</li><li>提取公共代码，便于维护</li><li>行为有父类控制，子类实现</li></ol><p><strong>缺点</strong>：</p><ol><li>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使系统更加庞大</li></ol><p><strong>使用场景</strong>：</p><ol><li>多个子类共有的方法，且<strong>逻辑</strong>相同</li><li>重要的，复杂的方法，可以考虑作为模板方法</li></ol><p><strong>注意事项</strong>：为了防止恶意操作，一般模板方法都加上final关键词。</p><p><em><strong>实现</strong></em></p><p><img src="/posts/41682/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230726034230.png"></p><p>顶层框架，规定逻辑操作，具体实现由子类完成</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Template;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractDisplay</span> &#123;</span><br><span class="line">    <span class="comment">// 还没有实现的一些操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装处理流程，但是具体的操作还没有实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        open();;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            print();</span><br><span class="line">        &#125;</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现抽象类的子类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Template;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharDisplay</span> <span class="keyword">extends</span> <span class="title class_">AbstractDisplay</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CharDisplay</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ch = ch;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 实现具体操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;&lt;&lt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Template;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDisplay</span> <span class="keyword">extends</span> <span class="title class_">AbstractDisplay</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StringDisplay</span><span class="params">(String string)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.string = string;</span><br><span class="line">        <span class="built_in">this</span>.width = string.length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        printLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;|&quot;</span> + string + <span class="string">&quot;|&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        printLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printLine</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; width; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建不同子类，调用抽象类中规定好的逻辑操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Template;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbstractDisplay</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharDisplay</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="type">AbstractDisplay</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringDisplay</span>(<span class="string">&quot;ccccccccc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        a.display();</span><br><span class="line">        b.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em><strong>解析</strong></em></p><p>（这是一个为打工人设计的模式？大佬负责写顶层逻辑，小弟负责实现？？？）</p><p>在这个模式中，主要角色有两个</p><ul><li><p>AbstractClass(抽象类)</p><p>抽象类负责实现模板方法，还负责声明模板方法中所使用到的抽象方法。这些方法由子类负责实现</p></li><li><p>ConcreteClass(具体类)</p><p>该角色负责实现抽象类中定义的抽象方法，这里实现的方法会在抽象类中的模板方法中被调用</p></li></ul><p>在这个模式中，父类和子类联系紧密，共同工作，在子类中实现父类中声明的抽象方法时，必须理解这些抽象方法被调用的时机，在看不到父类的源代码的情况向，想编写出子类是非常困难的</p><p>在实例程序中，不管哪个子类都是保存在父类类型变量中，然后再调用逻辑方法的，使用父类变量保存子类实例的优点是，即使没有用 instanceof指定子类种类，程序也能正常工作，<strong>无论在父类类型变量中保存哪个子类的实例，程序都可以正常工作，这种原则被称为里氏替换原则（LSP）</strong></p><p><em><strong>扩展</strong></em></p><p>在理解类的层次时，通常是站在子类的角度进行思考的，可以从以下方面入手</p><ul><li>在子类中可以使用父类中定义的方法</li><li>可以通过在子类中增加方法以实现新的功能</li><li>在子类中重写父类方法可以改变程序的行为</li></ul><p>如果站在父类的角度进行思考，在父类中，我们声明了抽象方法，则希望达到以下目的</p><ul><li>期待子类去实现抽象方法</li><li>要求子类去实现抽象方法</li></ul><p>子类具有实现在父类中声明的抽象方法的责任。这种责任被称为子类责任</p><p>在抽象类阶段确定处理的流程非常重要</p><p>父类与子类的相互写作支撑起了整个程序，虽然将更多方法的实现放在父类中会让子类变得更轻松，但同时也降低了子类的灵活性；反之，子类则会变得臃肿不堪，还容易导致子类间的代码出现重复</p><p>java.io.InputStream使用了模板模式，需要子类实现的方法有read()，availabe()，close()</p><h2 id="Factory-模式"><a href="#Factory-模式" class="headerlink" title="Factory 模式"></a>Factory 模式</h2><p>在模板模式中，我们在父类中规定处理的流程，在子类中实现具体的处理。如果将该模式用于生成实例，那他就是抽象工厂模式</p><p>在工厂模式中父类决定实例的生成方式，但并不决定要生成的具体类，具体的处理全部交给子类负责。这样就可以将生成实例的框架（framework）和实际负责生成实例的类解耦</p><p>工厂模式提供一种将对象的实例化过程封装在工厂类中的方式，通过工厂模式，可以将对象的创建与使用代码分离，提供一种统一接口来创建不同类型的 对象</p><p><em><strong>介绍</strong></em></p><p><strong>意图</strong>：定义一个创建对象的结构，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行</p><p><strong>主要解决</strong>：接口的选择问题</p><p><strong>何时使用</strong>：我们明确的计划不同条件下创建不同实例时。</p><p><strong>关键代码</strong>：抽象，封装</p><p><strong>应用实例</strong>：</p><ol><li>JDBC连接工厂</li><li>GUI组件工厂</li><li>日志记录器功能工厂</li><li>加密算法工厂</li></ol><p><strong>优点</strong>：</p><ol><li>一个调用者想创建一个对象，只要知道名称就可以</li><li>扩展性高，如果增加一个产品，只要扩展一个工厂类就可以</li><li>屏蔽产品的具体实现，调用者只关心产品的接口</li></ol><p><strong>缺点</strong>：</p><ol><li>每增加一个产品，就要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖</li></ol><p><strong>使用场景</strong>：</p><ol><li>创建复杂对象：当创建的对象过于复杂设计多个步骤或者依赖其他对象时，工厂模式可以将创建过程封装在工厂类中，使客户端无需关心实例化过程</li><li>统一管理对象的创建：如果有多出需要创建统一类型的对象，可以使用工厂模式将对象的创建逻辑集中在一个工厂类中，方便管理和维护</li><li>创建对象时涉及依赖注入：在依赖注入的场景中，工厂模式可以以作为一个创建依赖对象的方式，确保依赖对象的正确创建和管理</li></ol><p><strong>注意事项</strong>：</p><ol><li>选择合适的工厂模式类型：<ul><li>简单工厂模式：用于创建一组相关对象，客户端只需知道产品的共同接口即可。</li><li>工厂方法模式：用于创建单个产品类型的对象，每个产品类型有一个对应的工厂类。</li><li>抽象工厂模式：用于创建多个相关对象的产品族，每个产品族有一个对应的工厂类。</li></ul></li><li>适当的封装和抽象：工厂模式应该将对象的创建过程封装在工厂类中，并通过接口或抽象类来定义产品的公共接口。这样可以降低客户端代码与具体类的耦合。</li><li>使用依赖注入：在可能的情况下，可以将工厂对象作为依赖注入到客户端中。这样可以使客户端代码更加灵活，能够在运行时替换不同的工厂实现。</li><li>工厂方法的扩展性：如果预计需要添加新的产品类型，确保每个产品类型都有对应的工厂类，并遵循开闭原则，即对修改关闭，对扩展开放。</li><li>不滥用工厂模式：不是所有情况下都需要使用工厂模式。对于简单的对象创建，直接使用构造函数可能更简单和直观。</li><li>适当的命名：工厂模式中的类名和方法名应该能够清晰地表达其用途，遵循良好的命名约定。</li><li>不要过度设计：只有在确实需要灵活的对象创建逻辑、需要将对象的创建与使用代码分离时，才应使用工厂模式。不要过度设计，避免增加不必要的复杂性。</li><li>使用单例模式慎重：在工厂模式中使用单例模式可能导致工厂本身成为全局状态，增加了代码的复杂性和难以测试性。除非明确需要，否则慎用单例模式。</li></ol><p><em><strong>实现</strong></em>：</p><p><img src="/posts/41682/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230726171305.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Factory.framework;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过抽象工厂模式，我们可以统一创建对象的方式</span></span><br><span class="line"><span class="comment"> * 类似模板模式，我们首先定义创建对象的骨架，然后允许子类通过特定方法来完成具体创建步骤</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="comment">// 通过工厂接口的create接口来创建实例，但是没有实现具体的创建过程</span></span><br><span class="line">    <span class="comment">// 创建对象的骨架</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Product <span class="title function_">create</span><span class="params">(String owner)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">p</span> <span class="operator">=</span> createProduct(owner);</span><br><span class="line">        registerProduct(p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体的创建过程交给实现抽象工厂</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Product <span class="title function_">createProduct</span><span class="params">(String owner)</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">registerProduct</span><span class="params">(Product product)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Factory.framework;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来表示产品的类，表示通过该流程创建出的对象应该具有什么样的的特点（接口）</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Factory.idcard;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产品包，有一个实现了抽象工厂的具体工厂</span></span><br><span class="line"><span class="comment"> * 此工厂实现了创建产品的特定步骤，能通过模板中的特定方法创建产品</span></span><br><span class="line"><span class="comment"> * 还有一个具体产品</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">import</span> Factory.framework.Product;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDCard</span> <span class="keyword">extends</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String owner;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IDCard</span><span class="params">(String owner)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;制作&quot;</span> + owner + <span class="string">&quot;的ID卡。&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.owner = owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用&quot;</span> + owner + <span class="string">&quot;的ID卡。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getOwner</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> owner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Factory.idcard;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Factory.framework.Factory;</span><br><span class="line"><span class="keyword">import</span> Factory.framework.Product;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDCardFactory</span> <span class="keyword">extends</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IDCard&gt; owners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Product <span class="title function_">createProduct</span><span class="params">(String owner)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IDCard</span>(owner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerProduct</span><span class="params">(Product product)</span> &#123;</span><br><span class="line">        owners.add((IDCard) product);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;IDCard&gt; <span class="title function_">getOwners</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> owners;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Factory.framework.Factory;</span><br><span class="line"><span class="keyword">import</span> Factory.framework.Product;</span><br><span class="line"><span class="keyword">import</span> Factory.idcard.IDCardFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IDCardFactory</span>();</span><br><span class="line">        <span class="type">Product</span> <span class="variable">c1</span> <span class="operator">=</span> factory.create(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="type">Product</span> <span class="variable">c2</span> <span class="operator">=</span> factory.create(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        <span class="type">Product</span> <span class="variable">c3</span> <span class="operator">=</span> factory.create(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        c1.use();</span><br><span class="line">        c2.use();</span><br><span class="line">        c3.use();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em><strong>解析</strong></em></p><p>工厂模式与模板模式类似但是他们的关注点是不同的</p><ul><li>模板模式主要用于定义算法骨架，在一组相关类中提取共同行为，将这些行为放在一个抽象类中，并允许子类通过实现特定方法来完成算法的具体步骤</li><li>工厂模式主要用于创建对象，客户端通过接口，而不是直接使用构造函数创建对象</li></ul><p>但他们都关注于封装和抽象，都是封装某种特定逻辑实现逻辑重用</p><p>在这个模式中，主要有四个角色</p><ul><li><p>Product（产品）</p><p>产品角色属于框架一方，它定义了在工厂模式中生成的实例应该具有什么样的行为，但是具体的行为则由实现它的子类去定义</p></li><li><p>Creator（创建者）</p><p>创建者属于框架这一方，它是负责生成Prodect角色的抽象类，但具体的处理则由子类角色进行实现，封装了创建产品的主要逻辑，他对实际生成的产品一无所知，他唯一知道的就是创建产品的过程和方法，不用new 关键字生成实例，而是调用生成实例的专用方法来生成实例，这样就可以防止父类和其他具体类耦合</p></li><li><p>ConcreteProduct（具体产品）</p><p>属于具体加工这一方，决定了具体产品</p></li><li><p>ConcreteCreator（具体创建者）</p><p>负责生成具体产品</p></li></ul><p>在这个模式中，如果我们要生成另外一个新的产品，只需创建一个新的包进行编写即可，无需对framework包进行任何修改，即不需要将另一个包引入到框架之中，也就是工厂包不依赖于产品包</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA编程思想</title>
      <link href="/posts/37186.html"/>
      <url>/posts/37186.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="对象入门"><a href="#对象入门" class="headerlink" title="对象入门"></a>对象入门</h1><p><em><strong>抽象的优势</strong></em></p><p>什么是面向对象</p><p>所有的编程语言的最终目的都是提供一种“抽象方法”，<strong>解决问题的复杂程度直接取决于抽象的问题种类及质量</strong>。汇编语言是对基础机器的少量抽象，命令式语言是对汇编语言的一种抽象，但是这些抽象原理依然需要我们着重考虑计算机的结构而非问题本身结构。而面向对象的程序设计则使我们可以使用一些工具表达问题空间内的元素。我们将问题空间中的元素以及他们在方案空间的表示物称为“对象”（Object）<strong>OOP允许我们根据问题来描述问题</strong>，<strong>在OOP中，我们将问题中的实体看作是对象，每个对象都有自己的属性（数据）和方法（行为）</strong>。而面向过程编程则更偏向于按照解决问题的步骤和流程来描述问题，它以过程或者函数为中心，强调问题的解决过程和步骤。在面向过程编程中，数据和函数是分开的，函数接收输入数据，进行一系列操作，然后返回结果，这种方式可能适合一些简单的线性的问题，但在处理复杂问题时，代码会变得冗长和难以维护，总结一下</p><ul><li>OOP允许我们根据问题来描述问题，通过对象的抽象和交互来建模。</li><li>面向过程编程更加强调按照步骤和流程来描述问题，以函数为中心。</li></ul><p><em><strong>面向对象的五大特征</strong></em></p><ul><li><p><strong>所有东西都是对象</strong>。可将对象看成是一种新型变量；它保存数据，但可要求它自身对自身进行操作。理论上讲，可从要解决的问题身上提出所有概念性的组件，然后在程序中将它表达为一个对象。</p></li><li><p><strong>程序是一大堆对象的组合</strong>；通过消息传递，对象知道自己该做些什么。为了向对象发出请求，需要向那个对象“发送一条消息”。可将消息想象为一个调用请求，它调用的是从所属目标对象的一个子例或函数</p></li><li><p><strong>每个对象都有自己的储存空间</strong>，可容纳其他对象。通过封装现有对象，可制作出新型对象（通过现有的零件，我们可以组装成不同的车辆）。</p></li><li><p><strong>每个对象都有一种类型</strong>。每个对象都是某个类的一个实例。Class 是和 Type 的同义词。<strong>一个类最重要的特征是，能将什么消息发给它</strong></p></li><li><p><strong>同一类的所有对象都能接收相同的消息</strong>。换一种理解，同意类的所有对象都能对他们发送相同的消息（调用相同的方法），让他们执行相同的行为，统一了对象之间的交互方式</p><p>PS：在面向对象语言中，调用一个方法可以理解问向对象发送了一条消息，能向对象发送什么消息由接口进行定义，或方法，方法是向对象外提供的接口，用于响应外部的请求和实现特定的行为</p></li></ul><p><em><strong>对象的接口</strong></em>（API）</p><p>在创建对象后，我们如何向对象发出请求，让他做一些实际的事情呢？每个对象仅能接收特定的请求，我们向对象发出的请求是通过它的接口定义的，对象的类型，或类则定义了它的接口形式；<strong>类型与接口的等价对应关系是面向对象程序设计的基础</strong></p><p><em><strong>实现方案的隐藏</strong></em></p><p><strong>为什么要控制对成员的访问</strong>：</p><ul><li>防止程序员接触他们不该接触的东西</li><li>允许库设计人员修改内部结构，不用担心它会对客户端造成什么影响</li></ul><p><strong>设置访问权限的关键字</strong>——访问修饰符</p><ul><li>public：该成员对所有类可见，包括其他包中的类</li><li>private：只对本类可见，其他类无法访问</li><li>protected：对本包中的类和其他包中该类的子类可见</li><li>friendly：对本包中的类可见，但其他包中的类不可见</li></ul><p><strong>类边界</strong>——用于泛型中设置泛型类型参数的类型范围</p><ul><li><p>extends：设置上界边界，限制泛型类型参数必须是指定类或者其他子类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T <span class="keyword">extends</span> <span class="title class_">SomeClass</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>super：设置下界边界，限制泛型类型参数必须是执行类或其父类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T <span class="built_in">super</span> SomeClass&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>默认为Object类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p><em><strong>方案的重用</strong></em></p><p>重复使用一个类，最简单的方法就是直接使用该类的对象，同时也能将那个类的一个对象置入一个新的对象，创建新类的时候，首先应考虑组织对象</p><p><em><strong>继承</strong></em>：重新使用接口</p><p><strong>继承的目标</strong>：直接利用现有的数据类型，对其进行克隆，再根据情况进行添加和修改，使用继承时，相当于创建了一个新类，这个心累不仅包含了现有类型的所有成员，也同时复制类基础类的接口。也就是说，可以向基础类的对向发送的消息也可以原样发送给衍生类的对象，也就是说<strong>衍生类具有于基础类相同的类型</strong></p><p><strong>如何区别新类于基础类</strong>：为衍生类添加 新函数（功能）、改变基础类一个现有函数的行为。（重写）</p><p><strong>等价与类似关系</strong>：如果基础类与衍生类之间只有重写关系，没有添加新的功能，那么我们就称这种关系为等价关系，例如：圆形就是一种几何形状，此时，我们可以完美的将新类型替换为基础类型。如果衍生类中有新的接口元素，此时我们虽然也可以将新类型替换为基础类型，但是我们无法在基础类型中访问新函数，此时这种替换并不完美，所以他们不是完全等价的</p><p><em><strong>多态</strong></em>：对象的互换使用</p><p>继承通常会导致一系列类建立在统一的接口基础上，对于这样的一系列类，我们可以将衍生类对象当作基础类的一个对象看待，统一他们的操作，忽略衍生类的特定细节，只与基础类打交道，使得程序更具有扩展性，这种类型处理的过程被称为Upcasting， 向上转型</p><p><strong>动态绑定</strong>：在我们给基础类引用发送消息的时候，它怎么会知道应该使用哪个衍生类型呢？通过多态，对于面向对象的程序设计语言来说，实现多态性的方法叫做”动态绑定“，编译器和运行期系统会负责对所有细节的控制，函数的动态绑定是自动进行的，我们无需关心</p><p><strong>抽象的基础类和接口</strong>：如果我们只希望基础类为自己的衍生类提供一个接口，只对向上转型称它，来使用他的接口，我们可以使用abstract关键字将他设置为一个抽象对象，也可以使用该关键字描述一个尚未实现的方法作为一个”根“使用，这说明这是用于从这个类继承的所有类型的一个接口函数，目前没有对他进行任何形式的实现，继承的类必须重写，否则也得设置为抽象类。interface关键字将抽象类的概念更延申了一部，它完全禁止所有的函数定义</p><p><em><strong>对象的创建和存在时间</strong></em></p><p>C++认为执行效率是最重要的一个问题，所以允许程序员自己做出选择对象的储存地点和存在时间</p><ul><li>在堆栈中创建，缺点，在编写程序时，必须知道对象的准确数量，存在时间以及类型；优点，编译器会自动判断对象的持续时间有多长，会自动破坏和清除对象</li><li>在内存池中动态创建，优点，创建十分灵活，想要就可以创建，缺点，内存分配储存空间的时间比在堆栈中创建的时间长很多（堆栈中创建一般只需将指针向上或向下易懂即可），由垃圾收集器进行破坏，会牺牲一定性能</li></ul><p><strong>单根结构</strong>：所有类都从单独的及一个基础类继承而来，Java的基础类为Object，优点为</p><ul><li>单根结构中所有对象都有一个通用的接口，最终都能归属于相同的类型</li><li>单根结构中所有的对象，都可以保证拥有一些特定的功能，一个单根结构，加上所有对象都在内存堆中创建，可以极大简化参数的传递，使用单根结构，可以方便的实现一个垃圾收集器</li><li>方便使用集合，容纳了Object的集合可以容纳任何东西，但是向下转型的时候要注意是否安全，或者使用泛型对集合进行限制</li></ul><p><strong>垃圾收集器</strong></p><p>垃圾收集器会自己知道一个对象在什么时候不再使用，然后会自动释放那个对象占据的内存空间，但是会付出一定性能的代价，并且由于在Java程序执行期间存在一种不连贯的因素，所以在某些特定的场合，我们必须避免使用它，比如在一个程序的执行必须保持稳定，连贯的时候</p><p><em><strong>违例控制</strong></em>：解决错误</p><p>Java的为例控制会保证为例不能被忽视，这与那些返回错误值不同，肯定能在某个地方得到处置，是必须使用的</p><p><em><strong>多线程</strong></em></p><p>在线程处理的时候，必须注意的一个问题：共享资源，如果有多个线程同时玉兴并且试图访问相同资源，那么一个线程可将资源锁定，在完成了他的任务后，再解开这个锁，让其他线程可以接着使用同样的资源，Java中的线程处理是在对象这一级支持的，所以一个线程可表示为一个对象，Java提供了有限资源的锁定方案，它能锁定任何对象占用的内存（内存实际是多种共享资源的一种），所以同一时间只能有一个线程使用特定的内存空间但是要实现Synchronized关键字</p><p><em><strong>设计Java程序步骤</strong></em></p><ol><li><p>明确制作内容，建立需求分析和系统规格</p><p>明确使用条件和应用场景，让程序知道需要做什么</p></li><li><p>明确设计方案，解释各类对象在外观上是什么样子，以及相互间是如何沟通的，可以使用（UML）语言进行建模，也可以对对象以及他们的接口进行文字化描述</p></li><li><p>开始创建</p></li><li><p>校订</p></li></ol><p><strong>命名空间</strong>：问题空间是指解决一个具体问题时所涉及到的所有可能情况和可行解的范围。</p><p><strong>组织</strong>：在现有类上组织一个新类，也称为包含关系</p><h1 id="一切都是对象"><a href="#一切都是对象" class="headerlink" title="一切都是对象"></a>一切都是对象</h1><p>Java是一种存粹的面向对象的程序设计语言，首先便假定了我们只希望进行面向对象的程序设计。尽管我们将一切都看作”对象“，但实际操纵的标识符却是指向对象的一个引用。引用不一定会有一个对应的对象与他连接，所以在创建一个引用的时候，我们无论如何也要对它进行初始化。如何创建一个对象呢？我们通常使用”new“关键字，创建一个对象，然后把他与一个引用相连。</p><p>程序保存数据的地方</p><ol><li>寄存器。最快的保存区域，但是我们没有直接控制权，也不能在程序中找到寄存器存在的痕迹</li><li>堆栈。驻留于常规RAM（随机访问储存器）区域，可通过它的堆栈指针获得处理的直接支持，堆栈指针若下移，则会创建新的内存，若上移，则会释放对应内存。缺点是Java编译器必须准确的知道堆栈内保存的所有数据的长度以及存在时间。这是由于它必须生成相应的代码以便向上和向下移动指针</li><li>堆。一种常规用途的内存池（也在RAM）区域，其中保存了Java对象，特点是编译器不须知道要从堆力分配多少储存空间，也不需要知道储存的诗句要在堆里停留多长时间。但是付出的代价则是分配储存空间会花费更长的时间</li><li>静态储存。位于固定位置，在程序运行期间，静态储存的数据将随时等候调用。但是对象本身永远也不会进入静态储存空间</li><li>常数储存。</li><li>非RAM储存。独立于一个程序之外，程序不运行时仍然存在，并在程序的控制范围之外</li></ol><p>Java中所有对象都是存储在堆中的，除了基本数据类型</p><p>对象本身不存在生命周期，只要我们愿意，就可以让他继续存在下去，一旦不被需要，就会自动被垃圾收集器自动回收，</p><p>对象方法的调用可以理解为，向一个对象发送一个消息</p><p>嵌入 式文档，使用javadoc命令，我们可以给一个项目快速生成可供阅读的html文档</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 一个类注释 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">docTest</span> &#123;</span><br><span class="line"><span class="comment">/** 一个变量注释 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> i;</span><br><span class="line"><span class="comment">/** 一个方法注释 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@see</span> 类名</span><br><span class="line"><span class="meta">@see</span> 完整类名</span><br><span class="line"><span class="meta">@see</span> 完整类名#方法名</span><br><span class="line">    </span><br><span class="line">会自动加入一个指向其他类文档的超链接</span><br></pre></td></tr></table></figure><p>类文档标记</p><blockquote><ol><li>@version<br>格式如下：<br>@version 版本信息<br>其中，“版本信息”代表任何适合作为版本说明的资料。若在 javadoc 命令行使用了“-version”标记，就<br>会从生成的 HTML 文档里提取出版本信息。</li><li>@author<br>格式如下：<br>@author 作者信息<br>其中，“作者信息”包括您的姓名、电子函件地址或者其他任何适宜的资料。若在javadoc 命令行使用了“-<br>author”标记，就会专门从生成的HTML 文档里提取出作者信息。<br>可为一系列作者使用多个这样的标记，但它们必须连续放置。全部作者信息会一起存入最终 HTML 代码的单独<br>一个段落里。</li></ol></blockquote><p>方法文档标记</p><blockquote><ol><li>@param 格式如下： 58 @param 参数名 说明 其中，“参数名”是指参数列表内的标识符，而“说明”代表一些可延续到后续行内的说明文字。一旦遇到 一个新文档标记，就认为前一个说明结束。可使用任意数量的说明，每个参数一个。 </li><li>@return 格式如下： @return 说明 其中，“说明”是指返回值的含义。它可延续到后面的行内。 </li><li>@exception 有关“违例”（Exception）的详细情况，我们会在第 9 章讲述。简言之，它们是一些特殊的对象，若某个方 法失败，就可将它们“扔出”对象。调用一个方法时，尽管只有一个违例对象出现，但一些特殊的方法也许 能产生任意数量的、不同类型的违例。所有这些违例都需要说明。所以，违例标记的格式如下： @exception 完整类名 说明 其中，“完整类名”明确指定了一个违例类的名字，它是在其他某个地方定义好的。而“说明”（同样可以 延续到下面的行）告诉我们为什么这种特殊类型的违例会在方法调用中出现。 </li><li>@deprecated 这是Java 1.1 的新特性。该标记用于指出一些旧功能已由改进过的新功能取代。该标记的作用是建议用户不 必再使用一种特定的功能，因为未来改版时可能摒弃这一功能。若将一个方法标记为@deprecated，则使用该 方法时会收到编译器的警告。</li></ol></blockquote><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><p>在Java中，标签（Label）是用于标识代码块的标识符。标签通常与循环语句（如for、while、do-while）和条件语句（如if、switch）一起使用，用于在嵌套结构中定位和跳转到特定的代码块。虽然标签在某些情况下可能会被认为是一种不推荐使用的控制流构造，但在特定的情况下，它们可以提供一种便捷的方式来实现控制流。</p><p>在Java中，标签的语法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy codelabelName: <span class="comment">// 冒号是标签语法的一部分</span></span><br><span class="line"><span class="comment">// 代码块</span></span><br></pre></td></tr></table></figure><p>以下是标签的几个重要用途：</p><ol><li>跳出多重循环：通过使用标签，我们可以从内部循环直接跳出外部循环，从而避免使用嵌套的控制语句。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy codeouterLoop: <span class="comment">// 标签名为outerLoop</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i * j &gt; <span class="number">12</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span> outerLoop; <span class="comment">// 直接跳出外部循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i * j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在嵌套循环中使用continue：通过标签，我们可以在嵌套循环中使用<code>continue</code>语句跳过特定的外部循环迭代。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy codeouterLoop: <span class="comment">// 标签名为outerLoop</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i * j % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span> outerLoop; <span class="comment">// 跳过当前外部循环的迭代</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i * j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，在使用标签时要谨慎。滥用标签可能会导致代码可读性下降，并且可能使代码更难维护。大多数情况下，使用传统的循环控制语句（如<code>break</code>和<code>continue</code>）已经足够了。只有在处理复杂的嵌套结构时，才建议使用标签。在一般情况下，合理设计程序逻辑可以避免过度使用标签。</p><h1 id="初始化和清理"><a href="#初始化和清理" class="headerlink" title="初始化和清理"></a>初始化和清理</h1><p>Java会在用户使用对象之前（即对象刚创建完成）自动调用对象的构造器方法，从而保证初始化，<strong>构造器存在的意义就是保证在使用对象之前它进行了正确的初始化</strong>。为了避免构造方法命名冲突，要求构造器与类名完全相同</p><p>Java创建对象的步骤</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>类加载：在Java程序中使用某个类之前，需要先将该类加载到Java虚拟机（JVM）中。类加载是Java的类加载器执行的过程，它负责查找类的字节码文件，并将其加载到内存中。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>类加载后，JVM会在内存中为该类分配空间，包括类的字段、方法和其他成员变量。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>对象实例化：当使用<span class="built_in">new</span>关键字创建对象时，JVM会在内存中分配一块空间，用于存储对象的实例变量和引用类型。对象实例化是通过调用类的构造方法来完成的。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>初始化：在对象实例化后，JVM会调用对象的构造方法来完成对象的初始化。构造方法负责对实例变量进行初始化，可以执行其他必要的操作。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>内存分配：在对象初始化完成后，对象所需的内存空间已经分配完毕，并且对象可以在堆内存中被访问和使用。</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>对象引用：在创建对象后，可以使用对象的引用来访问和操作该对象。引用是一个指向对象在内存中地址的变量，通过引用可以访问对象的成员和方法。</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>对象使用和销毁：通过引用可以使用对象的方法和成员变量。当对象不再被引用时，Java的垃圾回收机制会自动回收该对象所占用的内存空间，以便将其用于存储其他对象。</span><br></pre></td></tr></table></figure><p><strong>方法重载</strong></p><p>因为Java（c++）规定构造器方法必须与类相同，而我们又想通过不同方式创建要给对象，所以必须有方法重载，重载的每个方法都保证有一个独一无二的参数列表用于区分，且Java的重载与返回值无关</p><p><strong>无参构造器</strong></p><p>作用：创建“默认对象”</p><p>如果一个类中没有构造器，编译器会自动创建一个无参构造，如果类中有且只有一个带参构造，那么无法使用系统提供的无参构造</p><p><strong>this关键字</strong></p><p>this关键字只能在非静态方法内部引用。当调用一个对象的方法时，this生成了一个对象引用。主要功能是避免混淆。例如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">example</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">example</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="comment">// 这里的语句可以理解为 这个对象.a = a;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this关键字必须使用的场合</p><ol><li><p>方法形参与本类属性字段重名</p></li><li><p>在一些方法中，需要返回对象的引用</p></li><li><p>想在本类调用本类的构造方法</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">class person &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String id;</span><br><span class="line">    </span><br><span class="line">    public person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public person(String name, <span class="type">int</span> age, String id) &#123;</span><br><span class="line">        this(name);</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>static关键字</strong></p><p>static 是不依赖对象，而是依赖类创建的</p></li></ol><p><strong>垃圾回收器</strong></p><p>java 使用垃圾回收器来回收无用对象占用的内存，但是只会回收通过 new 关键字分配的内存（对于其他资源，比如网络连接，数据库连接，必须手动关闭），所以 java 允许在类中定义一个名为 finalize()的方法</p><p>finalize()方法</p><ol><li>垃圾回收（Garbage Collection）： Java中的垃圾回收机制负责自动释放不再使用的对象占用的内存。当对象不再被任何引用指向时，Java虚拟机会将其标记为垃圾对象，并在合适的时机进行垃圾回收操作，释放这些对象占用的内存。</li><li>finalize()方法的作用： <code>finalize()</code>方法是<strong>在对象被垃圾回收器回收之前，即对象被销毁之前调用的一个方法</strong>。该方法<strong>允许对象执行一些清理操作或资源释放工作</strong>。例如，可以在<code>finalize()</code>方法中关闭文件、释放网络连接、释放系统资源等。但是，由于垃圾回收的时间不确定，不能保证<code>finalize()</code>方法何时被调用。</li><li>finalize()方法的用法： 在旧版本的Java中，开发人员可以重写<code>finalize()</code>方法来实现对象的清理操作。但是，由于它不可预测性和垃圾回收的开销，从Java 9开始，<code>finalize()</code>方法被标记为过时。因此，不再推荐使用该方法来执行重要的资源释放操作。</li><li>代替方式： 推荐使用<code>try-with-resources</code>或手动调用资源释放方法来代替<code>finalize()</code>方法执行资源释放。<code>try-with-resources</code>是Java 7中引入的一种语法，用于自动关闭实现<code>AutoCloseable</code>接口的资源，例如IO流、数据库连接等。</li></ol><p>无论是**”垃圾回收”还是”终结”，都不保证一定会发生<strong>。如果 Java 虚拟机（JVM）并未面临内存耗尽的情形，它可能不会浪费时间执行垃圾回收以恢复内存。（这就是我算法题爆空间的原因？？？）</strong>所以如果在不再需要某个对象之前，如果必须执行某些操作，我们的自己去做，比如关闭资源**</p><p>Java的垃圾回收器能明显提高对象的创建速度。Java 从堆空间分配的速度可以和其他语言在栈上分配空间的速度相比</p><blockquote><p>你可以把 C++ 里的堆想象成一个院子，里面每个对象都负责管理自己的地盘。一段时间后，对象可能被销毁，但地盘必须复用。在某些 Java 虚拟机中，堆的实现截然不同：它更像一个传送带，每分配一个新对象，它就向前移动一格。这意味着对象存储空间的分配速度特别快。Java 的”堆指针”只是简单地移动到尚未分配的区域，所以它的效率与 C++ 在栈上分配空间的效率相当。当然实际过程中，在簿记工作方面还有少量额外开销，但是这部分开销比不上查找可用空间开销大。</p></blockquote><blockquote><p>当垃圾回收器工作时，一边回收内存，一边使堆中的对象紧凑排列，这样”堆指针”就可以很容易地移动到更靠近传送带的开始处，也就尽量避免了页面错误。垃圾回收器通过重新排列对象，实现了一种高速的、有无限空间可分配的堆模型。</p></blockquote><p><strong>垃圾回收机制有哪些</strong></p><ol><li>引用计数法（Reference Counting）： 引用计数法是一种简单的垃圾回收算法，它通过为每个对象维护一个引用计数器来判断对象是否可回收。当对象被引用时，计数器加1；当引用失效时，计数器减1。当计数器为0时，表示该对象不再被引用，可以被回收。然而，引用计数法容易出现循环引用的问题，导致无法正确回收循环引用的对象。</li><li>可达性分析算法（Reachability Analysis）： Java的主要垃圾回收机制是基于可达性分析的。该算法通过从一组称为”GC Roots”的根对象开始，遍历所有与根对象直接或间接可达的对象，将可达的对象视为存活对象，而不可达的对象被标记为垃圾对象，最后进行回收。常见的GC Roots包括静态变量、局部变量表、JNI引用等。Java虚拟机的垃圾回收器会周期性地执行可达性分析来回收无用的对象。</li><li>分代垃圾回收： 分代垃圾回收是一种优化策略，将堆内存划分为不同的代（Generation），通常分为新生代（Young Generation）和老年代（Old Generation）。由于新对象的生命周期较短，大部分对象在创建后很快就变得不可达。因此，新生代采用较短的垃圾回收周期和更快的回收算法。而老年代中的对象生命周期较长，因此采用更慢但更全面的垃圾回收算法。</li><li>垃圾回收器： Java虚拟机提供了不同类型的垃圾回收器，例如Serial Garbage Collector、Parallel Garbage Collector、CMS (Concurrent Mark-Sweep) Garbage Collector、G1 (Garbage-First) Garbage Collector等。这些回收器有不同的实现策略，适用于不同的应用场景和硬件配置。</li><li>System.gc()和Runtime.gc()： Java中可以通过<code>System.gc()</code>或<code>Runtime.gc()</code>方法建议垃圾回收器执行垃圾回收操作。但是，这只是建议，垃圾回收器是否真正执行垃圾回收依然由虚拟机决定，不一定会立即执行。</li></ol><p><strong>Java垃圾回收</strong></p><ol><li>垃圾回收机制：Java虚拟机使用可达性分析算法来进行垃圾回收。从一组称为”GC Roots”的根对象开始，遍历所有与根对象直接或间接可达的对象，将不可达的对象标记为垃圾对象，然后进行回收。这种机制解决了循环引用导致的问题。</li><li>分代垃圾回收：Java虚拟机将堆内存划分为不同的代，如新生代和老年代。新对象的生命周期较短，大部分对象在创建后很快就变得不可达，因此新生代采用较短的垃圾回收周期和更快的回收算法，而老年代中的对象生命周期较长，采用更慢但更全面的垃圾回收算法。</li><li>停止-复制（stop-and-copy）和标记-清扫（mark-and-sweep）：Java虚拟机中的垃圾回收器采用了自适应的垃圾回收技术，其中包括停止-复制和标记-清扫两种方式。停止-复制在回收时会暂停程序运行，将存活对象从当前堆复制到另一个堆，并整理对象排列。标记-清扫在回收时只标记存活对象，然后清理未标记的垃圾对象，但会导致堆空间碎片化。</li><li>分块（Chunking）：Java虚拟机中的内存分配以较大的块为单位，其中每个块有年代数来记录对象是否存活。这对处理大量短命的临时对象很有帮助。</li><li>即时编译器（JIT）：Java虚拟机中使用即时编译器来将部分或全部代码翻译成本地机器码，以提高运行速度。它可以采用惰性评估的方式，只在必要时才进行编译，避免不必要的编译开销和代码长度增加。</li></ol><p><strong>成员初始化</strong></p><p>Java可以保证所有变量在使用前都能得到恰当的初始化。对于方法的局部变量，这种保证会以编译错误的方式呈现</p><p>指定初始化</p><p>在定义的地方赋值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitialValues2</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">bool</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">    <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0xff</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">999</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">lng</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">3.14f</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3.14159</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Depth</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Measurement</span> &#123;</span><br><span class="line">    <span class="type">Depth</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Depth</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用方法来提供初始值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodInit</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> f();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法可以带有参数，但这些参数不能是未初始化的类成员变量。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodInit2</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> f();</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> g(i);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造器初始化</p><p>在使用构造器初始化的时候并不会影响编译器自动初始化，这能为“初始化”操作提供保证，他们会在任何方法（包括构造器）被调用之前得到初始化</p><p>静态数据的初始化</p><blockquote><p>无论创建多少个对象，静态数据都只占用一份存储区域。<strong>static</strong> 关键字不能应用于局部变量，所以只能作用于属性（字段、域）。如果一个字段是静态的基本类型，你没有初始化它，那么它就会获得基本类型的标准初值。如果它是对象引用，那么它的默认初值就是 <strong>null</strong>。</p></blockquote><p>静态初始化只有在有必要的时候才会进行，如果不创建某个对象，也没有引用静态变量，那么它永远不会被创建</p><p>对象创建过程，假设有个Dog类</p><ol><li>即使没有显式地使用 <strong>static</strong> 关键字，构造器实际上也是静态方法。所以，当首次创建 <strong>Dog</strong> 类型的对象或是首次访问 <strong>Dog</strong> 类的静态方法或属性时，Java 解释器必须在类路径中查找，以定位 <strong>Dog.class</strong>。</li><li>当加载完 <strong>Dog.class</strong> 后（后面会学到，这将创建一个 <strong>Class</strong> 对象），有关静态初始化的所有动作都会执行。因此，静态初始化只会在首次加载 <strong>Class</strong> 对象时初始化一次。</li><li>当用 <code>new Dog()</code> 创建对象时，首先会在堆上为 <strong>Dog</strong> 对象分配足够的存储空间。</li><li>分配的存储空间首先会被清零，即会将 <strong>Dog</strong> 对象中的所有基本类型数据设置为默认值（数字会被置为 0，布尔型和字符型也相同），引用被置为 <strong>null</strong>。</li><li>执行所有出现在字段定义处的初始化动作。</li><li>执行构造器。你将会在”复用”这一章看到，这可能会牵涉到很多动作，尤其当涉及继承的时候。</li></ol><p>显式静态初始化（使用静态代码块）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态代码块中的内容只执行一次：首次创建这个类的对象或者首次访问这个类的静态成员的时候</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Spoon</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">47</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非静态实例初始化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mug</span> &#123;</span><br><span class="line">    Mug(<span class="type">int</span> marker) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mug(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mugs</span> &#123;</span><br><span class="line">    Mug mug1;</span><br><span class="line">    Mug mug2;</span><br><span class="line">    &#123; <span class="comment">// [1]</span></span><br><span class="line">        mug1 = <span class="keyword">new</span> <span class="title class_">Mug</span>(<span class="number">1</span>);</span><br><span class="line">        mug2 = <span class="keyword">new</span> <span class="title class_">Mug</span>(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;mug1 &amp; mug2 initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mugs() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mugs()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mugs(<span class="type">int</span> i) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mugs(int)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside main()&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Mugs</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;new Mugs() completed&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Mugs</span>(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;new Mugs(1) completed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inside main</span><br><span class="line">Mug(1)</span><br><span class="line">Mug(2)</span><br><span class="line">mug1 &amp; mug2 initialized</span><br><span class="line">Mugs()</span><br><span class="line">new Mugs() completed</span><br><span class="line">Mug(1)</span><br><span class="line">Mug(2)</span><br><span class="line">mug1 &amp; mug2 initialized</span><br><span class="line">Mugs(int)</span><br><span class="line">new Mugs(1) completed</span><br></pre></td></tr></table></figure><p>看起来它很像静态代码块，只不过少了 <strong>static</strong> 关键字。这种语法对于支持”匿名内部类”的初始化是必须的，但是你也可以使用它保证某些操作一定会发生，而不管哪个构造器被调用。从输出看出，实例初始化子句是在两个构造器之前执行的。</p><p>数组初始化</p><p>Java编译器不允许指定数组大小，我们只有对数组的一个引用（你已经为该引用分配了足够的存储空间），但是还没有给数组对象本身分配任何空间，为了给数组创建相应的存储空间，必须写初始化表达式。</p><p>如果在编写程序时，不确定数组中需要多少个元素，可以直接使用new关键字在数组中创建元素</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line">public class ArrayNew &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        <span class="type">int</span>[] a;</span><br><span class="line">        Random rand = <span class="built_in">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        a = <span class="built_in">new</span> <span class="type">int</span>[rand.nextInt(<span class="number">20</span>)];</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;length of a = &quot;</span> + a.length);</span><br><span class="line">        System.out.<span class="built_in">println</span>(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变参数列表</p><p>可以以一种类似 C 语言中的可变参数列表（C 通常把它称为”varargs”）来创建和调用方法。这可以应用在参数个数或类型未知的场合。由于所有的类都最后继承于 <strong>Object</strong> 类，所以可以创建一个以 Object 数组为参数的方法，并像下面这样调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarArgs</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(Object[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj: args) &#123;</span><br><span class="line">            System.out.print(obj + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        printArray(<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="number">47</span>, (<span class="type">float</span>) <span class="number">3.14</span>, <span class="number">11.11</span>&#125;);</span><br><span class="line">        printArray(<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;);</span><br><span class="line">        printArray(<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="keyword">new</span> <span class="title class_">A</span>(), <span class="keyword">new</span> <span class="title class_">A</span>(), <span class="keyword">new</span> <span class="title class_">A</span>()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">47 3.14 11.11</span><br><span class="line">one two three</span><br><span class="line">A@15db9742 A@6d06d69c A@7852e922</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F; 上面方法 过时 最新版 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewVarArgs</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(Object... args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj: args) &#123;</span><br><span class="line">            System.out.print(obj + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Can take individual elements:</span></span><br><span class="line">        printArray(<span class="number">47</span>, (<span class="type">float</span>) <span class="number">3.14</span>, <span class="number">11.11</span>);</span><br><span class="line">        printArray(<span class="number">47</span>, <span class="number">3.14F</span>, <span class="number">11.11</span>);</span><br><span class="line">        printArray(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        printArray(<span class="keyword">new</span> <span class="title class_">A</span>(), <span class="keyword">new</span> <span class="title class_">A</span>(), <span class="keyword">new</span> <span class="title class_">A</span>());</span><br><span class="line">        <span class="comment">// Or an array:</span></span><br><span class="line">        printArray((Object[]) <span class="keyword">new</span> <span class="title class_">Integer</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 当具有可选的尾随参数时，这一特性会有帮助：</span></span><br><span class="line">        printArray(); <span class="comment">// Empty list is OK</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">47 3.14 11.11</span><br><span class="line">47 3.14 11.11</span><br><span class="line">one two three</span><br><span class="line">A@15db9742 A@6d06d69c A@7852e922</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F; 可变参数列表会使得重载方法更加复杂，可能很危险</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverloadingVarargs</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Character... args)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Character c: args) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span> + c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Integer... args)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer i: args) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Long... args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;third&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        f(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">        f(<span class="number">1</span>);</span><br><span class="line">        f(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        f(<span class="number">0</span>);</span><br><span class="line">        f(<span class="number">0L</span>);</span><br><span class="line">        <span class="comment">//- f(); // Won&#x27;s compile -- ambiguous</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">first a b c</span><br><span class="line">second 1</span><br><span class="line">second 2 1</span><br><span class="line">second 0</span><br><span class="line">third</span><br></pre></td></tr></table></figure><p>在这个代码中，如果我们调用不含参的f()编译器就会感到迷茫，可以通过在参数列表中添加一个非可变参数来解决这个问题</p><p>枚举类型enum</p><p>在Java中，枚举类型（Enumeration，简称Enum）是一种特殊的数据类型，用于定义一个有限且固定数量的常量集合。枚举类型在Java中是一种预定义的类，它可以包含常量和方法。</p><p>Java的枚举类型具有以下特点：</p><ol><li>定义枚举类型：使用<code>enum</code>关键字来定义枚举类型。枚举类型的定义通常位于类的内部，但也可以单独定义。枚举类型的名称应该以大写字母开头，多个单词使用大写字母和下划线分隔。</li><li>常量集合：枚举类型定义了一组常量，这些常量称为枚举常量。每个枚举常量都是枚举类型的一个实例，用逗号分隔，放在括号内部。枚举常量通常以全大写字母表示，多个单词使用大写字母和下划线分隔。</li><li>枚举类的实例：枚举类型在运行时只会被实例化一次，每个枚举常量都是枚举类型的实例。</li><li>默认方法：Java中的枚举类型可以包含字段、构造方法、方法和内部类。可以在枚举类型中定义普通方法，但不能在枚举类型中定义抽象方法。</li></ol><p>常搭配switch语句，简单示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Spiciness</span> &#123;</span><br><span class="line">    NOT, MILD, MEDIUM, HOT, FLAMING</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleEnumUse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Spiciness</span> <span class="variable">howHot</span> <span class="operator">=</span> Spiciness.MEDIUM;</span><br><span class="line">        System.out.println(howHot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// MEDIUM</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EnumOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Spiciness s: Spiciness.values()) &#123;</span><br><span class="line">            System.out.println(s + <span class="string">&quot;, ordinal &quot;</span> + s.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NOT, ordinal 0</span></span><br><span class="line"><span class="comment">MILD, ordinal 1</span></span><br><span class="line"><span class="comment">MEDIUM, ordinal 2</span></span><br><span class="line"><span class="comment">HOT, ordinal 3</span></span><br><span class="line"><span class="comment">FLAMING, ordinal 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Burrito</span> &#123;</span><br><span class="line">    Spiciness degree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Burrito</span><span class="params">(Spiciness degree)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.degree = degree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">describe</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;This burrito is &quot;</span>);</span><br><span class="line">        <span class="keyword">switch</span>(degree) &#123;</span><br><span class="line">            <span class="keyword">case</span> NOT:</span><br><span class="line">                System.out.println(<span class="string">&quot;not spicy at all.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MILD:</span><br><span class="line">            <span class="keyword">case</span> MEDIUM:</span><br><span class="line">                System.out.println(<span class="string">&quot;a little hot.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> HOT:</span><br><span class="line">            <span class="keyword">case</span> FLAMING:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;maybe too hot&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Burrito</span> <span class="variable">plain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Burrito</span>(Spiciness.NOT),</span><br><span class="line">        greenChile = <span class="keyword">new</span> <span class="title class_">Burrito</span>(Spiciness.MEDIUM),</span><br><span class="line">        jalapeno = <span class="keyword">new</span> <span class="title class_">Burrito</span>(Spiciness.HOT);</span><br><span class="line">        plain.describe();</span><br><span class="line">        greenChile.describe();</span><br><span class="line">        jalapeno.describe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This burrito is not spicy at all.</span></span><br><span class="line"><span class="comment">This burrito is a little hot.</span></span><br><span class="line"><span class="comment">This burrito is maybe too hot.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/posts/1079.html"/>
      <url>/posts/1079.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="一，计算机系统概述"><a href="#一，计算机系统概述" class="headerlink" title="一，计算机系统概述"></a>一，计算机系统概述</h3><h4 id="基本构成"><a href="#基本构成" class="headerlink" title="基本构成"></a><strong>基本构成</strong></h4><p><em><strong>处理器</strong></em>：控制计算机操作，执行数据处理功能</p><ul><li>处理器的一种功能是和储存器交换数据，因此，通常使用内部寄存器：<strong>内存地址寄存器（Memory Address Register, MBR）</strong>：用于确定下次读写数据的储存器地址；<strong>内存缓冲寄存器（Memory Buffer Register, MBR）</strong>，用于存放要写入储存器或从储存器中读取的数据；<strong>程序计数器（Program Counter, PC）</strong>保存下一次要去的指令地址；<strong>指令寄存器（Instruction Register, IR）</strong>包含确定处理器将要执行的操作的位，处理器解释指令并执行对应操作</li></ul><p><em><strong>内存</strong></em>：储存数据和程序，通常是易失性的</p><ul><li>内存模块有一组单元组成，这些单元由顺序编号的地址定义。</li></ul><p><em><strong>输入&#x2F;输出模块</strong></em>：在计算机和外部环境之间移动数据</p><ul><li>在外部设备与处理器和储存器之间传送数据，包含内存缓冲区，用于临时保存数据，直到他们被发送出去</li></ul><p><em><strong>系统总线</strong></em>：在处理器，内存和输入输出模块间提供通信的设施</p><h4 id="指令的执行"><a href="#指令的执行" class="headerlink" title="指令的执行"></a><strong>指令的执行</strong></h4><p><strong>指令周期</strong>：单个指令所需要的处理称为一个指令周期，非别为取址阶段和执行阶段</p><p><img src="/posts/1079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230719215449.png"></p><p><em><strong>指令分类</strong></em></p><ul><li>处理器-储存器</li><li>处理器-I&#x2F;O</li><li>数据处理</li><li>控制</li></ul><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p><strong>什么是中断</strong>：中断是最初是用于提高处理器效率的一种手段。能够更有效的使用处理器，利用中断功能，处理器可以在I&#x2F;O操作的执行过程中执行其他指令（多数I&#x2F;O设备都远慢于处理器）</p><p><strong>中断类别</strong></p><ol><li>程序中断</li><li>时钟中断</li><li>I&#x2F;O中断</li><li>硬件失效中断</li></ol><p><strong>中断控制流程</strong></p><p><img src="/posts/1079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230719222031.png"></p><p><img src="/posts/1079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230719222537.png"></p><p><img src="/posts/1079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230719222221.png"></p><p><strong>与指令周期的关系</strong>：为了适应中断产生的情况，在指令周期中要增加一个中断阶段</p><p>在中断阶段，处理器检查是否有中断信号，如果没有中断，处理器继续运行，如果有中断，则处理器挂起当前程序的执行，并执行一个中断处理程序，中断程序通常是操作系统的一部分，它确定中断性质，并执行所需的操作</p><p><img src="/posts/1079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230719222314.png"></p><p><strong>中断处理</strong>：</p><ol><li>发送一个中断信号</li><li>处理器在响应中断前结束当前指令的执行</li><li>处理器对中断进行测试，确定存在未响应的中断，并给提交中断的设备发送确认信号，确认信号允许该设备取消它的中断信号</li><li>处理器需要准备把控制权交给中断程序，保存从中断点恢复当前程序所需的信息</li><li>处理器把响应此中断的中断处理程序入口地址装入程序计数器</li><li>此时，与被中断程序相关的程序计数器和PSW被保存到系统栈中</li><li>中断处理程序开始处理中断</li><li>中断处理结束后，被保存的寄存器值从栈中释放并恢复到寄存器中</li><li>从栈中恢复PSW和程序计数器的值</li></ol><p><img src="/posts/1079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230719223333.png"></p><p>PS：中断不是程序调用中的一个历程，它可以在任何时候发生，它的发生是不可预测的</p><p><strong>多个中断</strong></p><p>多个中断处理有两个方法：</p><ul><li>正在处理一个中断时，禁止再发生中断</li><li>定义中断优先级，允许高优先级中断打断低优先级中断</li></ul><p><img src="/posts/1079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230719223615.png"></p><h4 id="储存器的层次结构"><a href="#储存器的层次结构" class="headerlink" title="储存器的层次结构"></a>储存器的层次结构</h4><p>计算机储存器的设计目标：容量，速度，价格</p><p><img src="/posts/1079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230719223735.png"></p><p><strong>局部性原理</strong>：程序访问内存和存储器时，倾向于以局部性的方式进行，即程序在某个时间段内往往只会访问内存中的一小部分数据，而不是整个内存空间。局部性原理包括时间局部性和空间局部性两个方面。</p><p>时间局部性指的是程序在某个时间段内对某个数据的访问往往会在不久后再次访问该数据，即程序具有重复的访问模式。例如，循环结构中的数据访问就具有时间局部性，因为在每次循环迭代时，程序会访问相同的数据。</p><p>空间局部性指的是程序在某个时间段内对某个数据的访问往往会连续地访问附近的数据，即程序具有空间上的连续访问模式。例如，数组访问就具有空间局部性，因为数组中的元素在内存中是连续存储的，程序在访问一个元素后，往往会接着访问相邻的元素。</p><p>非易失性外部储存器也被称为二级储存器或辅助储存器，其表现形式是程序员可以看到文件和记录（record）而不是单个字节或字（word）硬盘也可作为内存扩展即虚拟内存（virtual memory）</p><p>软件中还可以有效的增加额外的存储层次：一部分内容可以作为缓冲区（buffer）用于临时保存从磁盘中读出的数据。这种技术也被称为（disk cache）可以通过两种方法提高性能</p><ol><li>磁盘成簇读写。采用次数少，数据量大的传输方式</li><li>一些注定要写出（write-out）的数据也可能在储存到磁盘之前被程序访问，在这种情况下，可以将数据储存到软件设置的磁盘高速缓存中</li></ol><h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>处理器执行指令的速度，受储存周期的限制，高速缓存的目的是使访问速度接近现有的最快储存器，同时支持价格较低的大储存容量</p><p><img src="/posts/1079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230719230045.png"></p><p><strong>原理</strong>：</p><ol><li><em><strong>局部性原理</strong></em>：高速缓存利用局部性原理，即程序在某个时间段内倾向于重复访问相同的数据或指令。通过将这些<strong>数据和指令缓存在高速缓存</strong>中，可以<strong>减少对主内存的访问次数</strong>，提高访问速度。</li><li><em><strong>缓存映射</strong></em>：高速缓存通常采用缓存映射的方式来管理数据的存储和访问。常见的缓存映射方式包括<strong>直接映射</strong>、<strong>全相联映射</strong>和<strong>组相联映射</strong>。直接映射将主内存的每个数据块映射到缓存中的唯一位置，全相联映射将主内存的每个数据块映射到缓存中的任意位置，组相联映射将主内存的每个数据块映射到缓存中的一组位置。</li><li><em><strong>缓存替换策略</strong></em>：由于缓存容量有限，当缓存已满时，需要替换掉一部分数据，以便为新的数据腾出空间。常见的缓存替换策略包括最近最少使用（LRU）、先进先出（FIFO）和随机替换等。LRU策略根据数据的最近使用情况来进行替换，即替换最长时间未被使用的数据。</li><li><em><strong>缓存一致性</strong></em>：由于高速缓存和主内存是分离的存储器，可能会导致缓存与主内存中的数据不一致。为了保持一致性，需要采取一些机制来确保缓存中的数据与主内存中的数据保持同步，如写回和写直达等策略。</li></ol><p><img src="/posts/1079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230719230829.png"></p><p><img src="/posts/1079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230719230844.png"></p><p><strong>高速缓存设计</strong></p><p><img src="/posts/1079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230719231015.png"></p><ul><li>适度小的高速缓存会对性能产生明显的影响</li><li>块大小，高速缓存与内存间的数据交换单位，影响命中率，当从很小增长到大时，命中率增加，当从大增加到很大时，命中率减小</li><li>映射函数，读取一个块时，另一个块可能会被置换出高速缓存区，置换方法应尽可能减小置换出的块在不久后还会用到的可能性。映射函数越灵活，越有余地来设计增大命中率的置换算法，但是，映射函数越灵活，完成搜索以确定某个指定块是否位于高速缓存中的功能所需要的逻辑电路越复杂</li><li>置换算法，当高速缓存中的所有储存槽被其他块占满时，置换算法选择哪些在不久后被访问的可能性最小的块，通常办法是置换最长时间未被访问的块（最近最少使用，LRU算法）</li><li>写策略（write policy），规定何时发生储存器写操作，一种极端情况是，每当块被更新后就发生写操作，另一种极端情况是只有当块被置换时才发生写操作，但可能会使内存处于一种过时状态</li></ul><h4 id="直接内存读取"><a href="#直接内存读取" class="headerlink" title="直接内存读取"></a>直接内存读取</h4><p><strong>I&#x2F;O操作技术分类</strong></p><p>当处理器正在执行程序并遇到一个与I&#x2F;O相关的指令时，他会通过给相应的I&#x2F;O模块发命令来执行这个指令</p><ol><li><p>可编程I&#x2F;O</p><p>在执行I&#x2F;O命令时，不会通知处理器，不会中断处理器，因此处理器需要定期煎炒I&#x2F;O模块的状态来确定I&#x2F;O操作是否已经完成，处理器不断询问会降低系统性能</p></li><li><p>中断I&#x2F;O</p><p>接收命令后，执行命令，与处理器并行执行，当需要再次交换数据时，打断处理器的执行并请求服务，处理器和前面一样执行数据传送，然后恢复处理器以前的执行过程</p></li><li><p>直接内存存取（DMA）</p><p>移动大量数据时使用的更为有效的技术，DMA功能可以有系统总线中的一个独立模块完成，也可并入一个I&#x2F;O模块，DMA模块直接与储存器交互，传送整个数据块，一次传送一个字，传送过程不需要处理器参与，处理器只参与传送开始和结束部分，但是当处理器需要访问总线时，处理器的执行速度会变慢</p></li></ol><h4 id="多处理器和多核计算机的组织结构"><a href="#多处理器和多核计算机的组织结构" class="headerlink" title="多处理器和多核计算机的组织结构"></a>多处理器和多核计算机的组织结构</h4><p><strong>对称多处理器（SMP）</strong></p><p><img src="/posts/1079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230719234717.png"></p><p><img src="/posts/1079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230719234749.png"></p><p><img src="/posts/1079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230719234910.png"></p><p><img src="/posts/1079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230719235009.png"></p><p><strong>多核计算机</strong></p><p>多核（multi core）计算机是指将两个或多个处理器组装在同一块硅片上的计算机</p><h4 id="关键术语与课后练习"><a href="#关键术语与课后练习" class="headerlink" title="关键术语与课后练习"></a>关键术语与课后练习</h4><h3 id="二，操作系统概述"><a href="#二，操作系统概述" class="headerlink" title="二，操作系统概述"></a>二，操作系统概述</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>模运算与快速幂</title>
      <link href="/posts/4664.html"/>
      <url>/posts/4664.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="模运算与快速幂"><a href="#模运算与快速幂" class="headerlink" title="模运算与快速幂"></a>模运算与快速幂</h1><h2 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h2><p>定义 ： 求 a 除以 m 的余数</p><p>作用：缩小数值范围，常用于哈希计算</p><p>性质：</p><ul><li><p>（a + b）% m &#x3D;&#x3D; （a % m + b % m）% m; </p><p>如果没有限制a, b正负，符号可能相反，大小相差m</p></li><li><p>（a - b）% m &#x3D;&#x3D; ((a %m) - (b % m)) % m;</p><p>左右符号可能相反，大小相差m;</p></li><li><p>(a * b) % m &#x3D; ((a % m) * (b % m)) % m;</p><p>大数乘法使用此公式可能溢出</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">mod</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b, <span class="type">long</span> m)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化取模，防止溢出</span></span><br><span class="line">        a %= m;</span><br><span class="line">        b %= m;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当 b &gt; 0 时进行计算</span></span><br><span class="line">        <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断 b 的最低位是否为 1 ， 判断 b 是否为奇数</span></span><br><span class="line">            <span class="keyword">if</span> ((b &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 b 是奇数， 则 累加 a 到结果res 并取模</span></span><br><span class="line">                res = (res + a) % m;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将 a 更新为 a 的平法对 m 取模，相当于 a *= a 但进行了取模操作</span></span><br><span class="line">            a = (a + a) % m;</span><br><span class="line">            <span class="comment">// 将 b 右移一位，相当于将 b 除以 2 并向下取整</span></span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回 a 的 b 次幂，对 m 取模的结果</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>原理：将幂次b转换成二进制形式，通过按位运算来决定是否累乘对应的幂次，从而实现高效计算幂运算的目的</p><ol><li><p>幂次与二进制的关系</p><p>a ^ 11 &#x3D;&#x3D; a ^ 8 * a ^ 2 * a ^ 1;</p><p>其中所有幂次都是 2 的倍数 所有幂 a ^ i 都是倍乘关系，可以逐级递推</p></li><li><p>幂次用二进制分解</p><p>利用二进制的特征 11 &#x3D;&#x3D; 1011 &#x3D; 2 ^3 + 2 ^1 + 2 ^ 0</p><p>n &amp; 1 : 取 n 的最后一位，判断这一位是否需要跳过</p><p>n &gt;&gt;&#x3D; 1: 右移一位，把刚处理过的 n 的最后一位去掉</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重点回想，如何使用二进制数去表示一个正整数</span></span><br><span class="line"></span><br><span class="line"><span class="number">13</span> = <span class="number">8</span> + <span class="number">4</span> + <span class="number">1</span></span><br><span class="line">a ^ <span class="number">13</span> = a ^ <span class="number">8</span> + a ^ <span class="number">4</span> + a ^ <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无需求模</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">fastPow</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123; <span class="comment">// 判断是否为zu&#x27;cheng</span></span><br><span class="line">                <span class="comment">// 倍乘关系，逐级递推</span></span><br><span class="line">                ans *= a;</span><br><span class="line">            &#125;</span><br><span class="line">            a *= a;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需求模</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">fastPow1</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> n, <span class="type">long</span> m)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        a %= m;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                ans = (ans * a) % m;</span><br><span class="line">            &#125;</span><br><span class="line">            a = (a * a) % m;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/posts/23591.html"/>
      <url>/posts/23591.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="/posts/23591/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230625144943.png"></p><p>是操作关系型数据的API，是一套接口</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><img src="/posts/23591/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230625145606.png"></p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ol><li>DriverManager</li></ol><p><img src="/posts/23591/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230625152419.png"></p><p><img src="/posts/23591/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230625152435.png"></p><ol start="2"><li><p>Connection</p><p><img src="/posts/23591/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230629082935.png"></p><p><img src="/posts/23591/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230629083024.png"></p></li><li><p>Statement</p><p><img src="/posts/23591/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230629083855.png"></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="/posts/52560.html"/>
      <url>/posts/52560.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/posts/24227.html"/>
      <url>/posts/24227.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623124242.png"></p><h1 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h1><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623124409.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623124504.png"></p><h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><ul><li><p>继承Thread类，重写 run方法</p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623125323.png"></p></li><li><p>实现Runnable接口</p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623130314.png"></p></li><li><p>Callable 和 Future</p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623130541.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623130738.png"></p></li></ul><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623130801.png"></p><h1 id="线程常见成员方法"><a href="#线程常见成员方法" class="headerlink" title="线程常见成员方法"></a>线程常见成员方法</h1><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623130917.png"></p><h1 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h1><p>线程的调度</p><ul><li>抢占式调度：随机</li><li>非抢占式调度：一条线程一次</li></ul><p>Java为抢占式调度，线程优先级越大，执行的次数越大，默认优先级为 5 </p><h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><p>当其他的非守护线程执行完毕之后，守护线程会陆续结束</p><h1 id="出让线程和插入线程"><a href="#出让线程和插入线程" class="headerlink" title="出让线程和插入线程"></a>出让线程和插入线程</h1><p>yield出让当前CPU的执行权，但是依然会再次抢夺</p><p>join将某个线程插入到某个线程之前</p><h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623133152.png"></p><h1 id="线程的安全问题"><a href="#线程的安全问题" class="headerlink" title="线程的安全问题"></a>线程的安全问题</h1><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623133512.png"></p><p>相同票出现多次</p><p>出现超出范围的票</p><p>线程在执行代码的时候随时有可能被抢走执行权</p><h1 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h1><p>把操作共享数据的代码锁起来</p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623133912.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623134054.png"></p><p>要注意锁的位置，锁对象唯一，可以用奔类的字节码对象</p><h1 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h1><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623134440.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623134843.png"></p><p>StringBulider线程不安全</p><p>StringBuffer线程安全</p><h1 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h1><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623135939.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623140250.png"></p><p>程序没有正常结束被锁未被打开剩余线程都被挡在外面</p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623140350.png"></p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623140541.png"></p><h1 id="生产者和消费者（等待唤醒机制）"><a href="#生产者和消费者（等待唤醒机制）" class="headerlink" title="生产者和消费者（等待唤醒机制）"></a>生产者和消费者（等待唤醒机制）</h1><p>消费者等待 -&gt; 唤醒</p><p>生产者等待 -&gt; 唤醒</p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623141143.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623141201.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623141700.png"></p><p>消费者代码实现</p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623141858.png"></p><p>生产者代码实现</p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623142115.png"></p><h1 id="阻塞队列实现等待唤醒机制"><a href="#阻塞队列实现等待唤醒机制" class="headerlink" title="阻塞队列实现等待唤醒机制"></a>阻塞队列实现等待唤醒机制</h1><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623142255.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623142337.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623142750.png"></p><h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623143044.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623143210.png"></p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623145215.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623145400.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623145440.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623145501.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623145625.png"></p><p>创建自定义线程池</p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623153747.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623153943.png"></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623154259.png"></p><p><strong>最大并行数</strong></p><p><img src="/posts/24227/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623154856.png" alt="16"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>I/O</title>
      <link href="/posts/4748.html"/>
      <url>/posts/4748.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="I-x2F-O流"><a href="#I-x2F-O流" class="headerlink" title="I&#x2F;O流"></a>I&#x2F;O流</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>读取和存储数据的解决方案</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620181736.png"></p><h2 id="IO流的体系结构"><a href="#IO流的体系结构" class="headerlink" title="IO流的体系结构"></a>IO流的体系结构</h2><img src="/posts/4748/微信截图_20230620181845.png" style="zoom:50%;"><h4 id="底层输入输出流"><a href="#底层输入输出流" class="headerlink" title="底层输入输出流"></a>底层输入输出流</h4><p>在 Java 中，底层输入流（即直接从 I&#x2F;O 源读取数据的流）主要有以下几种：</p><ol><li><strong>FileInputStream</strong>：这是用于从文件中读取数据的输入流。它是一种字节流，可以用于读取任何类型的文件，包括二进制文件和文本文件。</li><li><strong>ByteArrayInputStream</strong>：这是用于从字节数组中读取数据的输入流。</li><li><strong>PipedInputStream</strong>：这是用于从与之相关联的 <code>PipedOutputStream</code> 中读取数据的输入流。</li><li><strong>ObjectInputStream</strong>：这是用于从输入流中读取对象的输入流。这个输入流必须连接到一个 <code>ObjectOutputStream</code>。</li><li><strong>SequenceInputStream</strong>：这是一种组合多个 <code>InputStreams</code> 的输入流，可以将两个或多个输入流串联起来，就像它们是一个单一的输入流一样。</li></ol><p>对应的，底层输出流（即直接写入到 I&#x2F;O 目标的流）主要有以下几种：</p><ol><li><strong>FileOutputStream</strong>：这是用于向文件中写入数据的输出流。它是一种字节流，可以用于写入任何类型的文件，包括二进制文件和文本文件。</li><li><strong>ByteArrayOutputStream</strong>：这是用于向字节数组中写入数据的输出流。</li><li><strong>PipedOutputStream</strong>：这是用于向与之相关联的 <code>PipedInputStream</code> 中写入数据的输出流。</li><li><strong>ObjectOutputStream</strong>：这是用于向输出流中写入对象的输出流。这个输出流必须连接到一个 <code>ObjectInputStream</code>。</li><li><strong>PrintStream</strong>：这是一种方便的输出流，用于写入表示各种数据值的方法。例如，它是 <code>System.out</code> 和 <code>System.err</code> 输出流的类型。</li></ol><p>每种输入流都有一种或多种对应的输出流，它们通常能处理相同类型的数据和相同的数据源或数据目标。例如，<code>FileInputStream</code> 和 <code>FileOutputStream</code> 都是用于处理文件的，而 <code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code> 都是用于处理对象的。</p><h4 id="高级流"><a href="#高级流" class="headerlink" title="高级流"></a>高级流</h4><p>与底层输入&#x2F;输出流对应的高级流是什么。高级流也被称为<strong>处理流</strong>，它的作用是对底层的输入&#x2F;输出流进行处理，提供更高级的读写功能。</p><ol><li><strong>BufferedInputStream</strong> 和 <strong>BufferedOutputStream</strong>：这两种流提供了缓冲区，可以减少实际的磁盘操作次数，从而提高读写的效率。</li><li><strong>DataInputStream</strong> 和 <strong>DataOutputStream</strong>：这两种流提供了可以读写基本数据类型（如 int、double、boolean 等）和 UTF 字符串的方法。</li><li><strong>ObjectInputStream</strong> 和 <strong>ObjectOutputStream</strong>：这两种流提供了可以读写序列化对象的方法。请注意，尽管 <code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code> 也可以看作是底层流，但它们同时也是高级流，因为它们处理的是对象而不是原始字节。</li><li><strong>InputStreamReader</strong> 和 <strong>OutputStreamWriter</strong>：这两种流提供了字节和字符之间的转换。<code>InputStreamReader</code> 是从字节输入流到字符输入流的桥梁，而 <code>OutputStreamWriter</code> 是从字符输出流到字节输出流的桥梁。它们允许程序以字符为单位读写数据，而不仅仅是字节。</li><li><strong>BufferedReader</strong> 和 <strong>BufferedWriter</strong>：这两种流也提供了缓冲区，和 <code>BufferedInputStream</code> 及 <code>BufferedOutputStream</code> 类似。但它们处理的是字符数据而不是字节数据。此外，<code>BufferedReader</code> 还提供了一种方便的方法 <code>readLine()</code>，用于读取一行数据。</li><li><strong>PrintWriter</strong>：这是一种方便的字符输出流，提供了各种 print 和 println 方法，用于写入各种数据值。</li></ol><p>以上就是一些常见的高级输入&#x2F;输出流。这些流通常包装一个底层流，对其进行处理，提供更高级的读写功能。</p><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><h4 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h4><p>这是所有字节输入流的父类，定义了字节输入流的基本共性功能方法，是一个抽象类</p><h5 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h5><p>从文件中读取字节</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620184032.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620184137.png"></p><p><strong>细节</strong></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620184932.png"></p><ul><li>读不到文件中的 -1</li></ul><p> <strong>循环读取</strong></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620185131.png"></p><p><strong>一次读取多个字节</strong></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620185857.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620190540.png"></p><p>改进版本</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620190700.png"></p><p>用来装饰其他的输入流，他可以从字节流中读取基本的数据类型</p><p>异常处理</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620191203.png"></p><p>防止资源没有被及时释放</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620191712.png"></p><h5 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h5><p><code>BufferedInputStream</code> 是一种具有缓冲功能的字节输入流，它的设计主要目的是为了提高读取数据的效率。在读取数据时，<code>BufferedInputStream</code> 会一次性读取较大的数据块（即填充其内部的缓冲区），然后我们可以逐个字节地从缓冲区中读取数据，避免频繁的物理磁盘操作。</p><ul><li><code>public BufferedInputStream(InputStream in)</code>：创建一个新的缓冲输入流，以从指定的底层输入流中读取数据。</li><li><code>public BufferedInputStream(InputStream in, int size)</code>：创建一个新的缓冲输入流，以从指定的底层输入流中读取数据，并具有指定的缓冲区大小。</li><li><code>public synchronized int read()</code>：从输入流中读取数据的下一个字节。</li><li><code>public synchronized int read(byte[] b, int off, int len)</code>：从输入流中读取一定数量的字节，并将其存储在缓冲区数组 <code>b</code> 中。</li></ul><p>使用 <code>BufferedInputStream</code> 时的注意事项：</p><ul><li>在进行大量的读取操作时，使用 <code>BufferedInputStream</code> 比使用非缓冲的 <code>InputStream</code> 更有效率，因为它可以减少实际的磁盘操作次数。</li><li>读取完数据后，应该及时关闭 <code>BufferedInputStream</code>。虽然垃圾回收器最终会关闭这些流，但是为了更好的资源管理和避免文件锁定等问题，我们应该在代码中显式关闭这些流。</li></ul><h5 id="DataInputStream"><a href="#DataInputStream" class="headerlink" title="DataInputStream"></a>DataInputStream</h5><p>用来装饰其它输入流，它可以从流中读取基本数据类型的数据。</p><h4 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h4><p>所有输出流的父类是抽象类</p><h5 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h5><p>向文件中写入字节</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620181955.png"></p><p><strong>使用</strong></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620182141.png"></p><p><strong>细节</strong></p><ul><li><p>参数可为文件路径或者File对象</p></li><li><p>如果文件不存在会创建新文件，必须保证父级路径存在</p></li><li><p>如果文件已经存在，构造方法会清空文件</p></li><li><p>write的方法参数为整数，实际上是写他ASCII码对应的字符</p></li><li><p>每次使用完之后都要释放资源</p></li></ul><p><strong>写出数据的</strong>3种方式</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620182921.png"></p><ul><li><p>如何换行</p><p>系统不同，换行符不同</p><p>windows \r\n</p><p>linux \n</p><p>mac \r</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620183608.png"></p></li><li><p>如何续写</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620183829.png"></p></li></ul><h5 id="BufferedOutputStream"><a href="#BufferedOutputStream" class="headerlink" title="BufferedOutputStream"></a>BufferedOutputStream</h5><p><code>BufferedOutputStream</code> 是一种具有缓冲功能的字节输出流。在写入数据时，<code>BufferedOutputStream</code> 不会每写入一个字节就直接写入到磁盘，而是首先将这些字节写入到内部的缓冲区。只有当缓冲区满，或者调用了 <code>flush()</code> 方法，或者关闭了流时，才会将缓冲区中的数据一次性写入到磁盘。这可以减少实际的磁盘操作次数，从而提高写入数据的效率。</p><p>一些常见的方法包括：</p><ul><li><code>public BufferedOutputStream(OutputStream out)</code>：创建一个新的缓冲输出流，以将数据写入指定的底层输出流。</li><li><code>public BufferedOutputStream(OutputStream out, int size)</code>：创建一个具有指定缓冲区大小的新缓冲输出流，以将数据写入特定的底层输出流。</li><li><code>public synchronized void write(int b)</code>：将指定的字节写入此缓冲的输出流。</li><li><code>public synchronized void write(byte[] b, int off, int len)</code>：将指定的字节从偏移量 <code>off</code> 开始的 <code>len</code> 字节写入此缓冲的输出流。</li><li><code>public synchronized void flush()</code>：清空此缓冲的输出流，确保所有缓冲的输出字节被写出到目标。</li></ul><p>使用 <code>BufferedOutputStream</code> 时的注意事项：</p><ul><li>在进行大量的写入操作时，使用 <code>BufferedOutputStream</code> 比使用非缓冲的 <code>OutputStream</code> 更有效率，因为它可以减少实际的磁盘操作次数。</li><li>在写入数据后，应该调用 <code>flush()</code> 方法，以确保所有的数据都被写入到磁盘。否则，如果缓冲区未满，那么缓冲区中的数据可能不会被写入到磁盘。</li><li>写入完数据后，应该及时关闭 <code>BufferedOutputStream</code>。虽然垃圾回收器最终会关闭这些流，但是为了更好的资源管理和避免文件锁定等问题，我们应该在代码中显式关闭这些流。</li></ul><h5 id="DataOutputStream"><a href="#DataOutputStream" class="headerlink" title="DataOutputStream"></a>DataOutputStream</h5><p>用来装饰其它输出流，它可以向流中写入基本数据类型的数据。</p><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>某种程度上来说，字符流跟字节流及其相似，包括他们的使用事项和包含的方法，不同的是字符流主要只针对字符</p><h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620191713.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622181610.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622181804.png"></p><p>以一开头，与英文区分开</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622182026.png"></p><p><strong>小结</strong></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622182101.png"></p><p><strong>Unicode</strong></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622182304.png"></p><p>空间浪费太过严重，所以使用UTF-8</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622182449.png"></p><p>UTF-8不是字符集，是Unicode字符集的一种编码方式</p><p><strong>为什么会有乱码</strong></p><p>读取数据时未读取完整个汉字</p><p>编码和解码的方式不统一</p><p><strong>避免乱码</strong>，不要使用字节流读取文本文件，解码编码使用同一个码表，同一个编码方式</p><p><strong>Java编码和解码的实现</strong></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622183217.png"></p><p>根据字符集的编码方式进行操作，主要针对纯文本文件</p><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><h5 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h5><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622205058.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622205115.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622205148.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622205540.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622205319.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622205453.png"></p><p>强转为Char</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622205659.png" alt="带参read"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622205940.png"></p><h5 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h5><p><code>BufferedReader</code> 是一种具有缓冲功能的字符输入流，它的工作原理和 <code>BufferedInputStream</code> 非常相似，不同的是 <code>BufferedReader</code> 是处理字符数据的。</p><p>一些常见的方法包括：</p><ul><li><code>public BufferedReader(Reader in)</code>：创建一个新的缓冲阅读器，以从指定的底层阅读器中读取数据。</li><li><code>public BufferedReader(Reader in, int size)</code>：创建一个新的缓冲阅读器，以从指定的底层阅读器中读取数据，并具有指定的缓冲区大小。</li><li><code>public String readLine()</code>：读取一个文本行。如果到达流末尾而没有更多的数据，则返回 null。</li><li><code>public int read(char[] cbuf, int off, int len)</code>：从输入流中读取一定数量的字符，并将其存储在缓冲区数组 <code>cbuf</code> 中。</li></ul><p>使用 <code>BufferedReader</code> 时的注意事项：</p><ul><li>在读取字符数据时，使用 <code>BufferedReader</code> 比使用非缓冲的 <code>Reader</code> 更有效率，特别是在读取大文件时。</li><li><code>BufferedReader</code> 提供了 <code>readLine()</code> 方法，这对于读取文本文件非常有用，因为这个方法可以一次读取一整行的数据。</li><li>读取完数据后，应该及时关闭 <code>BufferedReader</code>。虽然垃圾回收器最终会关闭这些流，但是为了更好的资源管理和避免文件锁定等问题，我们应该在代码中显式关闭这些流。</li></ul><h5 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h5><p>是从字节流到字符流的桥梁，它读取字节，并使用指定的字符集将其解码为字符。</p><p><code>InputStreamReader</code> 是字节流通向字符流的桥梁。它使用指定的字符集读取字节并将其解码为字符。它的字符集可以由名称指定，也可以明确地给定，或者可以接受平台默认的字符集。</p><p>底层原理：<code>InputStreamReader</code> 在内部使用了一个字节输入流和一个字符解码器。当我们读取字符时，<code>InputStreamReader</code> 首先使用字节输入流从磁盘读取字节，然后再使用字符解码器将这些字节解码为字符。</p><p>一些常见的方法包括：</p><ul><li><code>public InputStreamReader(InputStream in)</code>：创建一个使用默认字符集的 InputStreamReader。</li><li><code>public InputStreamReader(InputStream in, String charsetName)</code>：创建使用指定字符集的 InputStreamReader。</li><li><code>public int read()</code>：读取单个字符。</li><li><code>public int read(char[] cbuf, int off, int len)</code>：将字符读入数组的一部分。</li><li><code>public void close()</code>：关闭流。</li></ul><p>使用 <code>InputStreamReader</code> 时的注意事项：</p><ul><li>在创建 <code>InputStreamReader</code> 时，应明确指定字符集。如果不指定字符集，那么 <code>InputStreamReader</code> 将使用平台默认的字符集，这可能会导致在不同平台或者不同地区的计算机上出现不一致的行为。</li><li>读取完数据后，应该及时关闭 <code>InputStreamReader</code>。虽然垃圾回收器最终会关闭这些流，但是为了更好的资源管理和避免文件锁定等问题，我们应该在代码中显式关闭这些流。</li></ul><h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><h5 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h5><p>构造方法</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622210021.png"></p><p>成员方法</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622210046.png"></p><p>细节</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622210125.png"></p><p>底层原理</p><p>缓冲区：加速读取效率，不用每次都从原位置获取</p><p>虽然存在缓冲机制，但是并不是缓冲流</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622210849.png"></p><p>每次读取的时候，都先判断缓冲区中是否有数据可以读取，如果有，直接读取，如果没有从数据源中传输数据尽可能填满缓冲区，再从缓冲区读取</p><p><strong>字节流没有缓冲区</strong></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622211219.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622212215.png" alt="相当细节"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622212523.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622212553.png"></p><p>只有在缓冲区满的时候才能把数据送往目的地，但是flush可以直接把数据送往目的地，无论缓冲区是否为满</p><h5 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h5><p><code>BufferedWriter</code> 是一种具有缓冲功能的字符输出流，它的工作原理和 <code>BufferedOutputStream</code> 类似，不同的是 <code>BufferedWriter</code> 是处理字符数据的。</p><p>一些常见的方法包括：</p><ul><li><code>public BufferedWriter(Writer out)</code>：创建一个使用默认大小输出缓冲区的缓冲字符输出流。</li><li><code>public BufferedWriter(Writer out, int sz)</code>：创建一个新的缓冲字符输出流，使用给定大小的输出缓冲区。</li><li><code>public void write(int c)</code>：写入单个字符。</li><li><code>public void write(char[] cbuf, int off, int len)</code>：写入字符数组的一部分。</li><li><code>public void write(String s, int off, int len)</code>：写入字符串的一部分。</li><li><code>public void newLine()</code>：写入一个行分隔符。行分隔符字符串由系统属性 <code>line.separator</code> 定义，并且不一定是单个新行字符 (‘\n’)。</li><li><code>public void flush()</code>：刷新流。</li><li><code>public void close()</code>：关闭流，先刷新它。</li></ul><p>使用 <code>BufferedWriter</code> 时的注意事项：</p><ul><li>在写入字符数据时，使用 <code>BufferedWriter</code> 比使用非缓冲的 <code>Writer</code> 更有效率，特别是在写入大量数据时。</li><li>在写入数据后，应该调用 <code>flush()</code> 方法，以确保所有的数据都被写入到磁盘。否则，如果缓冲区未满，那么缓冲区中的数据可能不会被写入到磁盘。</li><li>写入完数据后，应该及时关闭 <code>BufferedWriter</code>。虽然垃圾回收器最终会关闭这些流，但是为了更好的资源管理和避免文件锁定等问题，我们应该在代码中显式关闭这些流。</li></ul><h5 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h5><p>是从字符流到字节流的桥梁，它使用指定的字符集将字符编码为字节。</p><p><code>OutputStreamWriter</code> 是一个字符流到字节流的桥梁。它使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以明确地给定，或者可以接受平台默认的字符集。</p><p>底层原理：<code>OutputStreamWriter</code> 在内部使用了一个字节输出流和一个字符编码器。当我们写入字符时，<code>OutputStreamWriter</code> 首先使用字符编码器将字符转换为字节，然后再使用字节输出流将这些字节写入到磁盘。</p><p>一些常见的方法包括：</p><ul><li><code>public OutputStreamWriter(OutputStream out)</code>：创建使用默认字符编码的 OutputStreamWriter。</li><li><code>public OutputStreamWriter(OutputStream out, String charsetName)</code>：创建使用指定字符集的 OutputStreamWriter。</li><li><code>public void write(int c)</code>：写入单个字符。</li><li><code>public void write(char[] cbuf, int off, int len)</code>：写入字符数组的一部分。</li><li><code>public void write(String str, int off, int len)</code>：写入字符串的一部分。</li><li><code>public void flush()</code>：刷新流。</li><li><code>public void close()</code>：关闭流。</li></ul><p>使用 <code>OutputStreamWriter</code> 时的注意事项：</p><ul><li>在创建 <code>OutputStreamWriter</code> 时，应明确指定字符集。如果不指定字符集，那么 <code>OutputStreamWriter</code> 将使用平台默认的字符集，这可能会导致在不同平台或者不同地区的计算机上出现不一致的行为。</li><li>在写入数据后，应该调用 <code>flush()</code> 方法，以确保所有的数据都被写入到磁盘。</li><li>写入完数据后，应该及时关闭 <code>OutputStreamWriter</code>。虽然垃圾回收器最终会关闭这些流，但是为了更好的资源管理和避免文件锁定等问题，我们应该在代码中显式关闭这些流。</li></ul><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622221034.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622221129.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622221235.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622221302.png"></p><h4 id="InputStreamReader-1"><a href="#InputStreamReader-1" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h4><h4 id="OutputStreamReader"><a href="#OutputStreamReader" class="headerlink" title="OutputStreamReader"></a>OutputStreamReader</h4><h3 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h3><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622222950.png"></p><p>序列化流，可以把Java对象写到本地文件当中，反序列化流，从本地文件中读取J序列化ava对象</p><h4 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h4><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622223712.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622223800.png"></p><h4 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h4><p>不能直接写出，要实现Serializable接口，此接口中没有抽象方法，为标记型接口，一旦实现这个接口，则表示当前对象可以被序列化</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622223226.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622223642.png"></p><p>细节</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622225814.png"></p><p>反序列化时，注意版本号</p><p>transient：瞬态关键字，不会把当前对象序列化到本地文件中</p><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><img src="/posts/4748/微信截图_20230622225909.png" style="zoom:50%;"><h4 id="PintStream"><a href="#PintStream" class="headerlink" title="PintStream"></a>PintStream</h4><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622230041.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622230149.png"></p><h4 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h4><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622230904.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622230924.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622230942.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622231602.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622230016.png"></p><h3 id="压缩流"><a href="#压缩流" class="headerlink" title="压缩流"></a>压缩流</h3><p>Java只能识别zip，其中为zipEntry对象</p><p>无需递归，只需循环，不断在循环中操作entry对象</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623101324.png" alt="解压"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623102200.png" alt="压缩单个文件"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623102824.png" alt="压缩文件夹"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623103344.png"></p><h3 id="Commons-io"><a href="#Commons-io" class="headerlink" title="Commons-io"></a>Commons-io</h3><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623103510.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623103611.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623103627.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623103959.png"></p><h3 id="Hutool"><a href="#Hutool" class="headerlink" title="Hutool"></a>Hutool</h3><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623104715.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230623104737.png"></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h2><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620185627.png" alt="小文件"></p><p>一次只读写一个字节，非常慢，改进</p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230620190952.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622213400.png"></p><h2 id="文件加密"><a href="#文件加密" class="headerlink" title="文件加密"></a>文件加密</h2><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622213609.png"></p><h2 id="修改文件数据"><a href="#修改文件数据" class="headerlink" title="修改文件数据"></a>修改文件数据</h2><p><img src="/posts/4748/"><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622213641.png" alt="微信截图_20230622213641"></p><h2 id="转换流-1"><a href="#转换流-1" class="headerlink" title="转换流"></a>转换流</h2><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622221444.png" alt="按照指定的方案读入和按照指定的方法写出数据"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622221454.png"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622221840.png" alt="利用转换流，可以按指定编码格式读取数据"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622222154.png" alt="掌握"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622222326.png" alt="也被替代了"></p><p><img src="/posts/4748/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230622222456.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>File类</title>
      <link href="/posts/11300.html"/>
      <url>/posts/11300.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[toc]</p><h1 id="File"><a href="#File" class="headerlink" title="File"></a>File</h1><h2 id="File是什么"><a href="#File是什么" class="headerlink" title="File是什么"></a>File是什么</h2><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619125213.png"></p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619125246.png"></p><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><ol><li><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619125420.png"></p></li><li><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619125515.png"></p><p>最好使用构造方法拼接，手动拼接时 不同系统的分隔符可能不同</p></li><li><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619125649.png"></p></li></ol><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><h3 id="判断，获取"><a href="#判断，获取" class="headerlink" title="判断，获取"></a>判断，获取</h3><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619125830.png"></p><ul><li><p>length 只能获取文件的大小，单位是字节，其他单位可以处1024</p><p>如果需要获取一个文件夹的大小，需要把这个文件夹里所有文件的大小都累加在一起</p></li><li><p>getNmae 对于文件会获取到后缀</p></li></ul><h3 id="创建，删除"><a href="#创建，删除" class="headerlink" title="创建，删除"></a>创建，删除</h3><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619130736.png"></p><ul><li>creat如果当前路径表示文件已存在，返回false，且父级路径必须已经存在，只能创建文件，如果没有后缀名，则会创建一个没有后缀的文件</li><li>mkdirs能创建多级文件夹，也能创建单级文件夹，mkdir只能创建单级文件夹</li><li>delete只能删除空文件夹，和文件，且不走回收站</li></ul><h3 id="获取，遍历"><a href="#获取，遍历" class="headerlink" title="获取，遍历"></a>获取，遍历</h3><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619131829.png"></p><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619132055.png"></p><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619132111.png"></p><ul><li>listRoots 获取所有盘符</li><li>FilenameFilter文件名过滤器——函数式接口，匿名内部类，Lambda表达式，方法引用</li></ul><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619133235.png" alt="简单案例"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619125732.png"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619133417.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;P001\\aaa&quot;</span>);</span><br><span class="line">        file.mkdirs();</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file, <span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> src.createNewFile();</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619133429.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        check(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;P01/aaa&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f.isFile() &amp;&amp; f.getName().endsWith(<span class="string">&quot;.avi&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619133445.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\&quot;</span>);</span><br><span class="line">        findAVIs(src);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findAVIs</span><span class="params">(File src)</span> &#123;</span><br><span class="line">        File[] files = src.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (files == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> file.getName();</span><br><span class="line">                <span class="keyword">if</span> (name.endsWith(<span class="string">&quot;.avi&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(file);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                findAVIs(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619135827.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\aaa\\src&quot;</span>);</span><br><span class="line">        delete(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(File src)</span> &#123;</span><br><span class="line">        File[] files = src.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                file.delete();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                delete(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        src.delete();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619140849.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\aaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getLen</span><span class="params">(File src)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        File[] files = src.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                len += file.length();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                len += getLen(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/11300/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230619133458.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\aaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, Integer&gt; <span class="title function_">getLen</span><span class="params">(File src)</span> &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        File[] files = src.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> file.getName();</span><br><span class="line">                String[] arr = name.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (arr.length &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">endName</span> <span class="operator">=</span> arr[arr.length - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (hm.containsKey(endName)) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> hm.get(endName);</span><br><span class="line">                        count++;</span><br><span class="line">                        hm.put(endName, count);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        hm.put(endName, <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    HashMap&lt;String, Integer&gt; sonMap = getLen(file);</span><br><span class="line">                    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = sonMap.entrySet();</span><br><span class="line">                    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : entries) &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">                        <span class="keyword">if</span> (hm.containsKey(key)) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">count</span>  <span class="operator">=</span> hm.get(key);</span><br><span class="line">                            count = count + value;</span><br><span class="line">                            hm.put(key, count);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            hm.put(key, value);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hm;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java异常</title>
      <link href="/posts/48508.html"/>
      <url>/posts/48508.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[toc]</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618155444.png"></p><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618155507.png"></p><p><img src="/posts/48508/"><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618155613.png" alt="微信截图_20230618155613"></p><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618155710.png"></p><h3 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h3><p>红线划出，严重，大多数为语法错误</p><p>在编译阶段必须手动处理</p><p>提醒程序员检查本地信息</p><h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>编译阶段无法检查的异常，大多数为逻辑错误</p><h2 id="异常的作用"><a href="#异常的作用" class="headerlink" title="异常的作用"></a>异常的作用</h2><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618160316.png"></p><p>告诉我（控制台）出错了，跟告诉程序（返回值）出错了还是很不一样的</p><h2 id="异常的处理方式"><a href="#异常的处理方式" class="headerlink" title="异常的处理方式"></a>异常的处理方式</h2><ol><li>JVM默认处理方式</li></ol><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618161225.png"></p><ol start="2"><li><p>捕获异常</p><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618161328.png"></p></li></ol><p>​程序会继续进行</p><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618161505.png"></p><ol start="3"><li><p>细节</p><ul><li><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618161747.png"></p></li><li><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618162040.png"></p><p>多态</p><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618162137.png"></p></li><li><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618162326.png"></p></li><li><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618162430.png"></p></li></ul></li></ol><h2 id="异常中的常见方法"><a href="#异常中的常见方法" class="headerlink" title="异常中的常见方法"></a>异常中的常见方法</h2><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618162541.png"></p><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618163255.png"></p><p>手动抛出</p><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618163511.png"></p><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618163653.png"></p><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618163800.png"></p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618165432.png"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618163833.png"></p><p>抛出——告诉调用者错了</p><p>捕获——程序不能停止</p><p><img src="/posts/48508/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618165228.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>方法引用</title>
      <link href="/posts/9063.html"/>
      <url>/posts/9063.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><h2 id="什么是方法引用"><a href="#什么是方法引用" class="headerlink" title="什么是方法引用"></a>什么是方法引用</h2><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618104127.png"></p><ul><li>引用处必须是函数式接口</li><li>被引用方法必须已经存在</li><li>被引用方法的返回值需要跟抽象方法保持一直</li><li>被引用方法的功能要满足当前需求</li></ul><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618104528.png"></p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618104611.png"></p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618104737.png"></p><p>类名::方法名</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618104842.png"></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="引用静态方法"><a href="#引用静态方法" class="headerlink" title="引用静态方法"></a>引用静态方法</h3><ol><li><p>格式</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618104939.png"></p></li><li><p>使用案例</p><img src="/posts/9063/微信截图_20230618105259.png" style="zoom: 50%;"></li></ol><h3 id="引用成员方法"><a href="#引用成员方法" class="headerlink" title="引用成员方法"></a>引用成员方法</h3><ol><li><p>格式</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618105346.png"></p><p>注意：此处为对象，是引用了对象中的方法</p></li><li><p>使用案例</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618105926.png"></p></li></ol><ul><li><p>GUI界面中点击事件可以用方法引用写法</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618110525.png"></p><p>这个方法中的参数为函数式接口，使用方法引用，能让代码更加独立，可以改进之前的拼图游戏跟打字游戏，nice</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618110642.png"></p><p>现在我们应该可以写一个专门的监听事件的类，将方法写在类里面，然后使用引用方法</p></li></ul><h3 id="引用构造方法"><a href="#引用构造方法" class="headerlink" title="引用构造方法"></a>引用构造方法</h3><ol><li><p>格式</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618110829.png"></p></li><li><p>使用案例</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618110917.png"></p><p>如何手写Json解释器，呵呵呵</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618111121.png"></p><p>要重写构造方法，通过字符串来构造成员变量</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618111348.png"></p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618111403.png"></p></li></ol><h3 id="类名引用成员方法"><a href="#类名引用成员方法" class="headerlink" title="类名引用成员方法"></a>类名引用成员方法</h3><ol><li><p>格式</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618111946.png"></p></li><li><p>使用案例</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618112018.png"></p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618112154.png"></p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618112220.png"></p><ol start="3"><li><p>ps</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618112407.png"></p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618112433.png"></p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618112658.png"></p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618112732.png"></p></li></ol></li></ol><h3 id="引用数组的构造方法"><a href="#引用数组的构造方法" class="headerlink" title="引用数组的构造方法"></a>引用数组的构造方法</h3><ol><li>格式</li></ol><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618112749.png"></p><p>创建数组的类型必须跟流中的数据类型保持一致</p><ol start="2"><li><p>使用案例</p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618112920.png"></p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618113431.png"></p></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618113531.png"></p><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618113630.png"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><img src="/posts/9063/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618150941.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;aa,12&quot;</span>,<span class="string">&quot;bb,13&quot;</span>,<span class="string">&quot;cc,14&quot;</span>,<span class="string">&quot;dd,15&quot;</span>,<span class="string">&quot;jj,16&quot;</span>);</span><br><span class="line">        Student[] array = list.stream().map(Student::<span class="keyword">new</span>).toArray(Student[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    Student(String str) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = str.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">this</span>.age = Integer.parseInt(str.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">p4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;aa,12&quot;</span>,<span class="string">&quot;bb,13&quot;</span>,<span class="string">&quot;cc,14&quot;</span>,<span class="string">&quot;dd,15&quot;</span>,<span class="string">&quot;jj,16&quot;</span>);</span><br><span class="line">        Student[] array = list.stream().map(Student::<span class="keyword">new</span>).toArray(Student[]::<span class="keyword">new</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; list1 =  list.stream().map(Student::<span class="keyword">new</span>).collect(Collectors.toList());</span><br><span class="line">        String[] array1 = list1.stream().map(Student::getName).toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array1));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    Student(String str) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = str.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">this</span>.age = Integer.parseInt(str.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="string">&quot;-&quot;</span> + <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">p4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;aa,12&quot;</span>,<span class="string">&quot;bb,13&quot;</span>,<span class="string">&quot;cc,14&quot;</span>,<span class="string">&quot;dd,15&quot;</span>,<span class="string">&quot;jj,16&quot;</span>);</span><br><span class="line">        Student[] array = list.stream().map(Student::<span class="keyword">new</span>).toArray(Student[]::<span class="keyword">new</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; list1 =  list.stream().map(Student::<span class="keyword">new</span>).collect(Collectors.toList());</span><br><span class="line">        String[] array1 = list1.stream().map(Student::toString).toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Stream流</title>
      <link href="/posts/46403.html"/>
      <url>/posts/46403.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[toc]</p><h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>结合Lambda表达式，简化集合与数组的操作</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>获取流，操作，获得结果</p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618092148.png"></p><h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h3><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618092109.png"></p><ol><li><p>单列集合获取流</p><p>直接使用Collection接口中的Stream方法</p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618092248.png"></p></li><li><p>双列集合获取流</p><p>要先将集合中的元素转换为单独的key集合或者entrySet集合再进行操作</p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618093026.png"></p></li><li><p>数组获取流</p><p>使用Arrays中的静态方法</p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618093128.png"></p></li><li><p>零散数据获取流</p><p>直接使用Stream接口中的静态方法</p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618093224.png"></p></li></ol><h3 id="操作方法（中间方法）"><a href="#操作方法（中间方法）" class="headerlink" title="操作方法（中间方法）"></a>操作方法（中间方法）</h3><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618093351.png"></p><p>如果流中是对象，并且要进行去重的操作，那么要重写hashCode和equals方法</p><h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618093619.png" alt="去掉指定元素"></p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618093645.png" alt="获取前几个，跳过前几个"></p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618093713.png"></p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618093855.png" alt="去重，合并"></p><p>底层使用hashSet进行去重，合并时如果两个集合的类型不同，会使用他们的父类</p><h3 id="终结方法"><a href="#终结方法" class="headerlink" title="终结方法"></a>终结方法</h3><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618094027.png"></p><ul><li><p>forEach中的形参为Consumer，为一个函数式接口，可以改为Lambda表达式</p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618094545.png"></p></li></ul><p>​<img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618094600.png"></p><ul><li><p>toArray的空参返回类型为Object，含参为一个IntFunction也是一个函数式接口</p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618095018.png"></p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618095127.png"></p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618095306.png"></p></li><li><p>collect 可以传入一个函数，集合工具类中的函数把数据转换成集合</p><p>如果不加，则默认为Object数组</p></li></ul><h4 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h4><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618094847.png" alt="forEach"></p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618094912.png" alt="count"></p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618095232.png"></p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618095340.png"></p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618095606.png"></p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618095640.png"></p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618100025.png"></p><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618100047.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; collect = hm.entrySet().stream().</span><br><span class="line">                filter(s -&gt; s.getValue() * <span class="number">10</span> &lt; w * <span class="number">2.5</span> / <span class="number">2</span>).</span><br><span class="line">                map(Map.Entry::getKey).</span><br><span class="line">                collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618141111.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">p4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Collections.addAll(list, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        Object[] a = list.stream().filter(s -&gt; s % <span class="number">2</span> == <span class="number">0</span>).toArray();</span><br><span class="line">        List&lt;Integer&gt; collect = list.stream().filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (integer % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618141933.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;aaa,23&quot;</span>, <span class="string">&quot;bbb,25&quot;</span>,<span class="string">&quot;ccc,26&quot;</span>,<span class="string">&quot;ddd,27&quot;</span>);</span><br><span class="line">        list.stream().forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (age &gt;= <span class="number">25</span>) &#123;</span><br><span class="line">                    map.put(name, age);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Map&lt;String, Integer&gt; collect = list.stream().filter(s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]) &gt;= <span class="number">25</span>).collect(Collectors.toMap(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        System.out.println(collect);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; collect1 = list.stream().filter(s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]) &gt;= <span class="number">25</span>).collect(Collectors.toMap(s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>], s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]));</span><br><span class="line">        System.out.println(collect1);</span><br></pre></td></tr></table></figure><p><img src="/posts/46403/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618141958.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Actor</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String age;</span><br><span class="line"></span><br><span class="line">    Actor(String str) &#123;</span><br><span class="line">        String[] a = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = a[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">this</span>.age = a[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">p4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; mal = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(mal, <span class="string">&quot;aa,25&quot;</span>,<span class="string">&quot;bb,23&quot;</span>,<span class="string">&quot;ccc,54&quot;</span>,<span class="string">&quot;ddd,60&quot;</span>,<span class="string">&quot;eee,55&quot;</span>,<span class="string">&quot;fff,51&quot;</span>,<span class="string">&quot;ccc,23&quot;</span>);</span><br><span class="line">        ArrayList&lt;String&gt; fal = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(fal, <span class="string">&quot;aa,25&quot;</span>,<span class="string">&quot;cd,23&quot;</span>,<span class="string">&quot;ef,54&quot;</span>,<span class="string">&quot;ak,60&quot;</span>,<span class="string">&quot;ac,55&quot;</span>,<span class="string">&quot;ac,51&quot;</span>,<span class="string">&quot;ad,23&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; ma = mal.stream().filter(s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>].length() == <span class="number">3</span>).limit(<span class="number">2</span>).collect(Collectors.toList());</span><br><span class="line">        List&lt;String&gt; fa = fal.stream().filter(s -&gt; s.charAt(<span class="number">0</span>) == <span class="string">&#x27;a&#x27;</span>).skip(<span class="number">1</span>).collect(Collectors.toList());</span><br><span class="line">        List&lt;String&gt; list = Stream.concat(ma.stream(), fa.stream()).collect(Collectors.toList());</span><br><span class="line">        List&lt;Actor&gt; ans = list.stream().map(Actor::<span class="keyword">new</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java双列集合</title>
      <link href="/posts/31756.html"/>
      <url>/posts/31756.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[toc]</p><h1 id="Java双列集合"><a href="#Java双列集合" class="headerlink" title="Java双列集合"></a>Java双列集合</h1><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617144233.png"></p><h2 id="双列集合的特点"><a href="#双列集合的特点" class="headerlink" title="双列集合的特点"></a>双列集合的特点</h2><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617142141.png"></p><h2 id="常见API"><a href="#常见API" class="headerlink" title="常见API"></a>常见API</h2><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617142252.png"></p><ul><li>put方法，既可添加，也可覆盖，添加时如果键存在，那么会把原来的值覆盖并返回，如果不存在，返回null</li><li>remove 根据键移除对应键值对</li><li>clear 直接清空</li><li>判断是否包含某键，判断是否包含某值 contains key or value</li><li>keySet（）：返回一个键集合<ul><li>语法：Set<K> keySet()</K></li></ul></li><li>entrySet（）：返回一个键值对集合<ul><li>语法：Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</li></ul></li></ul><h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><h3 id="1-键找值"><a href="#1-键找值" class="headerlink" title="1. 键找值"></a>1. 键找值</h3><p>使用 keySet方法将键提出为一个单列集合，遍历单列集合，找出对应值</p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617143245.png"></p><h3 id="2-键值对"><a href="#2-键值对" class="headerlink" title="2. 键值对"></a>2. 键值对</h3><p>通过EntrySet方法获取Entry对象来进行遍历</p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617143712.png"></p><h3 id="3-lambda表达式"><a href="#3-lambda表达式" class="headerlink" title="3. lambda表达式"></a>3. lambda表达式</h3><p>在forEach方法中使用Lambda表达式</p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617144034.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617144132.png"></p><h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><strong>特点</strong></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617144331.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617144500.png"></p><p><strong>底层原理</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>看源码之前需要了解的一些内容</span><br><span class="line"></span><br><span class="line">Node&lt;K,V&gt;[] table   哈希表结构中数组的名字</span><br><span class="line"></span><br><span class="line">DEFAULT_INITIAL_CAPACITY：   数组默认长度<span class="number">16</span></span><br><span class="line"></span><br><span class="line">DEFAULT_LOAD_FACTOR：        默认加载因子<span class="number">0.75</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HashMap里面每一个对象包含以下内容：</span><br><span class="line">数组中的对象要分情况进行讨论</span><br><span class="line"><span class="number">1.1</span> 链表中的键值对对象</span><br><span class="line">    包含：  </span><br><span class="line"><span class="type">int</span> hash;         <span class="comment">//键的哈希值</span></span><br><span class="line">            <span class="keyword">final</span> K key;      <span class="comment">//键</span></span><br><span class="line">            V value;          <span class="comment">//值</span></span><br><span class="line">            Node&lt;K,V&gt; next;   <span class="comment">//下一个节点的地址值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.2</span> 红黑树中的键值对对象</span><br><span class="line">包含：</span><br><span class="line"><span class="type">int</span> hash;         <span class="comment">//键的哈希值</span></span><br><span class="line">            <span class="keyword">final</span> K key;      <span class="comment">//键</span></span><br><span class="line">            V value;          <span class="comment">//值</span></span><br><span class="line">            TreeNode&lt;K,V&gt; parent;  <span class="comment">//父节点的地址值</span></span><br><span class="line">TreeNode&lt;K,V&gt; left;<span class="comment">//左子节点的地址值</span></span><br><span class="line">TreeNode&lt;K,V&gt; right;<span class="comment">//右子节点的地址值</span></span><br><span class="line"><span class="type">boolean</span> red;<span class="comment">//节点的颜色</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>添加元素</span><br><span class="line">HashMap&lt;String,Integer&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">hm.put(<span class="string">&quot;aaa&quot;</span> , <span class="number">111</span>);</span><br><span class="line">hm.put(<span class="string">&quot;bbb&quot;</span> , <span class="number">222</span>);</span><br><span class="line">hm.put(<span class="string">&quot;ccc&quot;</span> , <span class="number">333</span>);</span><br><span class="line">hm.put(<span class="string">&quot;ddd&quot;</span> , <span class="number">444</span>);</span><br><span class="line">hm.put(<span class="string">&quot;eee&quot;</span> , <span class="number">555</span>);</span><br><span class="line"></span><br><span class="line">添加元素的时候至少考虑三种情况：</span><br><span class="line"><span class="number">2.1</span>数组位置为<span class="literal">null</span></span><br><span class="line"><span class="number">2.2</span>数组位置不为<span class="literal">null</span>，键不重复，挂在下面形成链表或者红黑树</span><br><span class="line"><span class="number">2.3</span>数组位置不为<span class="literal">null</span>，键重复，元素覆盖</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数一：键</span></span><br><span class="line"><span class="comment">//参数二：值</span></span><br><span class="line"><span class="comment">//返回值：被覆盖元素的值，如果没有覆盖，返回null</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用键计算出对应的哈希值，再把哈希值进行一些额外的处理</span></span><br><span class="line"><span class="comment">//简单理解：返回值就是返回键的哈希值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数一：键的哈希值</span></span><br><span class="line"><span class="comment">//参数二：键</span></span><br><span class="line"><span class="comment">//参数三：值</span></span><br><span class="line"><span class="comment">//参数四：如果键重复了是否保留</span></span><br><span class="line"><span class="comment">//   true，表示老元素的值保留，不会覆盖</span></span><br><span class="line"><span class="comment">//   false，表示老元素的值不保留，会进行覆盖</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个局部变量，用来记录哈希表中数组的地址值。</span></span><br><span class="line">    <span class="comment">//成员变量储存在堆中，而局部变量在栈中，使用局部变量，提升效率</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line"></span><br><span class="line"><span class="comment">//临时的第三方变量，用来记录键值对对象的地址值</span></span><br><span class="line">        Node&lt;K,V&gt; p;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//表示当前数组的长度</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示索引</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把哈希表中数组的地址值，赋值给局部变量tab</span></span><br><span class="line">tab = table; <span class="comment">// 原数组</span></span><br><span class="line">n = tab.length <span class="comment">// 当前数组长度</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || n == <span class="number">0</span>)&#123;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//1.如果当前是第一次添加数据，底层会创建一个默认长度为16，加载因子为0.75的数组</span></span><br><span class="line"><span class="comment">//2.如果不是第一次添加数据，会看数组中的元素是否达到了扩容的条件</span></span><br><span class="line"><span class="comment">//如果没有达到扩容条件，底层不会做任何操作</span></span><br><span class="line"><span class="comment">//如果达到了扩容条件，底层会把数组扩容为原先的两倍，并把数据全部转移到新的哈希表中</span></span><br><span class="line">tab = resize();</span><br><span class="line"><span class="comment">//表示把当前数组的长度赋值给n</span></span><br><span class="line">            n = tab.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拿着数组的长度跟键的哈希值进行计算，计算出当前键值对对象，在数组中应存入的位置</span></span><br><span class="line">i = (n - <span class="number">1</span>) &amp; hash;<span class="comment">//index</span></span><br><span class="line"><span class="comment">//获取数组中对应元素的数据</span></span><br><span class="line">p = tab[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="comment">//底层会创建一个键值对对象，直接放到数组当中</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            K k;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等号的左边：数组中键值对的哈希值</span></span><br><span class="line"><span class="comment">//等号的右边：当前要添加键值对的哈希值</span></span><br><span class="line"><span class="comment">//如果键不一样，此时返回false</span></span><br><span class="line"><span class="comment">//如果键一样，返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> p.hash == hash;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (b1 &amp;&amp; ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">                e = p;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)&#123;</span><br><span class="line"><span class="comment">//判断数组中获取出来的键值对是不是红黑树中的节点</span></span><br><span class="line"><span class="comment">//如果是，则调用方法putTreeVal，把当前的节点按照红黑树的规则添加到树当中。</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果从数组中获取出来的键值对不是红黑树中的节点</span></span><br><span class="line"><span class="comment">//表示此时下面挂的是链表</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//此时就会创建一个新的节点，挂在下面形成链表</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//判断当前链表长度是否超过8，如果超过8，就会调用方法treeifyBin</span></span><br><span class="line"><span class="comment">//treeifyBin方法的底层还会继续判断</span></span><br><span class="line"><span class="comment">//判断数组的长度是否大于等于64</span></span><br><span class="line"><span class="comment">//如果同时满足这两个条件，就会把这个链表转成红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//e：  0x0044  ddd  444</span></span><br><span class="line"><span class="comment">//要添加的元素： 0x0055   ddd   555</span></span><br><span class="line"><span class="comment">//如果哈希值一样，就会调用equals方法比较内部的属性值是否相同</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果e为null，表示当前不需要覆盖任何元素</span></span><br><span class="line"><span class="comment">//如果e不为null，表示当前的键是一样的，值会被覆盖</span></span><br><span class="line"><span class="comment">//e:0x0044  ddd  555</span></span><br><span class="line"><span class="comment">//要添加的元素： 0x0055   ddd   555</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等号的右边：当前要添加的值</span></span><br><span class="line"><span class="comment">//等号的左边：0x0044的值</span></span><br><span class="line">e.value = value;</span><br><span class="line">&#125;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//threshold：记录的就是数组的长度 * 0.75，哈希表的扩容时机  16 * 0.75 = 12</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)&#123;</span><br><span class="line"> resize();</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//表示当前没有覆盖任何元素，返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>练习</strong></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617144540.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617144552.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617145423.png"></p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617145713.png"></p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p><strong>特点</strong></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617151951.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617153028.png"></p><p><strong>底层原理</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>TreeMap中每一个节点的内部属性</span><br><span class="line">K key;<span class="comment">//键</span></span><br><span class="line">V value;<span class="comment">//值</span></span><br><span class="line">Entry&lt;K,V&gt; left;<span class="comment">//左子节点</span></span><br><span class="line">Entry&lt;K,V&gt; right;<span class="comment">//右子节点</span></span><br><span class="line">Entry&lt;K,V&gt; parent;<span class="comment">//父节点</span></span><br><span class="line"><span class="type">boolean</span> color;<span class="comment">//节点的颜色</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>TreeMap类中中要知道的一些成员变量</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMap</span>&lt;K,V&gt;&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//比较器对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line"><span class="comment">//集合的长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>空参构造</span><br><span class="line"><span class="comment">//空参构造就是没有传递比较器对象</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span> &#123;</span><br><span class="line">        comparator = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>带参构造</span><br><span class="line"><span class="comment">//带参构造就是传递了比较器对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>添加元素</span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> put(key, value, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">参数一：键</span><br><span class="line">参数二：值</span><br><span class="line">参数三：当键重复的时候，是否需要覆盖值</span><br><span class="line"><span class="literal">true</span>：覆盖</span><br><span class="line"><span class="literal">false</span>：不覆盖</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> V <span class="title function_">put</span><span class="params">(K key, V value, <span class="type">boolean</span> replaceOld)</span> &#123;</span><br><span class="line"><span class="comment">//获取根节点的地址值，赋值给局部变量t</span></span><br><span class="line">        Entry&lt;K,V&gt; t = root;</span><br><span class="line"><span class="comment">//判断根节点是否为null</span></span><br><span class="line"><span class="comment">//如果为null，表示当前是第一次添加，会把当前要添加的元素，当做根节点</span></span><br><span class="line"><span class="comment">//如果不为null，表示当前不是第一次添加，跳过这个判断继续执行下面的代码</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//方法的底层，会创建一个Entry对象，把他当做根节点</span></span><br><span class="line">            addEntryToEmptyMap(key, value);</span><br><span class="line"><span class="comment">//表示此时没有覆盖任何的元素</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//表示两个元素的键比较之后的结果</span></span><br><span class="line">        <span class="type">int</span> cmp;</span><br><span class="line"><span class="comment">//表示当前要添加节点的父节点</span></span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示当前的比较规则</span></span><br><span class="line"><span class="comment">//如果我们是采取默认的自然排序，那么此时comparator记录的是null，cpr记录的也是null</span></span><br><span class="line"><span class="comment">//如果我们是采取比较去排序方式，那么此时comparator记录的是就是比较器</span></span><br><span class="line">        Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;</span><br><span class="line"><span class="comment">//表示判断当前是否有比较器对象</span></span><br><span class="line"><span class="comment">//如果传递了比较器对象，就执行if里面的代码，此时以比较器的规则为准</span></span><br><span class="line"><span class="comment">//如果没有传递比较器对象，就执行else里面的代码，此时以自然排序的规则为准</span></span><br><span class="line">        <span class="keyword">if</span> (cpr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = cpr.compare(key, t.key);</span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> t.value;</span><br><span class="line">                    <span class="keyword">if</span> (replaceOld || oldValue == <span class="literal">null</span>) &#123;</span><br><span class="line">                        t.value = value;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> oldValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//把键进行强转，强转成Comparable类型的</span></span><br><span class="line"><span class="comment">//要求：键必须要实现Comparable接口，如果没有实现这个接口</span></span><br><span class="line"><span class="comment">//此时在强转的时候，就会报错。</span></span><br><span class="line">            Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">//把根节点当做当前节点的父节点</span></span><br><span class="line">                parent = t;</span><br><span class="line"><span class="comment">//调用compareTo方法，比较根节点和当前要添加节点的大小关系</span></span><br><span class="line">                cmp = k.compareTo(t.key);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">//如果比较的结果为负数</span></span><br><span class="line"><span class="comment">//那么继续到根节点的左边去找</span></span><br><span class="line">                    t = t.left;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">//如果比较的结果为正数</span></span><br><span class="line"><span class="comment">//那么继续到根节点的右边去找</span></span><br><span class="line">                    t = t.right;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果比较的结果为0，会覆盖</span></span><br><span class="line">                    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> t.value;</span><br><span class="line">                    <span class="keyword">if</span> (replaceOld || oldValue == <span class="literal">null</span>) &#123;</span><br><span class="line">                        t.value = value;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> oldValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//就会把当前节点按照指定的规则进行添加</span></span><br><span class="line">        addEntry(key, value, parent, cmp &lt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(K key, V value, Entry&lt;K, V&gt; parent, <span class="type">boolean</span> addToLeft)</span> &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, parent);</span><br><span class="line">        <span class="keyword">if</span> (addToLeft)</span><br><span class="line">            parent.left = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent.right = e;</span><br><span class="line"><span class="comment">//添加完毕之后，需要按照红黑树的规则进行调整</span></span><br><span class="line">        fixAfterInsertion(e);</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> &#123;</span><br><span class="line"><span class="comment">//因为红黑树的节点默认就是红色的</span></span><br><span class="line">        x.color = RED;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照红黑规则进行调整</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//parentOf:获取x的父节点</span></span><br><span class="line"><span class="comment">//parentOf(parentOf(x)):获取x的爷爷节点</span></span><br><span class="line"><span class="comment">//leftOf:获取左子节点</span></span><br><span class="line">        <span class="keyword">while</span> (x != <span class="literal">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前节点的父节点是爷爷节点的左子节点还是右子节点</span></span><br><span class="line"><span class="comment">//目的：为了获取当前节点的叔叔节点</span></span><br><span class="line">            <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line"><span class="comment">//表示当前节点的父节点是爷爷节点的左子节点</span></span><br><span class="line"><span class="comment">//那么下面就可以用rightOf获取到当前节点的叔叔节点</span></span><br><span class="line">                Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">                <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line"><span class="comment">//叔叔节点为红色的处理方案</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把父节点设置为黑色</span></span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line"><span class="comment">//把叔叔节点设置为黑色</span></span><br><span class="line">                    setColor(y, BLACK);</span><br><span class="line"><span class="comment">//把爷爷节点设置为红色</span></span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把爷爷节点设置为当前节点</span></span><br><span class="line">                    x = parentOf(parentOf(x));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//叔叔节点为黑色的处理方案</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//表示判断当前节点是否为父节点的右子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示当前节点是父节点的右子节点</span></span><br><span class="line">                        x = parentOf(x);</span><br><span class="line"><span class="comment">//左旋</span></span><br><span class="line">                        rotateLeft(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    rotateRight(parentOf(parentOf(x)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//表示当前节点的父节点是爷爷节点的右子节点</span></span><br><span class="line"><span class="comment">//那么下面就可以用leftOf获取到当前节点的叔叔节点</span></span><br><span class="line">                Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">                <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(y, BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    x = parentOf(parentOf(x));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                        x = parentOf(x);</span><br><span class="line">                        rotateRight(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把根节点设置为黑色</span></span><br><span class="line">        root.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>TreeMap添加元素的时候，键是否需要重写hashCode和equals方法？<br>此时是不需要重写的。</p></li><li><p>HashMap是哈希表结构的，JDK8开始由数组，链表，红黑树组成的。<br>既然有红黑树，HashMap的键是否需要实现Compareable接口或者传递比较器对象呢？<br>不需要的。<br>因为在HashMap的底层，默认是利用哈希值的大小关系来创建红黑树的</p></li><li><p>TreeMap和HashMap谁的效率更高？<br>如果是最坏情况，添加了8个元素，这8个元素形成了链表，此时TreeMap的效率要更高<br>但是这种情况出现的几率非常的少。<br>一般而言，还是HashMap的效率要更高。</p></li><li><p>你觉得在Map集合中，java会提供一个如果键重复了，不会覆盖的put方法呢？<br>此时putIfAbsent本身不重要。<br>传递一个思想：<br>代码中的逻辑都有两面性，如果我们只知道了其中的A面，而且代码中还发现了有变量可以控制两面性的发生。<br>那么该逻辑一定会有B面。<br><br> 习惯：<br> boolean类型的变量控制，一般只有AB两面，因为boolean只有两个值<br> int类型的变量控制，一般至少有三面，因为int可以取多个值。</p></li><li><p>三种双列集合，以后如何选择？<br>HashMap LinkedHashMap TreeMap<br> 默认：HashMap（效率最高）<br> 如果要保证存取有序：LinkedHashMap<br> 如果要进行排序：TreeMap</p></li></ol><h1 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h1><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>如何设计方法求n个数的和</p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618084959.png"></p><p>简化</p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618085107.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618085153.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618085354.png"></p><h2 id="集合工具类"><a href="#集合工具类" class="headerlink" title="集合工具类"></a>集合工具类</h2><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618085501.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618085531.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618085625.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618085706.png"></p><h2 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h2><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618090004.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618090022.png"></p><p>使用</p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618090222.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618090245.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618090436.png"></p><p>map无可变参数，最多只能传递20个键值对，但是有Entry的可变参数</p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618091601.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618091622.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618091644.png"></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618132859.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">p1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 随机点名</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用集合工具类添加数据</span></span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;aba&quot;</span>,<span class="string">&quot;aac&quot;</span>,<span class="string">&quot;eaa&quot;</span>,<span class="string">&quot;afa&quot;</span>,<span class="string">&quot;gaa&quot;</span>,<span class="string">&quot;haa&quot;</span>,<span class="string">&quot;aai&quot;</span>,<span class="string">&quot;aja&quot;</span>,<span class="string">&quot;kaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一种随机方式</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Random</span> <span class="variable">rd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> rd.nextInt(list.size());</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> list.get(idx);</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用集合工具进行打乱</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618132922.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">p2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 带权重的随机， 70%随机到男生 30%到女生</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如何解决概率问题</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        Collections.addAll(list, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在集合中有百分之七十概率抽到 1 百分之三十概率抽到 0</span></span><br><span class="line">        <span class="comment">// 如果抽到 1 我们从 男生的链表中随机，如果抽到 0 从女生的链表中随机</span></span><br><span class="line"></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> rd.nextInt(list.size());</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> list.get(idx);</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;从男生的集合中抽取&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;从女生的集合中抽取&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//在这个方法中，我们可以把随机抽取的这个步骤设计成方法多次调用即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618132938.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">p3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 点到的学生不会再点到，如果都电完，开启第二轮点名</span></span><br><span class="line">        <span class="comment">// 记忆化抽取</span></span><br><span class="line">        <span class="comment">// 也可以删一个就往另一个链表中加一个，当一个链表空的时候就重新往里面加就可以了 list.addAll(list1)</span></span><br><span class="line">        <span class="comment">// 在使用链表长度作为循环判断条件的时候需要注意链表的长度是有可能发生改变导致数组遍历不完全的</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//使用集合工具类添加数据</span></span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;aba&quot;</span>,<span class="string">&quot;aac&quot;</span>,<span class="string">&quot;eaa&quot;</span>,<span class="string">&quot;afa&quot;</span>,<span class="string">&quot;gaa&quot;</span>,<span class="string">&quot;haa&quot;</span>,<span class="string">&quot;aai&quot;</span>,<span class="string">&quot;aja&quot;</span>,<span class="string">&quot;kaa&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span>[] flag = <span class="keyword">new</span> <span class="title class_">boolean</span>[list.size()];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跟记忆化搜索一样，懒得写了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618133000.png"></p><p><img src="/posts/31756/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618140425.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, ArrayList&lt;String&gt;&gt; list = new HashMap()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/posts/2053.html"/>
      <url>/posts/2053.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h2><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617092143.png"></p><p>泛型是为了能够统一数据，方便操作</p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617092436.png"></p><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617092552.png"></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617092651.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617092816.png"></p><ol><li>因为在编译的时候都会转为Object类，而基本数据类型无法转成Object所以只能用对应的包装类</li><li>多态</li><li>所以不能用基本数据类型</li></ol><h1 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h1><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617093039.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617093101.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617093355.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617093456.png"></p><h1 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h1><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617093635.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617093655.png"></p><p>可变参数</p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617094104.png"></p><h1 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h1><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617094145.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617094201.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617094302.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617094414.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617094501.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617094621.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617094636.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617094947.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617095044.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617095625.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617095644.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617095713.png"></p><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617095742.png"></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><img src="/posts/2053/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617095138.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java数据结构</title>
      <link href="/posts/60592.html"/>
      <url>/posts/60592.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[toc]</p><h1 id><a href="#" class="headerlink" title></a></h1><h1 id="Java数据结构"><a href="#Java数据结构" class="headerlink" title="Java数据结构"></a>Java数据结构</h1><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616231612.png"></p><h2 id="1-栈"><a href="#1-栈" class="headerlink" title="1. 栈"></a>1. 栈</h2><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616231645.png"></p><p>进栈的过程称为压&#x2F;进栈，离开的过程称为弹&#x2F;出栈</p><h2 id="2-队列"><a href="#2-队列" class="headerlink" title="2. 队列"></a>2. 队列</h2><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616231815.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616231903.png"></p><h2 id="3-数组"><a href="#3-数组" class="headerlink" title="3. 数组"></a>3. 数组</h2><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616232016.png"></p><h2 id="4-链表"><a href="#4-链表" class="headerlink" title="4. 链表"></a>4. 链表</h2><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616232045.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616232204.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616232258.png"></p><h2 id="5-树"><a href="#5-树" class="headerlink" title="5. 树"></a>5. 树</h2><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617102155.png"></p><h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617102644.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617102728.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617102752.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617102807.png"></p><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="- 二叉查找树"></a>- 二叉查找树</h3><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617102328.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617102428.png"></p><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="- 平衡二叉树"></a>- 平衡二叉树</h3><p>查找树优化</p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617103047.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617103446.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617103713.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617103742.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617103822.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617103855.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617104030.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617104206.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617104325.png"></p><p>插入情况</p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617104520.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617104705.png"></p><p>先局部左旋,在整体右旋</p><img src="/posts/60592/微信截图_20230617104830.png" style="zoom:80%;"><p>小结</p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617104907.png"></p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="- 红黑树"></a>- 红黑树</h3><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617105152.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617105437.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617110042.png"></p><p><img src="/posts/60592/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617113911.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="/posts/21079.html"/>
      <url>/posts/21079.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[toc]</p><h1 id="集合体系结构"><a href="#集合体系结构" class="headerlink" title="集合体系结构"></a>集合体系结构</h1><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616222503.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616222539.png"></p><p>list 集合特点：有序，可重复，有索引</p><p>set集合特点：无序，不重复，无索引</p><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616222802.png"></p><p>Collection是一个接口，所以不能直接创建对象，只能创建他实现类的对象</p><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><h3 id="1-add"><a href="#1-add" class="headerlink" title="1. add"></a>1. add</h3><p>往list中添加数据，永远返回true因为list是允许元素重复的</p><p>如果往set中添加数据，则如果数据不存在返回true，否则返回false，因为set中的元素不允许重复</p><h3 id="2-clear"><a href="#2-clear" class="headerlink" title="2. clear"></a>2. clear</h3><p>清空集合</p><h3 id="3-remove"><a href="#3-remove" class="headerlink" title="3. remove"></a>3. remove</h3><p>因为是list跟set共有的方法，所以不嫩沟通过索引进行删除，只能通过元素对象进行删除，如果集合中存在该元素，则删除成功返回true，否则返回false</p><h3 id="4-contains"><a href="#4-contains" class="headerlink" title="4. contains"></a>4. contains</h3><p>判断是否包含某元素</p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616224336.png"></p><p>底层是依靠equals判断是否存在，如果储存的是自定义对象则需要重写equals方法（equals方法依靠地址值进行判断而我们一般需要比较的是属性值）</p><h3 id="5-isEmpty"><a href="#5-isEmpty" class="headerlink" title="5. isEmpty"></a>5. isEmpty</h3><p>判断集合是否为空，底层直接判断集合的长度</p><h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><p>因为collection没有索引，所以无法通过普通遍历方式进行遍历 </p><h3 id="1-迭代器遍历"><a href="#1-迭代器遍历" class="headerlink" title="1. 迭代器遍历"></a>1. 迭代器遍历</h3><p>迭代器对象，不依赖索引</p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616224908.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616225010.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616225128.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616225406.png"></p><p>对于4，会出现并发修改异常，如果需要在迭代时进行删除，那么我们不能用集合的方法进行删除，可以用迭代器使用的remove方法</p><h3 id="2-增强-for-遍历"><a href="#2-增强-for-遍历" class="headerlink" title="2. 增强 for 遍历"></a>2. 增强 for 遍历</h3><img src="/posts/21079/微信截图_20230616225635.png" style="zoom:67%;"><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616225728.png"></p><p>增强for遍历中的元素为临时变量</p><h3 id="3-lambda表达式遍历"><a href="#3-lambda表达式遍历" class="headerlink" title="3. lambda表达式遍历"></a>3. lambda表达式遍历</h3><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616230030.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616230104.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616230144.png"></p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h2><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617130104.png"></p><h2 id="2-特有方法"><a href="#2-特有方法" class="headerlink" title="2. 特有方法"></a>2. 特有方法</h2><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616230334.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616230543.png"></p><h2 id="3-遍历方式"><a href="#3-遍历方式" class="headerlink" title="3. 遍历方式"></a>3. 遍历方式</h2><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616230716.png"></p><p>重点，列表迭代器，为迭代器的子接口</p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616230915.png" alt="List"></p><p>在这个迭代器中，指针的移动更加灵活，既可以向前，也可以向后，并且在迭代时可以添加元素</p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616231136.png"></p><h2 id="4-实现类"><a href="#4-实现类" class="headerlink" title="4. 实现类"></a>4. 实现类</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ul><li><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616232744.png"></li></ul><p>size 变量是指list的长度，也是下一个存入的位置</p><ul><li><p>空参构造</p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616232925.png"></p></li><li><p>扩容（理解）</p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616233410.png" alt="神奇的源码"></p></li></ul><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616233912.png" alt="神奇的源码"></p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ul><li><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616234036.png"></li></ul><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230616234111.png"></p><ul><li><p>结构</p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617090856.png"></p></li></ul><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><ul><li><p>源码</p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617092007.png"></p></li></ul><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="1-特点-1"><a href="#1-特点-1" class="headerlink" title="1. 特点"></a>1. 特点</h2><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617114249.png"></p><h2 id="2-包含方法"><a href="#2-包含方法" class="headerlink" title="2. 包含方法"></a>2. 包含方法</h2><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617130302.png"></p><ul><li>add方法不一定成功,因为不允许有重复元素</li></ul><h2 id="3-遍历方式-1"><a href="#3-遍历方式-1" class="headerlink" title="3. 遍历方式"></a>3. 遍历方式</h2><ul><li>迭代器遍历</li><li>增强for遍历</li><li>lambda表达式遍历</li></ul><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617130713.png"></p><h2 id="4-实现类-1"><a href="#4-实现类-1" class="headerlink" title="4.实现类"></a>4.实现类</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617131123.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617130932.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617131037.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617131357.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617131633.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617131911.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617131925.png"></p><p>HashCode equals方法保证去重</p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617132136.png"></p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617132611.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617132744.png"></p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617132851.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617135231.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617140311.png"></p><p>实现比较接口</p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617135633.png"></p><p>传递比较器</p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617140513.png"></p><p>函数式接口可以改为lambda表达式</p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617140636.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617141115.png"></p><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617141146.png"></p><h1 id="使用情景"><a href="#使用情景" class="headerlink" title="使用情景"></a>使用情景</h1><p><img src="/posts/21079/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230617141252.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>双指针</title>
      <link href="/posts/58208.html"/>
      <url>/posts/58208.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>双指针可以使我们在不使用额外空间且只遍历一次数组的情况下修改数组中的元素</p><p>通常我们需要定义两个指针，利用他们前进的不同速度来实现不同的操作，快指针我们用来寻找新的目标，慢指针用于修改目标</p><h2 id="一，移除元素"><a href="#一，移除元素" class="headerlink" title="一，移除元素"></a>一，移除元素</h2><p><img src="/posts/58208/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230413213357.png"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>通过循环不断把右边的值赋给左边，也就是将fast指向的值赋给slow，fast指向待处理的元素，slow指向下一个要赋值的位置，如果右指针指向的元素为目标元素，则它不能出现在我们覆盖后的数组里，此时左指针不同，右指针移动一位</p><p>整个过程保持不变的性质是：区间[0, left)中的元素都不等于val，当左右指针遍历完输入数组以后，left的值就是输出数组的长度</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeElement(int[] nums, int val) &#123;</span><br><span class="line">        int slow = 0;</span><br><span class="line">        for (int fast = 0; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">            if (nums[fast] != val) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二，删除数组中相邻重复项"><a href="#二，删除数组中相邻重复项" class="headerlink" title="二，删除数组中相邻重复项"></a>二，删除数组中相邻重复项</h2><p><img src="/posts/58208/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230413214638.png"></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>跟第一道题思路类似，通过循环不断把快指针指向的值赋给左边，如果快指针指向的值等于慢指针指向的值，那么慢指针不懂，快指针右移一位，前两个题目看似不同，其实都是同一个道理</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeDuplicates(int[] nums) &#123;</span><br><span class="line"></span><br><span class="line">        int fast = 0;</span><br><span class="line">        int slow = 0;</span><br><span class="line">        while (fast != nums.length) &#123;</span><br><span class="line">            if (nums[fast] == nums[slow]) &#123;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125; else if (nums[fast] != nums[slow]) &#123;</span><br><span class="line">                nums[slow + 1] = nums[fast];</span><br><span class="line">                fast++;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow += 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三，移动零"><a href="#三，移动零" class="headerlink" title="三，移动零"></a>三，移动零</h2><p><img src="/posts/58208/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230413220705.png"></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>与前面题目的不同是，前面的题目都是在用快指针进行判断，如果快指针的值满足要求，那么我们进行操作，不断把右边的值移向左边，但是这个题目是把值移向右边，所以我们在对快指针指向值进行判断的前提下还要对慢指针指向的值进行判断，当两者指向的值都满足要求时，我们才进行操作</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void moveZeroes(int[] nums) &#123;</span><br><span class="line">        int slow = 0;</span><br><span class="line">        int fast = 0;</span><br><span class="line">        while (fast &lt; nums.length) &#123;</span><br><span class="line">            if (nums[slow] == 0 &amp;&amp; nums[fast] == 0) &#123;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125; else if (nums[slow] == 0 &amp;&amp; nums[fast] != 0) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                nums[fast] = 0;</span><br><span class="line">                slow++;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                slow++;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四，比较含退格的字符串"><a href="#四，比较含退格的字符串" class="headerlink" title="四，比较含退格的字符串"></a>四，比较含退格的字符串</h2><p><img src="/posts/58208/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230413221228.png"></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>这个题目我第一思路是用栈</p><p>双指针的思路也挺好想，我们定义两个指针分别逆序遍历两个数组，直到两个字符串能确定一个字符，对这两个字符进行比较，直到找到两个不一样的字符或者遍历完整个数组</p><p><img src="/posts/58208/1.gif" alt="作者：LeetCode-Solution        链接：https://leetcode.cn/problems/backspace-string-compare/solution/bi-jiao-han-tui-ge-de-zi-fu-chuan-by-leetcode-solu/        来源：力扣（LeetCode）"></p><p>栈是处理完字符之后比较最后的答案，但是双指针则是一部分，一部分的进行比较，这里直接上官方答案</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean backspaceCompare(String S, String T) &#123;</span><br><span class="line">        int i = S.length() - 1, j = T.length() - 1;</span><br><span class="line">        int skipS = 0, skipT = 0;</span><br><span class="line"></span><br><span class="line">        while (i &gt;= 0 || j &gt;= 0) &#123;</span><br><span class="line">            while (i &gt;= 0) &#123;</span><br><span class="line">                if (S.charAt(i) == &#x27;#&#x27;) &#123;</span><br><span class="line">                    skipS++;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125; else if (skipS &gt; 0) &#123;</span><br><span class="line">                    skipS--;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            while (j &gt;= 0) &#123;</span><br><span class="line">                if (T.charAt(j) == &#x27;#&#x27;) &#123;</span><br><span class="line">                    skipT++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125; else if (skipT &gt; 0) &#123;</span><br><span class="line">                    skipT--;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123;</span><br><span class="line">                if (S.charAt(i) != T.charAt(j)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (i &gt;= 0 || j &gt;= 0) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">        链接：https://leetcode.cn/problems/backspace-string-compare/solution/bi-jiao-han-tui-ge-de-zi-fu-chuan-by-leetcode-solu/</span><br><span class="line">        来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure><h2 id="五，有序数组的平方"><a href="#五，有序数组的平方" class="headerlink" title="五，有序数组的平方"></a>五，有序数组的平方</h2><p><img src="/posts/58208/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230413221928.png"></p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>类似并规排序，找到分界线，对两边数组进行遍历，比较两个指针对应的数字，把符合条件的放到答案中，当有一边碰到边界时，把另一边的数一次放入答案</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] sortedSquares(int[] nums) &#123;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (nums.length &lt;= 1) &#123;</span><br><span class="line">            return nums;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int slow = 0, fast = nums.length - 1;</span><br><span class="line">        int[] ans = new int[nums.length];</span><br><span class="line">        int count = nums.length - 1;</span><br><span class="line">        int mid = 0;</span><br><span class="line">        while (mid != nums.length - 1 &amp;&amp; nums[mid] &gt;= nums[mid + 1]) mid++;</span><br><span class="line">        while (slow &lt;= fast) &#123;</span><br><span class="line">            if (slow != mid &amp;&amp; fast != mid) &#123;</span><br><span class="line">                if (nums[slow] &gt;= nums[fast]) &#123;</span><br><span class="line">                    ans[count--] = nums[slow];</span><br><span class="line">                    slow++;</span><br><span class="line">                &#125; else if (nums[slow] &lt; nums[fast]) &#123;</span><br><span class="line">                    ans[count--] = nums[fast];</span><br><span class="line">                    fast--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (fast == mid) &#123;</span><br><span class="line">                    ans[count--] = nums[slow++];</span><br><span class="line">                &#125; else if (slow == mid) &#123;</span><br><span class="line">                    ans[count--] = nums[fast--];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//又是一个错误写法</span><br><span class="line">        // int slow = 0, fast = nums.length - 1;</span><br><span class="line">        // while (slow &lt;= fast) &#123;</span><br><span class="line"></span><br><span class="line">        //     //一个数轴上总移动量为一次，可以使用等于，否则有风险</span><br><span class="line"></span><br><span class="line">        //     if (nums[slow] &gt; nums[fast]) &#123;</span><br><span class="line">        //         int cur = nums[slow];</span><br><span class="line">        //         nums[slow] = nums[fast];</span><br><span class="line">        //         nums[fast] = cur;</span><br><span class="line">        //         slow++;</span><br><span class="line">        //     &#125;</span><br><span class="line"></span><br><span class="line">        //     fast--;</span><br><span class="line">        // &#125;</span><br><span class="line"></span><br><span class="line">        // return nums;</span><br><span class="line"></span><br><span class="line">//错误写法</span><br><span class="line">        // int slow = 0, fast = 0;</span><br><span class="line">        // int mid = 0;</span><br><span class="line">        // while (nums[mid] &gt; nums[mid + 1]) mid++;</span><br><span class="line">        // fast = mid;</span><br><span class="line">        // while (slow != fast) &#123;</span><br><span class="line">        //     if (nums[slow] &gt; nums[fast]) &#123;</span><br><span class="line">        //         int cur = nums[slow];</span><br><span class="line">        //         nums[slow] = nums[fast];</span><br><span class="line">        //         nums[fast] = cur;</span><br><span class="line">        //     &#125;</span><br><span class="line">        //     slow++;</span><br><span class="line">        //     if (fast != nums.length - 1) fast++;</span><br><span class="line">        // &#125;</span><br><span class="line"></span><br><span class="line">        // return nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>毛毛虫算法（滑动窗口）</title>
      <link href="/posts/37949.html"/>
      <url>/posts/37949.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="长度最小子数组"><a href="#长度最小子数组" class="headerlink" title="长度最小子数组"></a>长度最小子数组</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h2 id="水果成篮"><a href="#水果成篮" class="headerlink" title="水果成篮"></a>水果成篮</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PTA错题第四次收录</title>
      <link href="/posts/22469.html"/>
      <url>/posts/22469.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="嘟嘟可大骑士的犯二手册"><a href="#嘟嘟可大骑士的犯二手册" class="headerlink" title="嘟嘟可大骑士的犯二手册"></a>嘟嘟可大骑士的犯二手册</h1><h2 id="一，阅览室"><a href="#一，阅览室" class="headerlink" title="一，阅览室"></a>一，阅览室</h2><p><img src="/posts/22469/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230328111454.png"></p><p><img src="/posts/22469/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230328111513.png"></p><h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><p>这个题目的难点在系统如何能自动忽略无效记录，可以采用桶排的思想，创建两个数组分别用于储存借出信息和归还信息，如果借出，那么在对应地方进行标记，如果归还查询借出数组是否有借出的标记，如果没有那么这是一条只有归还没有借出的记录，那么我们进行忽略。另外还需要注意的是，如果书名为0，那么我们要对后面的一系列数据进行读取，要不然会乱，另外快读的读取方式也需要注意，还有，出现除法，一定要考虑0</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>&#96;&#96;错误代码，没有注意，时间的读入，书名为0的时候没有对后面面的数据进行处理</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Z2017;</span><br><span class="line"></span><br><span class="line">import jdk.swing.interop.SwingInterOpUtils;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line">public class p03 &#123;</span><br><span class="line">    static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">    static StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line"></span><br><span class="line">    static int[][] bookState = new int[1000][6];</span><br><span class="line">    //1. jiechu 0 2. huan 1 3.jsj 2 3 4.hsj 4 5</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int n = readInt();</span><br><span class="line">        int bt = 0;</span><br><span class="line">        int pn = 0;</span><br><span class="line">        while (n != 0) &#123;</span><br><span class="line">            int bookName = readInt();</span><br><span class="line">            if (bookName == 0) &#123;</span><br><span class="line">                n -= 1;</span><br><span class="line">                readChar();</span><br><span class="line">                int hh = readInt();st.nextToken();</span><br><span class="line">                int mm = readInt();</span><br><span class="line">                System.out.println(pn +&quot; &quot;+ bt*1.0 / pn);</span><br><span class="line">                pn = 0;</span><br><span class="line">                bt = 0;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            char a = readChar();</span><br><span class="line">            if (a == &#x27;S&#x27;) &#123;</span><br><span class="line">                bookState[bookName][0] = 1;</span><br><span class="line">                //char[] time = readCharArray();</span><br><span class="line">                //String aaa = readStr();</span><br><span class="line">                //char[] time = aaa.toCharArray();</span><br><span class="line">                //int hh = (time[0] - &#x27;0&#x27;) * 10 + (time[1] - &#x27;0&#x27;);</span><br><span class="line">                //int mm = (time[3] - &#x27;0&#x27;) * 10 + (time[4] - &#x27;0&#x27;);</span><br><span class="line">                int hh = readInt();st.nextToken();</span><br><span class="line">                int mm = readInt();</span><br><span class="line">                bookState[bookName][2] = hh;</span><br><span class="line">                bookState[bookName][3] = mm;</span><br><span class="line">            &#125; else if (a == &#x27;E&#x27;) &#123;</span><br><span class="line">                if (bookState[bookName][0] != 1)&#123;</span><br><span class="line">                    readStr();</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else if (bookState[bookName][0] == 1)&#123;</span><br><span class="line">                    pn++;</span><br><span class="line">//                    char[] time = readCharArray();</span><br><span class="line">//                    int hh = (time[0] - &#x27;0&#x27;) * 10 + (time[1] - &#x27;0&#x27;);</span><br><span class="line">//                    int mm = (time[3] - &#x27;0&#x27;) * 10 + (time[4] - &#x27;0&#x27;);</span><br><span class="line">                    int hh = readInt();st.nextToken();</span><br><span class="line">                    int mm = readInt();</span><br><span class="line">                    bookState[bookName][4] = hh;</span><br><span class="line">                    bookState[bookName][5] = mm;</span><br><span class="line">                    bt += countTime(bookState[bookName][2],bookState[bookName][3],bookState[bookName][4],bookState[bookName][5]);</span><br><span class="line">                    bookState[bookName][0] =bookState[bookName][1] = bookState[bookName][2] = bookState[bookName][3] = bookState[bookName][4] = bookState[bookName][5] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        readInt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int countTime (int h1, int m1, int h2, int m2) &#123;</span><br><span class="line">        int all = 0;</span><br><span class="line">        if (h2 == h1) &#123;</span><br><span class="line">            all += m2 - m1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            all += 60 - m1;</span><br><span class="line">            h1++;</span><br><span class="line">            all += (h2 - h1) * 60;</span><br><span class="line">            all += m2;</span><br><span class="line">        &#125;</span><br><span class="line">        return all;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int readInt () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return (int)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String readStr () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char readChar () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.charAt(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readCharArray () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Z2017;</span><br><span class="line"></span><br><span class="line">import jdk.swing.interop.SwingInterOpUtils;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line">public class p03_1 &#123;</span><br><span class="line">    static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">    static StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line"></span><br><span class="line">    static int[][] bookState = new int[1000][6];</span><br><span class="line">    //1. jiechu 0 2. huan 1 3.jsj 2 3 4.hsj 4 5</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int n = readInt();</span><br><span class="line">        int bt = 0;</span><br><span class="line">        int pn = 0;</span><br><span class="line">        while (n != 0) &#123;</span><br><span class="line">            int bookName = readInt();</span><br><span class="line">            if (bookName == 0) &#123;</span><br><span class="line">                n -= 1;</span><br><span class="line">                readChar();</span><br><span class="line">                int hh = readInt();st.nextToken();</span><br><span class="line">                int mm = readInt();</span><br><span class="line">                System.out.print(pn +&quot; &quot;);</span><br><span class="line">                if (pn == 0) &#123;</span><br><span class="line">                    System.out.println(0);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.printf(&quot;%.0f\n&quot;, bt * 1.0 / pn);</span><br><span class="line">                &#125;</span><br><span class="line">                pn = 0;</span><br><span class="line">                bt = 0;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            char a = readChar();</span><br><span class="line">            if (a == &#x27;S&#x27;) &#123;</span><br><span class="line">                bookState[bookName][0] = 1;</span><br><span class="line">                //char[] time = readCharArray();</span><br><span class="line">                //String aaa = readStr();</span><br><span class="line">                //char[] time = aaa.toCharArray();</span><br><span class="line">                //int hh = (time[0] - &#x27;0&#x27;) * 10 + (time[1] - &#x27;0&#x27;);</span><br><span class="line">                //int mm = (time[3] - &#x27;0&#x27;) * 10 + (time[4] - &#x27;0&#x27;);</span><br><span class="line">                int hh = readInt();st.nextToken();</span><br><span class="line">                int mm = readInt();</span><br><span class="line">                bookState[bookName][2] = hh;</span><br><span class="line">                bookState[bookName][3] = mm;</span><br><span class="line">            &#125; else if (a == &#x27;E&#x27;) &#123;</span><br><span class="line">                if (bookState[bookName][0] != 1)&#123;</span><br><span class="line">                    int hh = readInt();st.nextToken();</span><br><span class="line">                    int mm = readInt();</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else if (bookState[bookName][0] == 1)&#123;</span><br><span class="line">                    pn++;</span><br><span class="line">//                    char[] time = readCharArray();</span><br><span class="line">//                    int hh = (time[0] - &#x27;0&#x27;) * 10 + (time[1] - &#x27;0&#x27;);</span><br><span class="line">//                    int mm = (time[3] - &#x27;0&#x27;) * 10 + (time[4] - &#x27;0&#x27;);</span><br><span class="line">                    int hh = readInt();st.nextToken();</span><br><span class="line">                    int mm = readInt();</span><br><span class="line">                    bookState[bookName][4] = hh;</span><br><span class="line">                    bookState[bookName][5] = mm;</span><br><span class="line">                    bt += countTime(bookState[bookName][2],bookState[bookName][3],bookState[bookName][4],bookState[bookName][5]);</span><br><span class="line">                    bookState[bookName][0] =bookState[bookName][1] = bookState[bookName][2] = bookState[bookName][3] = bookState[bookName][4] = bookState[bookName][5] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        readInt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int countTime (int h1, int m1, int h2, int m2) &#123;</span><br><span class="line">        int all = 0;</span><br><span class="line">        if (h2 == h1) &#123;</span><br><span class="line">            all += m2 - m1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            all += 60 - m1;</span><br><span class="line">            h1++;</span><br><span class="line">            all += (h2 - h1) * 60;</span><br><span class="line">            all += m2;</span><br><span class="line">        &#125;</span><br><span class="line">        return all;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int readInt () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return (int)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String readStr () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char readChar () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.charAt(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readCharArray () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二，猜数字"><a href="#二，猜数字" class="headerlink" title="二，猜数字"></a>二，猜数字</h2><p><img src="/posts/22469/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230328151216.png"></p><h3 id="坑-1"><a href="#坑-1" class="headerlink" title="坑"></a>坑</h3><p>这个题目其实相当简单，算出平均成绩的四分之一（ans）后对成绩数组(num[])进行排序，然后利用二分查找的思想找到ans两边的数就行了但是我如果ans用doule来存的话会出错，估计是在使用double之后小数点后面的量进位导致出现偏差</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Z2018;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line">public class 猜数字_1 &#123;</span><br><span class="line">    static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">    static StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line"></span><br><span class="line">    static String[] name = new String[10010];</span><br><span class="line">    static int[] num = new int[10010];</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int n = readInt();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            name[i] = readStr();</span><br><span class="line">            num[i] = readInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //        double ans = 0;</span><br><span class="line">//        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">//            ans += num[i];</span><br><span class="line">//        &#125;</span><br><span class="line">//        if (n != 0)ans = ans * 0.5 / n;错误部分</span><br><span class="line"></span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            ans += num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if (n != 0)ans = (int)(ans * 0.5 / n);</span><br><span class="line"></span><br><span class="line">        int left = -10;</span><br><span class="line">        int right = 110;</span><br><span class="line">        int lidx = 0;</span><br><span class="line">        int ridx = 0;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (num[i] &gt; left &amp;&amp; num[i] &lt;= ans) &#123;</span><br><span class="line">                left = num[i];</span><br><span class="line">                lidx = i;</span><br><span class="line">            &#125; else if (num[i] &gt; ans &amp;&amp; num[i] &lt; right) &#123;</span><br><span class="line">                right = num[i];</span><br><span class="line">                ridx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int lc = (int)Math.abs(ans - left);</span><br><span class="line">        int rc = (int)Math.abs(ans - right);</span><br><span class="line">        int a = (int)ans;</span><br><span class="line">        if (lc &lt; rc &amp;&amp; n != 0) &#123;</span><br><span class="line">            System.out.printf(&quot;%d&quot;,a);</span><br><span class="line">            System.out.println(&quot; &quot;+name[lidx]);</span><br><span class="line">        &#125; else if (n != 0)&#123;</span><br><span class="line">            System.out.printf(&quot;%d&quot;,a);</span><br><span class="line">            System.out.println(&quot; &quot;+name[ridx]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readSP () throws IOException &#123;</span><br><span class="line">        char aa[] = new char[5];</span><br><span class="line">        bf.read(aa);</span><br><span class="line">        return  aa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int readInt () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return (int)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String readStr () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char readChar () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.charAt(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readCharArray () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String readLine () throws IOException &#123;</span><br><span class="line">        return bf.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三，座位分配"><a href="#三，座位分配" class="headerlink" title="三，座位分配"></a>三，座位分配</h2><p><img src="/posts/22469/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230328155134.png"></p><p><img src="C:/Users/SLH/AppData/Roaming/Typora/typora-user-images/image-20230328155158406.png" alt="image-20230328155158406"></p><h3 id="坑-2"><a href="#坑-2" class="headerlink" title="坑"></a>坑</h3><p>这个题目我脑子一抽用了三维数组模拟，我只想说，实在是十分痛苦，这个题目细节挺多</p><p>如果只剩1所学校没分配座位如果上一行是本学校的，那么下一个行要+&#x3D;2，如果还+&#x3D;1那么他们可能会坐到一起，如果上一行不是本学校的，那么+&#x3D;1就可以，如果+&#x3D;2直接过不了，还有就是如果只有一个学校参赛，那么不但要求间隔座位，还必须要从1开始，否则过不了，这个题目我只能说真的是非常‘真实’</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Z2018;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line">public class 座位分配_1 &#123;</span><br><span class="line">    static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">    static StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int n = readInt();</span><br><span class="line">        int[][][] map = new int[n + 1][][];</span><br><span class="line"></span><br><span class="line">        int count = 1;</span><br><span class="line">        if (n == 1) count = -1;</span><br><span class="line">        int max = 0;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            int cur = readInt();</span><br><span class="line">            if (max &lt; cur)max = cur;</span><br><span class="line">            int[][] curr = new int[cur + 1][11];</span><br><span class="line">            curr[0][0] = cur;</span><br><span class="line">            curr[1][1] = count++;</span><br><span class="line">            map[i] = curr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count = 0;</span><br><span class="line">        boolean f = pd(map, n);</span><br><span class="line">        if (n == 1)count = -1;</span><br><span class="line">        int i = 1;</span><br><span class="line">        while (i &lt;= max) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= 10; j++) &#123;</span><br><span class="line">                for (int m = 1; m &lt; map.length; m++) &#123;</span><br><span class="line">                    if (i &gt;= map[m].length) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (f) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                        map[m][i][j] = count;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        if (count != map[m][i - 1][10] &amp;&amp; j == 1 &amp;&amp; n != 1) &#123;</span><br><span class="line">                            count++;</span><br><span class="line">                            map[m][i][j] = count;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            map[m][i][j] = count+=2;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i1 = 1; i1 &lt; map.length; i1++) &#123;</span><br><span class="line">                map[i1][0][0]--;</span><br><span class="line">            &#125;</span><br><span class="line">            f = pd(map, n);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int j = 1; j &lt; map.length; j++) &#123;</span><br><span class="line">            System.out.println(&quot;#&quot;+j);</span><br><span class="line">            for (int i1 = 1; i1 &lt; map[j].length; i1++) &#123;</span><br><span class="line">                for (int i2 = 1; i2 &lt; map[j][i1].length; i2++) &#123;</span><br><span class="line">                    System.out.print(map[j][i1][i2]);</span><br><span class="line">                    if (i2 != map[j][i1].length - 1) &#123;</span><br><span class="line">                        System.out.print(&quot; &quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static boolean pd (int[][][] a, int n) &#123;</span><br><span class="line">        if (n == 1) return false;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 1; i &lt; a.length; i++) &#123;</span><br><span class="line">            if (a[i][0][0] &gt; 0) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (count &gt;= 2) return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readSP () throws IOException &#123;</span><br><span class="line">        char aa[] = new char[5];</span><br><span class="line">        bf.read(aa);</span><br><span class="line">        return  aa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int readInt () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return (int)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String readStr () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char readChar () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.charAt(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readCharArray () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String readLine () throws IOException &#123;</span><br><span class="line">        return bf.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Z2018;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line">public class 座位分配_1 &#123;</span><br><span class="line">    static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">    static StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int n = readInt();</span><br><span class="line">        int[][][] map = new int[n + 1][][];</span><br><span class="line"></span><br><span class="line">        int count = 1;</span><br><span class="line">        if (n == 1) count = -1;</span><br><span class="line">        int max = 0;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            int cur = readInt();</span><br><span class="line">            if (max &lt; cur)max = cur;</span><br><span class="line">            int[][] curr = new int[cur + 1][11];</span><br><span class="line">            curr[0][0] = cur;</span><br><span class="line">            curr[1][1] = count++;</span><br><span class="line">            map[i] = curr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count = 0;</span><br><span class="line">        boolean f = pd(map, n);</span><br><span class="line">        if (n == 1)count = -1;</span><br><span class="line">        int i = 1;</span><br><span class="line">        while (i &lt;= max) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= 10; j++) &#123;</span><br><span class="line">                for (int m = 1; m &lt; map.length; m++) &#123;</span><br><span class="line">                    if (i &gt;= map[m].length) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (f) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                        map[m][i][j] = count;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        if (count != map[m][i - 1][10] &amp;&amp; j == 1 &amp;&amp; n != 1) &#123;</span><br><span class="line">                            count++;</span><br><span class="line">                            map[m][i][j] = count;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            map[m][i][j] = count+=2;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i1 = 1; i1 &lt; map.length; i1++) &#123;</span><br><span class="line">                map[i1][0][0]--;</span><br><span class="line">            &#125;</span><br><span class="line">            f = pd(map, n);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int j = 1; j &lt; map.length; j++) &#123;</span><br><span class="line">            System.out.println(&quot;#&quot;+j);</span><br><span class="line">            for (int i1 = 1; i1 &lt; map[j].length; i1++) &#123;</span><br><span class="line">                for (int i2 = 1; i2 &lt; map[j][i1].length; i2++) &#123;</span><br><span class="line">                    System.out.print(map[j][i1][i2]);</span><br><span class="line">                    if (i2 != map[j][i1].length - 1) &#123;</span><br><span class="line">                        System.out.print(&quot; &quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static boolean pd (int[][][] a, int n) &#123;</span><br><span class="line">        if (n == 1) return false;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 1; i &lt; a.length; i++) &#123;</span><br><span class="line">            if (a[i][0][0] &gt; 0) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (count &gt;= 2) return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readSP () throws IOException &#123;</span><br><span class="line">        char aa[] = new char[5];</span><br><span class="line">        bf.read(aa);</span><br><span class="line">        return  aa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int readInt () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return (int)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String readStr () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char readChar () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.charAt(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readCharArray () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String readLine () throws IOException &#123;</span><br><span class="line">        return bf.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四，倒数数第N个字符串"><a href="#四，倒数数第N个字符串" class="headerlink" title="四，倒数数第N个字符串"></a>四，倒数数第N个字符串</h2><p><img src="/posts/22469/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230328155950.png"></p><h3 id="坑-3"><a href="#坑-3" class="headerlink" title="坑"></a>坑</h3><p>这个题目也比较有意思，一开始我还以为要用数组模拟来做（这应该也算一个坑吧）但是后来画了图之后发现，原来是考的进制，这个字符串明显就是一个二十六进制的数，问倒数第几个数罢了，第一次出错的地方是在倒数第最后一位，因为本来进位的逻辑是直接取模，以两位数为例子，如果676直接取模的话得到100，打印出来就是zz显然是不对的，直接在一开始减一，再取模的话就是25，25这就没问题了，</p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Z2018;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class 倒数第N个字符串 &#123;</span><br><span class="line">    static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">    static StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line"></span><br><span class="line">    static int[] jzb = new int[10];</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int l = readInt();</span><br><span class="line">        int n = readInt();</span><br><span class="line">        char[] a = new char[l];</span><br><span class="line">        Arrays.fill(a,&#x27;z&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0; i &lt; l + 1; i++) &#123;</span><br><span class="line">            jzb[count++] = n % 26;</span><br><span class="line">            n /= 26;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (jzb[0] != 0)jzb[0] -= 1;</span><br><span class="line">        if (jzb[l] != 0) &#123;</span><br><span class="line">            for (int i = 0; i &lt; jzb.length; i++) &#123;</span><br><span class="line">                jzb[i] = 25;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count -= 2;</span><br><span class="line">        for (int i = 0; i &lt; l; i++) &#123;</span><br><span class="line">            a[i] = (char)(a[i] - jzb[count--]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readSP () throws IOException &#123;</span><br><span class="line">        char aa[] = new char[5];</span><br><span class="line">        bf.read(aa);</span><br><span class="line">        return  aa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int readInt () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return (int)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String readStr () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char readChar () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.charAt(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readCharArray () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Z2018;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class 倒数第N个字符串_1 &#123;</span><br><span class="line">    static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">    static StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line"></span><br><span class="line">    static int[] jzb = new int[10];</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int l = readInt();</span><br><span class="line">        int n = readInt();</span><br><span class="line">        char[] a = new char[l];</span><br><span class="line">        Arrays.fill(a,&#x27;z&#x27;);</span><br><span class="line"></span><br><span class="line">        n--;</span><br><span class="line"></span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0; i &lt; l + 1; i++) &#123;</span><br><span class="line">            jzb[count++] = n % 26;</span><br><span class="line">            n /= 26;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count -= 2;</span><br><span class="line">        for (int i = 0; i &lt; l; i++) &#123;</span><br><span class="line">            a[i] = (char)(a[i] - jzb[count--]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readSP () throws IOException &#123;</span><br><span class="line">        char aa[] = new char[5];</span><br><span class="line">        bf.read(aa);</span><br><span class="line">        return  aa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int readInt () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return (int)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String readStr () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char readChar () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.charAt(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readCharArray () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Big</title>
      <link href="/posts/44751.html"/>
      <url>/posts/44751.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="BIG"><a href="#BIG" class="headerlink" title="BIG"></a>BIG</h1><p>什么东西很BIG？？？当然是数据啦，要不然你以为会是什么东西。。。[滑稽]</p><p>先上题目</p><p><img src="/posts/44751/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230325143407.png"></p><p>这道题有两种解题思路，一种是用高精度，一种是模拟除法</p><p>在这里我主要用的是Java自带的BigInteger类实现的高精度</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Z2017;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line">import java.math.BigInteger;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class 整除光棍 &#123;</span><br><span class="line">    static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">    static StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line"></span><br><span class="line">    //学习bigInteger</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        BigInteger s = new BigInteger(&quot;0&quot;);</span><br><span class="line">        BigInteger x = sc.nextBigInteger();</span><br><span class="line"></span><br><span class="line">        for (int i = 1;;i++) &#123;</span><br><span class="line">            s = s.multiply(new BigInteger(&quot;10&quot;)); // s* 10  返回s *10的值</span><br><span class="line">            s = s.add(new BigInteger(&quot;1&quot;)); // &#x27;s&#x27;+&#x27;1&#x27; 在个位补1  例如从0开始，s的值变依次转变为 0 1 11 111 1111</span><br><span class="line">            if(s.mod(x).equals(new BigInteger(&quot;0&quot;))) &#123;  //如果s除以输入的数模为0</span><br><span class="line">                System.out.println(s.divide(x).toString() + &quot; &quot; + i); // 输出s除以输入的数 + 1的个数</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readSP () throws IOException &#123;</span><br><span class="line">        char aa[] = new char[5];</span><br><span class="line">        bf.read(aa);</span><br><span class="line">        return  aa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int readInt () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return (int)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String readStr () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char readChar () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.charAt(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readCharArray () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是重要的不是这个题目，而是要熟悉Java中高精度类的使用</p><h1 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h1><p>BigInteger是Java中一个非常有用的类，用于处理任意精度整数，普通整数类型都有固定的位数限制，但是BigInteger类可以处理无限长度的整数</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ol><li>BigInteger <strong>add</strong>(BigInteger val)：将此BigInteger的值与给定BigInteger的值相加，并返回一个新的BigInteger对象。需要传入一个BigInteger对象作为参数。</li><li>BigInteger <strong>subtract</strong>(BigInteger val)：从此BigInteger的值中减去给定BigInteger的值，并返回一个新的BigInteger对象。需要传入一个BigInteger对象作为参数。</li><li>BigInteger <strong>multiply</strong>(BigInteger val)：将此BigInteger的值乘以给定BigInteger的值，并返回一个新的BigInteger对象。需要传入一个BigInteger对象作为参数。</li><li>BigInteger <strong>divide</strong>(BigInteger val)：将此BigInteger的值除以给定BigInteger的值，并返回一个新的BigInteger对象。需要传入一个BigInteger对象作为参数。如果除数为0，会抛出ArithmeticException异常。</li><li>BigInteger <strong>mod</strong>(BigInteger val)：返回此BigInteger除以给定BigInteger的余数，并返回一个新的BigInteger对象。需要传入一个BigInteger对象作为参数。如果除数为0，会抛出ArithmeticException异常。</li><li>BigInteger <strong>pow</strong>(int exponent)：返回此BigInteger的给定指数幂，并返回一个新的BigInteger对象。需要传入一个int类型的指数作为参数。</li><li>BigInteger <strong>gcd</strong>(BigInteger val)：返回此BigInteger和给定BigInteger的最大公约数，并返回一个新的BigInteger对象。需要传入一个BigInteger对象作为参数。</li><li>int <strong>compareTo</strong>(BigInteger val)：将此BigInteger与给定BigInteger进行比较。如果此BigInteger<strong>小于</strong>给定BigInteger，则<strong>返回一个负数</strong>；如果此BigInteger<strong>等于</strong>给定BigInteger，则<strong>返回0</strong>；如果此BigInteger<strong>大于</strong>给定BigInteger，则<strong>返回一个正数</strong>。需要传入一个BigInteger对象作为参数。</li><li>BigInteger <strong>negate</strong>()：返回此BigInteger的相反数，并返回一个新的BigInteger对象。</li><li>BigInteger <strong>abs</strong>()：返回此BigInteger的绝对值，并返回一个新的BigInteger对象。</li><li>BigInteger <strong>shiftLeft</strong>(int n)：将此BigInteger左移n位，并返回一个新的BigInteger对象。需要传入一个int类型的位数作为参数。</li><li>BigInteger <strong>shiftRight</strong>(int n)：将此BigInteger右移n位，并返回一个新的BigInteger对象。需要传入一个int类型的位数作为参数。</li></ol><h2 id="与基本类型间的转换"><a href="#与基本类型间的转换" class="headerlink" title="与基本类型间的转换"></a>与基本类型间的转换</h2><p>1.BigInteger转换为int或long类型：</p><p>使用BigInteger对象的<strong>intValue()<strong>方法可以</strong>将BigInteger对象转换为int类型</strong>，使用<strong>longValue()<strong>方法可以将</strong>BigInteger对象转换为long</strong>类型。需要注意的是，如果BigInteger对象超出了int或long类型的取值范围，转换结果可能会丢失精度，因此在进行转换之前应该检查BigInteger对象的大小。</p><p>2.int或long类型转换为BigInteger：</p><p>使用BigInteger类的<strong>valueOf()<strong>方法可以</strong>将int或long类型转换为BigInteger对象</strong>。这个方法有两个重载形式，一个接受一个long类型的参数，另一个接受一个int类型的参数。</p><p>3.String类型转换为BigInteger：</p><p>使用<strong>BigInteger类的构造方法可以将String类型转换为BigInteger对象</strong>。这个构造方法接受一个String类型的参数，用于表示BigInteger对象的值。</p><h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>bigdecimal是Java中一个用于高精度计算的类，用于处理需要高精度的小数运算和金额计算等场景，和基本数据类型的浮点数相比，这个类可以准确的表示任意位数的小数，并且不会产生摄入误差</p><p>使用这个类需要注意的是，BigDecimal对象不可变（BigIneger也是一样的），对BigDecimal对象的任何修改都会返回一个新的BigDecimal对象，因此，在对BigDecimal进行运算时，需要将结果保存在新的BigDecimal对象中</p><h2 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h2><ol><li>BigDecimal <strong>add</strong>(BigDecimal augend)：将此BigDecimal与指定的BigDecimal相加，返回一个新的BigDecimal对象。</li><li>BigDecimal <strong>subtract</strong>(BigDecimal subtrahend)：从此BigDecimal中减去指定的BigDecimal，返回一个新的BigDecimal对象。</li><li>BigDecimal <strong>multiply</strong>(BigDecimal multiplicand)：将此BigDecimal与指定的BigDecimal相乘，返回一个新的BigDecimal对象。</li><li>BigDecimal <strong>divide</strong>(BigDecimal divisor, int scale, RoundingMode roundingMode)：将此BigDecimal除以指定的BigDecimal，使用指定的舍入模式将结果四舍五入到指定的小数位数，返回一个新的BigDecimal对象。</li><li>BigDecimal <strong>remainder</strong>(BigDecimal divisor)：返回此BigDecimal除以指定的BigDecimal的余数，返回一个新的BigDecimal对象。</li><li>BigDecimal <strong>pow</strong>(int n)：返回此BigDecimal的n次幂，返回一个新的BigDecimal对象。</li><li>BigDecimal <strong>abs</strong>()：返回此BigDecimal的绝对值，返回一个新的BigDecimal对象。</li><li>BigDecimal <strong>negate</strong>()：返回此BigDecimal的相反数，返回一个新的BigDecimal对象。</li><li>int <strong>compareTo</strong>(BigDecimal val)：将此BigDecimal与指定的BigDecimal进行比较，返回一个整数。如果此BigDecimal小于指定的BigDecimal，则返回负整数；如果此BigDecimal等于指定的BigDecimal，则返回0；如果此BigDecimal大于指定的BigDecimal，则返回正整数。</li></ol><h3 id="与基本数据类型间的转换"><a href="#与基本数据类型间的转换" class="headerlink" title="与基本数据类型间的转换"></a>与基本数据类型间的转换</h3><ol><li>double <strong>doubleValue</strong>()：将此BigDecimal转换为double类型。</li><li>float <strong>floatValue</strong>()：将此BigDecimal转换为float类型。</li><li>long <strong>longValue</strong>()：将此BigDecimal转换为long类型。</li><li>int <strong>intValue</strong>()：将此BigDecimal转换为int类型。</li></ol><h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><ol><li>BigInteger和BigDecimal是不可变对象，每次对它们进行操作都会返回一个新的对象，因此在处理大量数据时，需要考虑内存的使用和性能的问题。</li><li>对于BigDecimal对象的比较操作，需要使用compareTo方法而不是equals方法。这是因为<strong>equals</strong>方法在比较两个BigDecimal对象时，<strong>会比较它们的值和精度</strong>，而不仅仅是它们的值。因此，如果两个BigDecimal对象的值相等但精度不同，equals方法会返回false。而compareTo方法则只比较值的大小，不考虑精度。</li><li>在进行BigDecimal对象的除法运算时，需要注意<strong>除数不能为0</strong>的情况，否则会抛出ArithmeticException异常。同时，需要指定保留小数位数和舍入模式，否则可能会得到一个不精确的结果。</li><li>在进行BigInteger对象的除法运算时，需要注意被<strong>除数不能为0</strong>的情况，否则会抛出ArithmeticException异常。同时，需要使用divide方法的重载形式指定舍入模式，否则可能会得到一个不精确的结果。</li><li>在使用BigInteger和BigDecimal对象时，需要注意它们的位数限制。由于这两个类是基于内存的，因此它们的位数限制取决于计算机内存的大小。在处理特别大的数值时，可能需要使用其他技术，如分布式计算或使用第三方库。</li><li>在使用BigInteger和BigDecimal对象时，需要注意它们的精度限制。由于浮点数的精度是有限的，因此对于某些计算，可能需要使用BigDecimal类来保证精度。例如，在进行货币计算时，需要使用BigDecimal类来避免舍入误差。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我与AI</title>
      <link href="/posts/53343.html"/>
      <url>/posts/53343.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="我与AI"><a href="#我与AI" class="headerlink" title="我与AI"></a>我与AI</h1><p>​我自己算是最早的一批感受到ChatGPT有多强的人，随着自己对AI领域知识了解的逐渐增加，愈发觉得自己将来可能会被AI取代，人生第一次由衷的觉得我们的科技发展的太快了，感觉自己快要跟不上，第一次产生害怕被时代远远甩在后头的恐惧</p><p>​在低版本的时候我就觉得普通的码农肯定会被取代，但是随着AI版本的提高，到现在的GhatGPT4,我逐渐感觉被取代的可能不只是码农，随着AI智能的不断增加我有理由相信在未来我们可以实现只要说出需求人工智能就能编写出对应的程序</p><p>​以后的开发流程完全可能是一个人代替之前的十个人，一个开发团队可能只会需要一个产品经理，我们的出路在哪里呢？使用AI，如何更好的，更有效率的去使用AI，应该是我应该去关注的重点，所以我修改了我博客的副标题——积极拥抱新技术，如何去更好的，更有效率的去使用AI ，以及如何使用AI去编写一个大型的程序，其实从表面上看，AI可能是会取代现在的相当大的一部分人，但其中也包含着机会，AI让每个人都能有机会去接触他们并不熟悉的领域。</p><p>​所以我在这里给自己定一个小目标，在AI的帮助下学习关于软件扩展的知识，尝试将ChatGPT的API接到自己想要的软件上。</p><p>​其实如果人工智能真的保持一定的速度持续发展下去，我相信被取代的绝对不仅仅是程序员，试想一下，把人工智能接到机器上面，让AI去执行以前需要一定人类智能的流水线操作，有多少流水线岗位会被取代</p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>愿天下有情人都是失散多年的兄妹</title>
      <link href="/posts/34527.html"/>
      <url>/posts/34527.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="兄妹"><a href="#兄妹" class="headerlink" title="兄妹"></a>兄妹</h1><p>这句话表达了一种希望，希望所有有情人都能够像失散多年的兄妹一样相互关爱、相互扶持。这种关系是亲密而纯洁的，没有任何的欲望和争斗，只有相互的理解和支持。这样的愿望是美好的，也是值得我们去追求的。CSDN上的人工智能回答的，感觉一般般，感觉没有ChatGPT智能</p><p>开个玩笑，接下来看看题目</p><p><img src="/posts/34527/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230322172124.png"></p><p><img src="/posts/34527/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230322172151.png"></p><p><img src="/posts/34527/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230322172203.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题我乍一看，亲戚关系，猛地想到，并查集，但是仔细想了想还是得用DFS，深度优先搜索，给我们两个人，向上翻五代，如果五代之内有相同的父母，那么就不能结婚，如果不可考，那么算可以，在递归的时候我们传入两个参数，如果深度大于四，结束递归，否则，获取x的父母和y的父母，如果两个人的父母都可考，且有相等的，那么我们返回false，结束递归，否则，判断x的母亲和y的母亲有没有相同父母，x的父亲和y的父亲有没有相等的，x的父亲和y的母亲有没有相等父母，x的母亲和y的父亲有没有相等父母，只要有一个返回false那么结束递归。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Trial.兄妹;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class p2 &#123;</span><br><span class="line">    static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">    static StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line"></span><br><span class="line">    static int[] id = new int[100000];</span><br><span class="line">    static String[] sex = new String[100000];</span><br><span class="line">    static int[] fid = new int[100000];</span><br><span class="line">    static int[] mid = new int[100000];</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Arrays.fill(fid, -1);</span><br><span class="line">        Arrays.fill(mid, -1);</span><br><span class="line">        int n = nextInt();</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            id[i] = nextInt();</span><br><span class="line">            sex[i] = next();</span><br><span class="line">            fid[i] = nextInt();</span><br><span class="line">            mid[i] = nextInt();</span><br><span class="line">            if (fid[i] != -1) &#123;</span><br><span class="line">                sex[fid[i]] = &quot;M&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mid[i] != -1) &#123;</span><br><span class="line">                sex[mid[i]] = &quot;F&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int k = nextInt();</span><br><span class="line">        for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">            int xid = nextInt();</span><br><span class="line">            int yid = nextInt();</span><br><span class="line">            if (sex[xid].equals(sex[yid])) &#123;</span><br><span class="line">                System.out.println(&quot;Never Mind&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (DFS(xid, yid, 1)) &#123;</span><br><span class="line">                    System.out.println(&quot;Yes&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.println(&quot;No&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static boolean DFS (int xid, int yid, int deep) &#123;</span><br><span class="line">        if (xid == -1 || yid == -1 || deep &gt; 5) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int xfid = -1;</span><br><span class="line">        int xmid = -1;</span><br><span class="line">        int yfid = -1;</span><br><span class="line">        int ymid = -1;</span><br><span class="line">        xfid = fid[xid];</span><br><span class="line">        xmid = mid[xid];</span><br><span class="line">        yfid = fid[yid];</span><br><span class="line">        ymid = mid[yid];</span><br><span class="line">        if (xfid != -1 &amp;&amp; xfid == yfid || xmid != -1 &amp;&amp; xmid == ymid) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deep++;</span><br><span class="line">        return DFS(xfid, yfid, deep) &amp;&amp; DFS(xmid, ymid, deep) &amp;&amp; DFS(xfid, ymid, deep) &amp;&amp; DFS(xmid, yfid, deep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int nextInt () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return (int)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static String next () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个代码只得了18分，具体差在哪我还真的没找到</p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>列车调度</title>
      <link href="/posts/36741.html"/>
      <url>/posts/36741.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="列车调度"><a href="#列车调度" class="headerlink" title="列车调度"></a>列车调度</h1><p>这是一道理解题意之后十分容易使用栈这种数据结构进行模拟的题目，个人觉得有一点要注意的是一条铁轨并不是只能停一辆火车，一开始理解错题目了，苦想用例答案为什么会是四</p><p><img src="/posts/36741/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230321212027.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><img src="/posts/36741/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230321212844.png"></p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Trial.列车调度;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class p01_1 &#123;</span><br><span class="line">    static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">    static StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line">    static Stack&lt;Stack&lt;Integer&gt;&gt; mp = new Stack&lt;&gt;();</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        inItStack();</span><br><span class="line">        int n = readInt();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            int c = readInt();</span><br><span class="line">            add(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(mp.size());</span><br><span class="line">    &#125;</span><br><span class="line">    static void inItStack () &#123;</span><br><span class="line">        Stack&lt;Integer&gt; item = new Stack&lt;&gt;();</span><br><span class="line">        item.add(1000000);</span><br><span class="line">        mp.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void add(int c) &#123;</span><br><span class="line">        for (int i = 0; i &lt; mp.size(); i++) &#123;</span><br><span class="line">            int temp = mp.get(i).peek();</span><br><span class="line">            if (c &lt; temp) &#123;</span><br><span class="line">                mp.get(i).add(c);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; item = new Stack&lt;&gt;();</span><br><span class="line">        item.add(c);</span><br><span class="line">        mp.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int readInt() throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return (int)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己用栈模拟的代码最后果然不出我所料，超时了，然后在网上找到了一份比较有技术含量的题解</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Trial.列车调度;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.BufferedWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.io.OutputStreamWriter;</span><br><span class="line">import java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class copy &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Reader.init(System.in);</span><br><span class="line">        Writer.init(System.out);</span><br><span class="line">        solve();</span><br><span class="line">        Writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void solve() throws IOException &#123;</span><br><span class="line">        int n = Reader.nextInt();</span><br><span class="line">        map = new int[n];</span><br><span class="line">        int count = 0;</span><br><span class="line">        map[count++] = Reader.nextInt();</span><br><span class="line">        n--;</span><br><span class="line">        while (n-- &gt; 0) &#123;</span><br><span class="line">            int id = Reader.nextInt();</span><br><span class="line">            if (map[count-1] &lt; id) &#123;</span><br><span class="line">                map[count++] = id;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            int low = 0;</span><br><span class="line">            int high = count - 1;</span><br><span class="line">            while (low &lt; high) &#123;</span><br><span class="line">                int mid = (low + high) &gt;&gt; 1;</span><br><span class="line">                if (id &lt; map[mid]) &#123;</span><br><span class="line">                    high = mid;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    low = mid + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map[low] = id;</span><br><span class="line">        &#125;</span><br><span class="line">        Writer.print(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int[] map;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Class for buffered reading int and double values *//*</span><br><span class="line">class Reader &#123;</span><br><span class="line">    static BufferedReader reader;</span><br><span class="line">    static StringTokenizer tokenizer;</span><br><span class="line"></span><br><span class="line">    // ** call this method to initialize reader for InputStream *//*</span><br><span class="line">    static void init(InputStream input) &#123;</span><br><span class="line">        reader = new BufferedReader(new InputStreamReader(input));</span><br><span class="line">        tokenizer = new StringTokenizer(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ** get next word *//*</span><br><span class="line">    static String next() throws IOException &#123;</span><br><span class="line">        while (!tokenizer.hasMoreTokens()) &#123;</span><br><span class="line">            // TODO add check for eof if necessary</span><br><span class="line">            tokenizer = new StringTokenizer(reader.readLine());</span><br><span class="line">        &#125;</span><br><span class="line">        return tokenizer.nextToken();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String nextLine() throws IOException &#123;</span><br><span class="line">        return reader.readLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int nextInt() throws IOException &#123;</span><br><span class="line">        return Integer.parseInt(next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char nextChar() throws IOException &#123;</span><br><span class="line">        return next().toCharArray()[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static float nextFloat() throws IOException &#123;</span><br><span class="line">        return Float.parseFloat(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Writer &#123;</span><br><span class="line">    static BufferedWriter writer;</span><br><span class="line"></span><br><span class="line">    static void init(OutputStream outputStream) &#123;</span><br><span class="line">        writer = new BufferedWriter(new OutputStreamWriter(outputStream));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void print(Object object) throws IOException &#123;</span><br><span class="line">        writer.write(object.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void println(Object object) throws IOException &#123;</span><br><span class="line">        writer.write(object.toString());</span><br><span class="line">        writer.write(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void close() throws IOException &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我将快读写成了方法以为很好用了，没想到有人竟然将快读跟快输都写成了类，这里面的读入方法我还没试过，比较好奇的是他能不能实现对一个单词中的挨个字符进行读取。。。。。要不现在先试试吧。。。刚试了试。。。也会跳过，算了算了，只不过他这种编程的思路可以借鉴，自己重写一个专门用于读入和输出的类</p><p>再说一说思路，我是用栈模拟，但实际上栈中储存了什么，储存了多少并不重要，重要的 是栈的大小罢了，他用的一维数组进行模拟，数组中的一个元素就相当于我一条栈的入口，如果一个元素符合进栈的要求就直接把数据存进该位置最后计算数组中元素不为0，也就是入口不为空的元素有多少个就可以了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红色警报</title>
      <link href="/posts/63117.html"/>
      <url>/posts/63117.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="红色警报"><a href="#红色警报" class="headerlink" title="红色警报"></a>红色警报</h1><p>并查集使用第二弹，上次使用并查集是体会了集合的合并于查找，这次的题目让我体会了什么是“维护联通性”，在这个题目中，我们依然使用一个二维数组来储存两个对象之间的关系，上次是保存两个人之间是不是仇敌，这次是保存两个城市之间是否联通，而且学到一个新词，连通块</p><p>先上题目</p><p><img src="/posts/63117/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320215946.png"></p><p><img src="/posts/63117/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320215946.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在这个题目中，我们首先使用一个二维数组储存两个城市之间是否连续的逻辑关系，并且在并查集数组将两个互相连通的元素合并到一个集合当中，这时候，连通块的概念就出现了，连通块其实指的就是集合中公最远公共祖先的数量，也就是集合的数目，假设有五个城市，其中三个是连通的，算是集合A，另外两个也是连通的，算是集合B，这两个集合之间不连通，那么这两个集合就会有两个代表元素，两个公共祖先，如果集合A中的三个元素之间的连接断开了，那么这时候集合中就有四个连通块，通过查询并查集中连通块的数目我们就可以知道一个城市被攻占之后是否会对其他城市的连通性产生影响</p><p>所以在这个题目中，我们首先使用一个二维数组储存两个城市之间是否连续的逻辑关系，并且在并查集数组将两个互相连通的元素合并到一个集合当中，记录原本的连通块数量，如果一个城市被攻占，那么我们改变二维数组中的值，然后根据二维数组中的值去重新构建一个并查集，然后计算其中连通块的数量，如果两次的连通块数量相等或者比原来的多一个（被攻占的城市自己也算一个连通块）相等，那么这一个城市被攻占就不会对其他城市的连通性产生影响（反正如果连通块增加数量大于一那就是出问题了）反之则会</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Trial.红色警报;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line">import java.math.BigInteger;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class 红色警报 &#123;</span><br><span class="line">    static int[] a = new int[510];</span><br><span class="line">    static int[][] aa = new int[510][510];</span><br><span class="line">    static int n = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int cnt = 0;//原本连通块数量</span><br><span class="line">        int cnt2 = 0;//修改后连通块数量</span><br><span class="line">        int flag = 0;//判断是否GAMEOVER</span><br><span class="line"></span><br><span class="line">        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line">        st.nextToken();</span><br><span class="line">        n = (int)st.nval;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        int m = (int)st.nval;</span><br><span class="line">        inIt();</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int n1 = (int)st.nval;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int n2 = (int)st.nval;</span><br><span class="line">            aa[n1][n2] = aa[n2][n1] = 1;</span><br><span class="line">            union(n1, n2);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (i == find(i)) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        int k = (int)st.nval;</span><br><span class="line">        if (k == n) &#123;</span><br><span class="line">            flag = 1;</span><br><span class="line">        &#125;</span><br><span class="line">            for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                int x = (int)st.nval;</span><br><span class="line">                inIt();</span><br><span class="line">                cnt2 = 0;</span><br><span class="line">                for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                    aa[x][j] = aa[j][x] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                    for (int l = 0; l &lt; n; l++) &#123;</span><br><span class="line">                        if (aa[j][l] == 1) union(j, l);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                    if (j == find(j)) cnt2++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (cnt2 &lt;= cnt + 1) &#123;</span><br><span class="line">                    System.out.println(&quot;City &quot;+x+&quot; is lost.&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.println(&quot;Red Alert: City &quot;+x+&quot; is lost!&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                cnt = cnt2;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        if (flag == 1) &#123;</span><br><span class="line">            System.out.println(&quot;Game Over.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void inIt () &#123;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            a[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int find (int i) &#123;</span><br><span class="line">        if (a[i] == i) &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return a[i] = find(a[i]);//依然cai&#x27;qu</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void union (int i, int j) &#123;</span><br><span class="line">        int iF = find(i);</span><br><span class="line">        int jF = find(j);</span><br><span class="line">        if (iF != jF) &#123;</span><br><span class="line">            a[jF] = iF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转二叉树</title>
      <link href="/posts/29808.html"/>
      <url>/posts/29808.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="玩转二叉树"><a href="#玩转二叉树" class="headerlink" title="玩转二叉树"></a>玩转二叉树</h1><p>幸好假期自学了数据结构，能看得出知识点在哪</p><p>1.根据前序遍历和中序遍历构造二叉树</p><p>2.镜面反转</p><p>3.二叉树的层序遍历</p><p><img src="/posts/29808/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320215946.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先是根据前序遍历和中序遍历来构建二叉树</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; inorder.length; i++) &#123; // 用map保存中序序列的数值对应位置</span><br><span class="line">        map.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return findNode(preorder, 0, preorder.length, inorder,  0, inorder.length);  // 前闭后开</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public TreeNode findNode(int[] preorder, int preBegin, int preEnd, int[] inorder, int inBegin, int inEnd) &#123;</span><br><span class="line">    // 参数里的范围都是前闭后开</span><br><span class="line">    if (preBegin &gt;= preEnd || inBegin &gt;= inEnd) &#123;  // 不满足左闭右开，说明没有元素，返回空树</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int rootIndex = map.get(preorder[preBegin]);  // 找到前序遍历的第一个元素在中序遍历中的位置</span><br><span class="line">    TreeNode root = new TreeNode(inorder[rootIndex]);  // 构造结点</span><br><span class="line">    int lenOfLeft = rootIndex - inBegin;  //// 保存中序左子树个数（结点位置，减去中序开始位置），用来确定前序数列的个数</span><br><span class="line">    //这里思路要非常清楚除非想陷入改bug地狱，尤其是在处理前序遍历下标的时候</span><br><span class="line">    root.left = findNode(preorder, preBegin + 1, preBegin + lenOfLeft + 1,//前序遍历结束位置等于前序开始位置加上左子树大小加上一</span><br><span class="line">            inorder, inBegin, rootIndex);</span><br><span class="line">    root.right = findNode(preorder, preBegin + lenOfLeft + 1, preEnd,//开始位置等于前序开始位置加上左子树个数</span><br><span class="line">            inorder, rootIndex + 1, inEnd);</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法看着复杂其实也就还行，首先是建树的方法，我们往这个方法里传入两个数组，也就是前序遍历和中续遍历的结果，先用哈希表将数组元素变成下标以便我们找到对应的数据，方便我们直接根据某个值直接找到对应元素的位置然后使用findNode方法构造结点</p><p>findNode方法包含六个参数，前序数组，开始位置，结束位置，中序数组，开始位置，结束位置（注意全部都是左闭右开）如果开始位置大于等于结束位置，说明没有元素，返回空结点，如果存在元素，则找到前序数组中第一个元素在中序数组中的位置，然后构造新节点，在确定左子树元素个数，将左子树返回值赋给左节点，右子树返回值赋给右结点，完事，返回当前结点</p><p>镜像交换比较简单，直接上代码</p><p>&#96;&#96;注意是否为叶子结点即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void change (Node a) &#123;</span><br><span class="line">    if (a == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125; else if (a.leftNode == null &amp;&amp; a.rightNode == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Node cur = a.rightNode;</span><br><span class="line">        a.rightNode = a.leftNode;</span><br><span class="line">        a.leftNode = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    change(a.leftNode);</span><br><span class="line">    change(a.rightNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层序遍历我还没想到有可以在迭代的过程中打印的，我用的递归，存在二维链表中，结束后再打印链表中元素，注意要传入一个参数来判断深度是否需要增加新的链表</p><p><code>static List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void cengXu (Node a, int deep) &#123;</span><br><span class="line">    if (a == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    deep++;</span><br><span class="line">    if (ans.size() &lt; deep) &#123;</span><br><span class="line">        List&lt;Integer&gt; item = new ArrayList&lt;&gt;();</span><br><span class="line">        ans.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.get(deep - 1).add(a.num);</span><br><span class="line">    cengXu(a.leftNode, deep);</span><br><span class="line">    cengXu(a.rightNode, deep);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class 二叉树 &#123;</span><br><span class="line">    static Map&lt;Integer, Integer&gt; map;</span><br><span class="line">    static List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line">        st.nextToken();</span><br><span class="line">        int n = (int)st.nval;</span><br><span class="line">        int[] zx = new int[n];</span><br><span class="line">        int[] qx = new int[n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            zx[i] = (int)st.nval;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            qx[i] = (int)st.nval;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node first = createTree(qx, zx);</span><br><span class="line">        change(first);</span><br><span class="line"></span><br><span class="line">        int deep = 0;</span><br><span class="line">        cengXu(first, deep);</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; ans.size(); i++) &#123;</span><br><span class="line">            for (int i1 = 0; i1 &lt; ans.get(i).size(); i1++) &#123;</span><br><span class="line">                sb.append(ans.get(i).get(i1)+&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sb.deleteCharAt(sb.length() - 1);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排座位</title>
      <link href="/posts/55749.html"/>
      <url>/posts/55749.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="排座位"><a href="#排座位" class="headerlink" title="排座位"></a>排座位</h1><p><img src="/posts/55749/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320213126.png"></p><p><img src="/posts/55749/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320213137.png"></p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集是一种用于处理集合合并及查询问题的数据结构，在并查集种，每个元素都有一个父节点，表示它所属的集合。并查集支持两种操作：合并两个集合和查询某个元素所在的集合。其中查询操作通常用于检测两个元素是否属于同一个集合</p><p>并查集的基本思想是将元素分组，每个组内元素之间存在一种特殊的关系，可以通过这种关系来判断元素是否属于同一个集合，在并查集种，每个元素都有一个代表元，也称为根结点，也是公共祖先，表示该元素所属的集合。当两个集合需要合并时，只需要将其中一个集合的根节点设置为 另一个集合的根节点即可。这样，就可以将两个集合合并为一个集合</p><p>并查集的主要应用场景包括网络连通性问题，图的连通性问题等。</p><p>并查集来维护一组联通的结点，快速查询两个结点之间是否存在联通路径</p><p>实现</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Q2016.排座位;</span><br><span class="line"></span><br><span class="line">public class 并查集 &#123;</span><br><span class="line">    public static int[] a = new int[100000];</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //合并两个东西合并两个东西，可以为元素与元素，也可以为集合与集合，也可以为集合与元素</span><br><span class="line">    public static void union (int i, int j) &#123;</span><br><span class="line">        int iFather = find(i);//查找i的祖先</span><br><span class="line">        int jFather = find(j);//查找j的祖先</span><br><span class="line">        a[jFather] = iFather;//j的祖先指向i的祖先</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //普通查找，如果需要查找的次数多，不建议用此方法</span><br><span class="line">    public static int find(int i) &#123;</span><br><span class="line">        if (a[i] == i) &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return find(a[i]); //查找父节点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //压缩路径，让一条链表上的所有元素全部指向他们的公共祖先，如果需要多次查找建议使用</span><br><span class="line">    public static int ys (int i) &#123;</span><br><span class="line">        if (a[i] == i) &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            a[i] = ys(a[i]);</span><br><span class="line">            return a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化,理解，位置，与位置储存数值的含义</span><br><span class="line">    public static void inIt (int[] a) &#123;</span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/55749/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320214020.png">一堆元素</p><p><img src="/posts/55749/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320214826.png"></p><p>存在关系，合并之后</p><p><img src="/posts/55749/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320214831.png"></p><p>压缩路径之后的样子</p><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><p>那么这个题目最大的难点就在于我们如何判断两个人之间是否有公共朋友，这个我们就可以使用并查集，把是朋友的分到一个集合当中，通过查找一个元素与一个元素之间是否存在公共祖先就可以快速判断两个人是否有公共朋友</p><p>而且我们可以使用一个二维数组来储存两个人时间的关系，（新的数据安排）</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Q2016.排座位;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line">public class 排座位 &#123;</span><br><span class="line">    public static int[] a = new int[110];//并查集</span><br><span class="line">    public static int[][] aa = new int[110][110];//存关系</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line">        st.nextToken();</span><br><span class="line">        int n = (int)st.nval;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        int m = (int)st.nval;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        int k = (int)st.nval;</span><br><span class="line">        inIt();</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int b1 = (int)st.nval;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int b2 = (int)st.nval;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int gx = (int)st.nval;</span><br><span class="line">            if (gx == -1) &#123;//如果是死对头，矩阵中进行标记</span><br><span class="line">                aa[b1][b2] = aa[b2][b1] = -1;</span><br><span class="line">            &#125; else &#123;//如果是朋友，进行合并</span><br><span class="line">                union(b1, b2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int c1 = (int)st.nval;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int c2 = (int)st.nval;</span><br><span class="line">            if (ys(c1) == ys(c2) &amp;&amp; aa[c1][c2] != -1) &#123;//有公共朋友，不是敌人</span><br><span class="line">                System.out.println(&quot;No problem&quot;);</span><br><span class="line">            &#125; else if (ys(c1) == ys(c2) &amp;&amp; aa[c1][c2] == -1) &#123;//有公共朋友，是敌人</span><br><span class="line">                System.out.println(&quot;OK but...&quot;);</span><br><span class="line">            &#125; else if (ys(c1) != ys(c2) &amp;&amp; aa[c1][c2] != -1) &#123;//无公共朋友，不是敌人</span><br><span class="line">                System.out.println(&quot;OK&quot;);</span><br><span class="line">            &#125; else if (ys(c1) != ys(c2) &amp;&amp; aa[c1][c2] == -1) &#123;//无公共朋友，是敌人</span><br><span class="line">                System.out.println(&quot;No way&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//初始化——让元素的祖先变成自己</span><br><span class="line">    public static void inIt () &#123;</span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//压缩路径</span><br><span class="line">    public static int ys(int i) &#123;</span><br><span class="line">        if (a[i] == i) &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            a[i] = ys(a[i]);</span><br><span class="line">            return a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//合并</span><br><span class="line">    public static void union (int i, int j) &#123;</span><br><span class="line">        int iF = ys(i);</span><br><span class="line">        int jF = ys(j);</span><br><span class="line">        a[jF] = iF;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抢红包</title>
      <link href="/posts/37296.html"/>
      <url>/posts/37296.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="抢红包"><a href="#抢红包" class="headerlink" title="抢红包"></a>抢红包</h1><p> 这个题目首先想到的就是对对象进行排序，但是不出意料的超时了，然后将对象换成数组，加深了我对Arrarys.sort方法的理解，让我重洗思考了数据的安排，和重新看待二维数组</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/posts/37296/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320211541.png"></p><p><img src="/posts/37296/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320211603.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Q2016.抢红包;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line"></span><br><span class="line">class person &#123;</span><br><span class="line">    int count;</span><br><span class="line">    int name;</span><br><span class="line">    double sr;</span><br><span class="line"></span><br><span class="line">    public person(int name, double sr) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.sr = sr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class 抢红包 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line">        st.nextToken();</span><br><span class="line">        int n = (int)st.nval;</span><br><span class="line">        person[] ar = new person[n + 1];</span><br><span class="line">        for (int i = 0; i &lt; ar.length; i++) &#123;</span><br><span class="line">            ar[i] = new person(i, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int k = (int)st.nval;</span><br><span class="line">            for (int j = 0; j &lt; k; j++) &#123;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                int nn = (int)st.nval;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                int pp = (int)st.nval;</span><br><span class="line">                ar[nn].sr += pp;</span><br><span class="line">                ar[i].sr -= pp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">//这部分出错，排序依据先是收入，再是抢红包个数，再是名字</span><br><span class="line">        Arrays.sort(ar, new Comparator&lt;person&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(person o1, person o2) &#123;</span><br><span class="line">                if (o1.sr &gt; o2.sr) &#123;//sr是double</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125; else if (o1.sr &lt; o2.sr) &#123;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (o1.name &gt; o2.name) &#123;//name是字符串</span><br><span class="line">                        return 1;</span><br><span class="line">                    &#125; else if (o1.name &lt; o2.name)&#123;</span><br><span class="line">                        return -1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        for (int i = ar.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            if (ar[i].name != 0) &#123;</span><br><span class="line">                System.out.print(ar[i].name+&quot; &quot;);</span><br><span class="line">                System.out.printf(&quot;%.2f&quot;,ar[i].sr / 100);</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一思路，尝试对对象数组进行排序，然后重写比较器</p><p>&#96;&#96;精简比较器部分代码，并改进其中错误</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.sort(ar, new Comparator&lt;person&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public int compare(person o1, person o2) &#123;</span><br><span class="line">               if (o1.sr != o2.sr) &#123;</span><br><span class="line">                   return Double.compare(o1.sr, o2.sr);</span><br><span class="line">               &#125; else if (o1.count != o2.count) &#123;</span><br><span class="line">                   return Integer.compare(o1.count, o2.count);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   return Integer.compare(o2.name, o1.name);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p>错误改进1</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class 抢红包_3 &#123;</span><br><span class="line">    public static int[][] person = new int[3][10010];</span><br><span class="line">    //sr</span><br><span class="line">    //count</span><br><span class="line">    //name;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line">        st.nextToken();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 10010; i ++) &#123;</span><br><span class="line">            person[2][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int n = (int)st.nval;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt;= n; i ++) &#123;</span><br><span class="line">            person[2][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int k = (int)st.nval;</span><br><span class="line">            for (int j = 0; j &lt; k; j++) &#123;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                int nn = (int)st.nval;//谁</span><br><span class="line">                st.nextToken();</span><br><span class="line">                int pp = (int)st.nval;//强到了多少</span><br><span class="line">                person[0][nn] += pp;</span><br><span class="line">                person[1][nn] ++;</span><br><span class="line">                person[0][i] -= pp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(person, 1, n + 1, Comparator.comparingInt(a -&gt; a[0]));</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            System.out.println(person[2][i]+&quot; &quot;+person[1][i]+&quot; &quot;+person[0][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个首先数据的安排就有问题，很明显，一列就相当于一个person第一行为收入，我们如果要根据第一行的收入进行排序，那么我们在sort里面就要交换三个元素，交换三个什么东西，但是Arrays.sort()只允许我们重写其中的比较方法不能重写交换的方法，那么我们一次就只能交换一个什么东西，所以无法用它对这个二维数组进行排序，除非我们自己手写sort方法，要不然就不行</p><p>正确答案</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Q2016.抢红包;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line"></span><br><span class="line">public class 抢红包_4 &#123;</span><br><span class="line">    public static int[][] per = new int[10010][3];</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line">        st.nextToken();</span><br><span class="line">        int n = (int)st.nval;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            per[i][2] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int k = (int)st.nval;</span><br><span class="line">            for (int j = 0; j &lt; k; j++) &#123;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                int nn = (int)st.nval;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                int pp = (int)st.nval;</span><br><span class="line">                per[nn][0] += pp;</span><br><span class="line">                per[nn][1] ++;</span><br><span class="line">                per[i][0] -= pp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(per,  1, n + 1, new Comparator&lt;int[]&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(int[] o1,int[] o2) &#123;</span><br><span class="line">                if (o1[0] != o2[0]) &#123;</span><br><span class="line">                    return Integer.compare(o2[0],o1[0]);</span><br><span class="line">                &#125; else if (o1[1] != o2[1]) &#123;</span><br><span class="line">                    return Integer.compare(o2[1],o1[1]);//默认少在前</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return Integer.compare(o1[2],o2[2]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            System.out.print(per[i][2] +&quot; &quot;);</span><br><span class="line">            System.out.printf(&quot;%.2f&quot; , per[i][0] * 1.0 / 100);;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次我们一行就是一个元素，就是一个人，这个就可以在Arrays.sort中进行排序这个时候我们交换的就是其中的一个子数组</p><p>反正这个题目对我这种彩笔来说挺典型的，尤其是对数据结构的安排上</p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA错题第三次收录</title>
      <link href="/posts/20284.html"/>
      <url>/posts/20284.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="嘟嘟可大骑士的犯二手册三"><a href="#嘟嘟可大骑士的犯二手册三" class="headerlink" title="嘟嘟可大骑士的犯二手册三"></a>嘟嘟可大骑士的犯二手册三</h2><p>这次只有一道题，这次犯的错误提醒我应该认真仔细的去考虑输入输出的问题，前两次已经看到了输出类型00000，说明数字不足五位数应该加上前导零，然后这个提示的输入。。。。非常有意思</p><h3 id="正整数A-B"><a href="#正整数A-B" class="headerlink" title="正整数A+B"></a>正整数A+B</h3><p><img src="/posts/20284/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230317140339.png"></p><p>至少存在一个空格，且第一个空格认为是A与B的分隔，说明第一个字符串不可能为空字符串，所以我十分有信心的写了下面的代码</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Trial;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class P1 &#123;</span><br><span class="line">    public static int aaa;</span><br><span class="line">    public static int bbb;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        String a = sc.nextLine();</span><br><span class="line">        String b = sc.nextLine();</span><br><span class="line">        char[] aa = a.toCharArray();</span><br><span class="line">        char[] bb = b.toCharArray();</span><br><span class="line">        //Arrays.copyOfRange()</span><br><span class="line">        boolean a1 = check(aa,a);</span><br><span class="line">        boolean a2 = check(bb,b);</span><br><span class="line"></span><br><span class="line">        if (a1 &amp;&amp; a2) &#123;</span><br><span class="line">            aaa = Integer.parseInt(a);</span><br><span class="line">            bbb = Integer.parseInt(b);</span><br><span class="line">            int c = aaa + bbb;</span><br><span class="line">            System.out.println(aaa+&quot; + &quot;+bbb+&quot; = &quot;+c);</span><br><span class="line">        &#125; else if (!a1 &amp;&amp; !a2) &#123;</span><br><span class="line">            System.out.println(&quot;? + ? = ?&quot;);</span><br><span class="line">        &#125; else if (a1 &amp;&amp; !a2) &#123;</span><br><span class="line">            aaa = Integer.parseInt(a);</span><br><span class="line">            System.out.println(aaa+&quot; + ? = ?&quot;);</span><br><span class="line">        &#125; else if (!a1 &amp;&amp; a2) &#123;</span><br><span class="line">            bbb = Integer.parseInt(b);</span><br><span class="line">            System.out.println(&quot;? + &quot; + bbb +&quot; = ?&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static boolean check(char[] a, String aa) &#123;</span><br><span class="line"></span><br><span class="line">        if (a.length &gt; 4) return false;</span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            if (a[i] &gt;= &#x27;0&#x27; &amp;&amp; a[i] &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int c = Integer.parseInt(aa);</span><br><span class="line">        if (c &gt; 1000 || c &lt; 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个测试点不能通过，用例是    输入  123 123 123 输出应该为123 + ？&#x3D; ？</p><p>题目中说至少存在一个空格，且无空字符串，但是可以有多个空格，在上面的例子由于我读取方法的错误所以得到的答案是123 + 123 &#x3D; 246 ，也就是说，我因为没有考虑到后面也有空格的情况从而让b少读取了一半</p><p>下面是修改后的代码</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Trial;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class P1 &#123;</span><br><span class="line">    public static int aaa;</span><br><span class="line">    public static int bbb;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        String aaaa = sc.nextLine();</span><br><span class="line">        String[] st = cf(aaaa);</span><br><span class="line">        String a = st[0];</span><br><span class="line">        String b = st[1];</span><br><span class="line">        char[] aa = a.toCharArray();</span><br><span class="line">        char[] bb = b.toCharArray();</span><br><span class="line">        //Arrays.copyOfRange()</span><br><span class="line">        boolean a1 = check(aa,a);</span><br><span class="line">        boolean a2 = check(bb,b);</span><br><span class="line"></span><br><span class="line">        if (a1 &amp;&amp; a2) &#123;</span><br><span class="line">            aaa = Integer.parseInt(a);</span><br><span class="line">            bbb = Integer.parseInt(b);</span><br><span class="line">            int c = aaa + bbb;</span><br><span class="line">            System.out.println(aaa+&quot; + &quot;+bbb+&quot; = &quot;+c);</span><br><span class="line">        &#125; else if (!a1 &amp;&amp; !a2) &#123;</span><br><span class="line">            System.out.println(&quot;? + ? = ?&quot;);</span><br><span class="line">        &#125; else if (a1 &amp;&amp; !a2) &#123;</span><br><span class="line">            aaa = Integer.parseInt(a);</span><br><span class="line">            System.out.println(aaa+&quot; + ? = ?&quot;);</span><br><span class="line">        &#125; else if (!a1 &amp;&amp; a2) &#123;</span><br><span class="line">            bbb = Integer.parseInt(b);</span><br><span class="line">            System.out.println(&quot;? + &quot; + bbb +&quot; = ?&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String[] cf (String a) &#123;</span><br><span class="line">        String[] k = new String[2];</span><br><span class="line">        int idx = 0;</span><br><span class="line">        char[] kk = a.toCharArray();</span><br><span class="line">        for (int i = 0; i &lt; kk.length; i++) &#123;</span><br><span class="line">            if (kk[i] == &#x27; &#x27;) &#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        char[] aa = Arrays.copyOfRange(kk, 0, idx);</span><br><span class="line">        char[] bb = Arrays.copyOfRange(kk, idx + 1, kk.length);</span><br><span class="line">        k[0] = String.valueOf(aa);</span><br><span class="line">        k[1] = String.valueOf(bb);</span><br><span class="line">        return k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean check(char[] a, String aa) &#123;</span><br><span class="line"></span><br><span class="line">        if (a.length &gt; 4) return false;</span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            if (a[i] &gt;= &#x27;0&#x27; &amp;&amp; a[i] &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int c = Integer.parseInt(aa);</span><br><span class="line">        if (c &gt; 1000 || c &lt; 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入输出~~~这是一个问题~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PTA错题第二次收录</title>
      <link href="/posts/59175.html"/>
      <url>/posts/59175.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="嘟嘟可大骑士的犯二手册二"><a href="#嘟嘟可大骑士的犯二手册二" class="headerlink" title="嘟嘟可大骑士的犯二手册二"></a>嘟嘟可大骑士的犯二手册二</h2><p>没错新一期的错题集，这次在刷题的时候我对修改的不同版本的代码进行保存，通过比较自己的第一思路与修改后通过的的代码之间的不同来发现自己哪些地方犯二</p><h3 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h3><p><img src="/posts/59175/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230317132515.png"></p><p>这个题目与2016年区域赛帅到没朋友非常相似，使用类似桶排的方法进行统计，然后遍历一次数组来确定答案，虽然并没有错但是当个典型题收集一下</p><p><img src="/posts/59175/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230317132904.png"></p><p>使用了快读，复习快读基本用法</p><h3 id="古风排序"><a href="#古风排序" class="headerlink" title="古风排序"></a>古风排序</h3><p><img src="/posts/59175/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230317134143.png"></p><p>这个题目相当有意思，我修改了两个版本的代码，两个代码之间只有一个区别，那就是是否对二维字符数组钟非原字符数组的部分进行初始化，虽然两者运行之后输出的答案一模一样，但是一个只能对三个测试点</p><p><img src="/posts/59175/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230317134409.png" alt="未对数组空白部分进行初始化"></p><p><img src="/posts/59175/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230317134437.png" alt="将数组空白部分打印为空格"></p><p>在Java中，如果一个char类型数组未被完全初始化，那么未被初始化的元素将被赋予默认值’\u0000’（null字符）。而在打印此元素时，可能会输出类似于空格的空白字符，因此上面两个代码在控制台中的输出看起来是一模一样的，然而实际上两个输出的值却并不相同</p><p><img src="/posts/59175/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230317134954.png"></p><p>这个题目看起来简单，实际上也很简单，只不过这个是我第一用快读尝试字符数字的混合读取，而且似乎让我找到了读取单个字符的方法</p><p><img src="/posts/59175/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230317135104.png"></p><p>只不过这个提醒了我现在依然存在的一个问题，那对这些输入输出的使用，原理，可以读取哪些内容，怎样读取这些内容还是不够熟悉。相当有必要认真学一下BuffereReader这个类</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PTA错题第一次收录</title>
      <link href="/posts/24812.html"/>
      <url>/posts/24812.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​唉感觉自己好菜，别人用几毫秒，几百kb就能做的题目我得用一百多毫秒，几千kb想想就心酸啊，这是pta错题第一次收录，希望能给自己长点记性</p><h3 id="判断素数"><a href="#判断素数" class="headerlink" title="判断素数"></a>判断素数</h3><p><img src="/posts/24812/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230316215838.png">&#96;</p><p>原本以为是因为读入数据的速度太慢，结果发现是因为自己少了特判 “  1  “，算是因祸得福吧，学了快输</p><p><img src="/posts/24812/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230316220118.png" alt="改进后的代码"></p><h3 id="到底有多二"><a href="#到底有多二" class="headerlink" title="到底有多二"></a>到底有多二</h3><p><img src="/posts/24812/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230316220258.png"></p><p>这个题目算是给我提了个醒，顺着题目的思路来看不清楚如果一位正数，且为偶数的数最后要不要乘二，但这不是因为她没说清楚，在以后的工作中应该很少有客户能直接说清楚自己的需求，但是在这个题目里如果在这里错了那我就应该往这个我不太清楚的地方去思考正数的偶数是不是也要乘二，其实错了并不奇怪，但是关键的是错了之后要知道往哪个地方去怀疑</p><p><code>错误代码</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Q2016;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class p01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        String a = sc.next();</span><br><span class="line">        double er = 0;</span><br><span class="line">        double ws = 0;</span><br><span class="line">        double ans = 0;</span><br><span class="line">        boolean fs = false;</span><br><span class="line">        boolean os = false;</span><br><span class="line"></span><br><span class="line">        char[] aa = a.toCharArray();</span><br><span class="line">        if (aa[0] == &#x27;-&#x27;) &#123;</span><br><span class="line">            fs = true;</span><br><span class="line">        &#125;</span><br><span class="line">        int cur = aa[aa.length - 1] - &#x27;0&#x27;;</span><br><span class="line">        if (cur % 2 == 0) &#123;</span><br><span class="line">            os = true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; aa.length; i++) &#123;</span><br><span class="line">            if ((aa[i] - &#x27;0&#x27;) == 2) &#123;</span><br><span class="line">                er++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (fs) &#123;</span><br><span class="line">            ws = aa.length - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ws = aa.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (fs) &#123;</span><br><span class="line">            if (os) &#123;</span><br><span class="line">                ans = er /ws * 1.5 * 2 * 100;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ans = er /ws * 1.5 * 100;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (os) &#123;</span><br><span class="line">                ans = er /ws * 1.0 * 2 * 100;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ans = er/ws * 1.0 * 100;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">            System.out.printf(&quot;%.2f&quot;, ans);</span><br><span class="line">            System.out.println(&quot;%&quot;);</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>正确代码</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Q2016;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class p01_1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        int ws = 0;</span><br><span class="line"></span><br><span class="line">        double er = 0;</span><br><span class="line">        double bs = 1;</span><br><span class="line">        double bss = 1;</span><br><span class="line">        double ans = 0;</span><br><span class="line"></span><br><span class="line">        String a = sc.next();</span><br><span class="line">        char[] aa = a.toCharArray();</span><br><span class="line">        if (aa[0] == &#x27;-&#x27;) &#123;</span><br><span class="line">            bs = 1.5;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ws = aa.length;</span><br><span class="line"></span><br><span class="line">        if (aa[aa.length - 1]%2 == 0) &#123;</span><br><span class="line">            bss = 2;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; aa.length; i++) &#123;</span><br><span class="line">            if (aa[i] == &#x27;2&#x27;) &#123;</span><br><span class="line">                er++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (aa[0] == &#x27;-&#x27;) &#123;</span><br><span class="line">            ws = ws - 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = er / ws * bs * bss * 100;</span><br><span class="line">        System.out.printf(&quot;%.2f&quot;, ans);</span><br><span class="line">        System.out.print(&quot;%&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大笨钟"><a href="#大笨钟" class="headerlink" title="大笨钟"></a>大笨钟</h3><p><img src="/posts/24812/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230316220751.png"></p><p>这个题目在端点时间理解错了，以为端点时间是12：00，但结果在12点的时候都不敲而且我的代码思路不够好</p><p><code>这个是我的垃圾代码</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Q2016;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class p01_1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        int ws = 0;</span><br><span class="line"></span><br><span class="line">        double er = 0;</span><br><span class="line">        double bs = 1;</span><br><span class="line">        double bss = 1;</span><br><span class="line">        double ans = 0;</span><br><span class="line"></span><br><span class="line">        String a = sc.next();</span><br><span class="line">        char[] aa = a.toCharArray();</span><br><span class="line">        if (aa[0] == &#x27;-&#x27;) &#123;</span><br><span class="line">            bs = 1.5;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ws = aa.length;</span><br><span class="line"></span><br><span class="line">        if (aa[aa.length - 1]%2 == 0) &#123;</span><br><span class="line">            bss = 2;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; aa.length; i++) &#123;</span><br><span class="line">            if (aa[i] == &#x27;2&#x27;) &#123;</span><br><span class="line">                er++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (aa[0] == &#x27;-&#x27;) &#123;</span><br><span class="line">            ws = ws - 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = er / ws * bs * bss * 100;</span><br><span class="line">        System.out.printf(&quot;%.2f&quot;, ans);</span><br><span class="line">        System.out.print(&quot;%&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">        using namespace std;</span><br><span class="line">        int main()&#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        scanf(&quot;%02d:%02d&quot;,&amp;a,&amp;b);</span><br><span class="line">        if(a&lt;=12)&#123;</span><br><span class="line">        printf(&quot;Only %02d:%02d.  Too early to Dang.&quot;,a,b);</span><br><span class="line">        &#125;else if(b==0)&#123;</span><br><span class="line">        for(int i=0;i&lt;(a-12);i++)&#123;</span><br><span class="line">        printf(&quot;Dang&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;else if(b&gt;0)&#123;</span><br><span class="line">        for(int i=0;i&lt;=(a-12);i++)&#123;</span><br><span class="line">        printf(&quot;Dang&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是别人的思路清晰且相当简洁的代码，学习，学习</p><h3 id="帅到没朋友"><a href="#帅到没朋友" class="headerlink" title="帅到没朋友"></a>帅到没朋友</h3><p><img src="/posts/24812/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230316221446.png"></p><p>这个题目相当有意思</p><p>我的第一思路是创建二维数组，然后遍历，但是越看越不对，因为相当可能会超时，然后我想到了桶排，虽然我能往这个思路靠，但是还是相当复杂，我的打算是用类似桶排的方法储存一个数出现的坐标，然后要查的时候遍历坐标所在的数组，但是后来我发现一个数可能出现在多个位置，所以储存坐标的想法并不可靠</p><p>答案的思想是利用类似桶排序的方法直接在读入数据的时候进行标记</p><p><img src="/posts/24812/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230316221716.png" alt="第一版代码"></p><p>这个代码在写的时候光想着当k&#x3D;&#x3D;1的时候不进行操作，结果忘记虽然不操作但数依然得读</p><p>而且这个题目有一个相当细节的地方  0 的写法是 00000 无论如何都得凑足五位数，所以输出部分也是错的</p><p><img src="/posts/24812/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230316222310.png" alt="第二版代码"></p><p>最后一个测试点超时，使用快读</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Q2016;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class p04_2 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line">        int[] id = new int[100000];</span><br><span class="line"></span><br><span class="line">        st.nextToken();</span><br><span class="line">        int n = (int)st.nval;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int k = (int)st.nval;</span><br><span class="line">            if (k &lt;= 1) &#123;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                int kk = (int)st.nval;;//错误在这里</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for (int i1 = 0; i1 &lt; k; i1++) &#123;</span><br><span class="line">                    st.nextToken();</span><br><span class="line">                    int cur = (int)st.nval;</span><br><span class="line">                    id[cur]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int flag = 0;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        int m = (int)st.nval;</span><br><span class="line">        int[] ans = new int[m];</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int cur = (int)st.nval;</span><br><span class="line">            if (id[cur] == 0) &#123;</span><br><span class="line">                flag ++;</span><br><span class="line">                ans[count++] = cur;</span><br><span class="line">                id[cur]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (flag == 0) &#123;</span><br><span class="line">            System.out.println(&quot;No one is handsome&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt; flag; i++) &#123;</span><br><span class="line">                System.out.printf(&quot;%05d&quot;, ans[i]);</span><br><span class="line">                if (i != flag - 1) &#123;</span><br><span class="line">                    System.out.print(&quot; &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是超时，数组去重</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Q2016;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class p04_3 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line">        int[] id = new int[100000];</span><br><span class="line"></span><br><span class="line">        st.nextToken();</span><br><span class="line">        int n = (int)st.nval;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int k = (int)st.nval;</span><br><span class="line">            if (k &lt;= 1) &#123;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                int kk = (int)st.nval;;//错误在这里</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for (int i1 = 0; i1 &lt; k; i1++) &#123;</span><br><span class="line">                    st.nextToken();</span><br><span class="line">                    int cur = (int)st.nval;</span><br><span class="line">                    id[cur]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        st.nextToken();</span><br><span class="line">        int m = (int)st.nval;</span><br><span class="line">        int[] idx = new int[m];</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            idx[i] = (int)st.nval;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        idx = removeDuplicates(idx);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int flag = 0;</span><br><span class="line">        int[] ans = new int[m];</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0; i &lt; idx.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            int cur = idx[i];</span><br><span class="line">            if (id[cur] == 0) &#123;</span><br><span class="line">                flag ++;</span><br><span class="line">                ans[count++] = cur;</span><br><span class="line">                id[cur]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (flag == 0) &#123;</span><br><span class="line">            System.out.println(&quot;No one is handsome&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt; flag; i++) &#123;</span><br><span class="line">                System.out.printf(&quot;%05d&quot;, ans[i]);</span><br><span class="line">                if (i != flag - 1) &#123;</span><br><span class="line">                    System.out.print(&quot; &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static int[] removeDuplicates(int[] arr) &#123;</span><br><span class="line">        return Arrays.stream(arr).distinct().toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是超时，于是去抄了几个，下面是一个用字符串做的</p><p><img src="/posts/24812/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230316222504.png"></p><p>翻遍CSDN，用Java写的就没有一个过的</p><p>果然，错的不是我，是语言</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java快读</title>
      <link href="/posts/54254.html"/>
      <url>/posts/54254.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java快读"><a href="#Java快读" class="headerlink" title="Java快读"></a>Java快读</h1><p>起因是因为PTA题目中求素数的题目没过，有大佬提示说是因为Java的Scanner类在读取的数据过多时会显得非常慢，于是就去网上找到了快读的教程</p><p>下面是使用快读与不使用快读的区别</p><p><img src="/posts/54254/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230316175903.png"></p><p><img src="/posts/54254/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230316175916.png"></p><h2 id="StreamTokenizer"><a href="#StreamTokenizer" class="headerlink" title="StreamTokenizer"></a>StreamTokenizer</h2><p>在Java中，StreamTokenizer 是一个用于将输入流分解为标记（tokens）的类。输入流可以是文件，网络连接或其他数据源，st可以将文本分解为数字，字符串，和特殊字符</p><p>st的工作方式类似于标准的Tokenizer类，但更加灵活，可以处理更多类型 的输入流，StreamTokenizer可以用于解析不同格式的数据</p><p>StreamTokenizer可以设置不同的分隔符和标记类型，以适应不同的输入格式。在使用StreamTokenizer时，我们需要指定输入流并设置分隔符和标记类型，然后我们可以逐个读取每个标记，并根据需要进行处理。</p><p>下面是从文件中读取标记的示例：</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class StreamTokenizerExample &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        FileReader fileReader = new FileReader(&quot;input.txt&quot;);</span><br><span class="line">        StreamTokenizer tokenizer = new StreamTokenizer(fileReader);</span><br><span class="line">        while (tokenizer.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            if (tokenizer.ttype == StreamTokenizer.TT_NUMBER) &#123;</span><br><span class="line">                System.out.println(&quot;Number: &quot; + tokenizer.nval);</span><br><span class="line">            &#125; else if (tokenizer.ttype == StreamTokenizer.TT_WORD) &#123;</span><br><span class="line">                System.out.println(&quot;Word: &quot; + tokenizer.sval);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(&quot;Special character: &quot; + (char)tokenizer.ttype);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fileReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>（1）导入io包<br>（2）在使用这个类时，函数要throws IOException<br>（3）StreamTokenizer re &#x3D; new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); 具体实现</p><p><code>读取整数</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String args[]) throws IOException &#123;</span><br><span class="line">        StreamTokenizer re = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));</span><br><span class="line">        //获取下一个标记，每次读取数据之前必须写一次</span><br><span class="line">        re.nextToken(); </span><br><span class="line">        int n = (int)re.nval;</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取字符串不需要加StreamTokenizer类直接写成BufferedReader re &#x3D; new BufferedReader(new InputStreamReader(System.in))；</p><p><code>读取字符串</code></p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String args[]) throws IOException&#123;</span><br><span class="line">//    StreamTokenizer re = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));</span><br><span class="line">        BufferedReader re = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        String x = re.readLine();//读取字符串时不需要nextToken()方法</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>混合读取</p><p><code>混合读取</code></p><p>错误示例</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String args[]) throws IOException&#123;</span><br><span class="line">        BufferedReader re = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer r = new StreamTokenizer(re);</span><br><span class="line">        r.nextToken(); int n = (int)r.nval;</span><br><span class="line">        String x = re.readLine();</span><br><span class="line">        System.out.println(n+&quot; &quot;+x);</span><br><span class="line">//    输入 </span><br><span class="line">//    3</span><br><span class="line">//    afadfa</span><br><span class="line">//    输出</span><br><span class="line">//    3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>残留换行符</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String args[]) throws IOException&#123;</span><br><span class="line">        BufferedReader re = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer r = new StreamTokenizer(re);</span><br><span class="line">        r.nextToken(); int n = (int)r.nval;</span><br><span class="line">        re.readLine();</span><br><span class="line">        String x = re.readLine();</span><br><span class="line">        System.out.println(n+&quot; &quot;+x);</span><br><span class="line">//    输入 </span><br><span class="line">//    3</span><br><span class="line">//    afadfa</span><br><span class="line">//    输出</span><br><span class="line">//    3 afadfa</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps快输</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String args[]) throws IOException&#123;</span><br><span class="line">        BufferedReader re = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer r = new StreamTokenizer(re);</span><br><span class="line">        PrintWriter pr = new PrintWriter(new OutputStreamWriter(System.out));</span><br><span class="line">        r.nextToken(); int n = (int)r.nval;</span><br><span class="line">        re.readLine();</span><br><span class="line">        String x = re.readLine();</span><br><span class="line">        pr.println(n+&quot; &quot;+x);</span><br><span class="line">        pr.flush();</span><br><span class="line">//    输入 </span><br><span class="line">//    3</span><br><span class="line">//    afadfa</span><br><span class="line">//    输出</span><br><span class="line">//    3 afadfa</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的没学，保存，以备不时之需</p><ol><li><p>读取多行数据</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    StreamTokenizer tokenizer = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));</span><br><span class="line">while (tokenizer.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">        int n = (int) tokenizer.nval; // 读取数字</span><br><span class="line">        String s = tokenizer.sval; // 读取字符串</span><br><span class="line">        // 处理数据...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>读取空格分隔的数据</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    StreamTokenizer tokenizer = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));</span><br><span class="line">tokenizer.whitespaceChars(&#x27; &#x27;, &#x27; &#x27;); // 设置空格为分隔符</span><br><span class="line">        while (tokenizer.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">        int n = (int) tokenizer.nval; // 读取数字</span><br><span class="line">        String s = tokenizer.sval; // 读取字符串</span><br><span class="line">        // 处理数据...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>读取逗号分隔的数据</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    StreamTokenizer tokenizer = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));</span><br><span class="line">tokenizer.whitespaceChars(&#x27;,&#x27;, &#x27;,&#x27;); // 设置逗号为分隔符</span><br><span class="line">        while (tokenizer.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">        int n = (int) tokenizer.nval; // 读取数字</span><br><span class="line">        String s = tokenizer.sval; // 读取字符串</span><br><span class="line">        // 处理数据...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>读取 CSV 文件</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    StreamTokenizer tokenizer = new StreamTokenizer(new BufferedReader(new FileReader(&quot;input.csv&quot;)));</span><br><span class="line">tokenizer.eolIsSignificant(true); // 设置行末为分隔符</span><br><span class="line">        tokenizer.wordChars(&#x27;,&#x27;, &#x27;,&#x27;); // 设置逗号为单词字符</span><br><span class="line">        while (tokenizer.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">        String s = tokenizer.sval; // 读取字符串</span><br><span class="line">        // 处理数据...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>读取二维数组</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    StreamTokenizer tokenizer = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));</span><br><span class="line">while (tokenizer.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">        int n = (int) tokenizer.nval; // 读取行数</span><br><span class="line">        int m = (int) tokenizer.nval; // 读取列数</span><br><span class="line">        int[][] a = new int[n][m];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">        tokenizer.nextToken();</span><br><span class="line">        a[i][j] = (int) tokenizer.nval; // 读取数组元素</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 处理数据...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>读取带有换行符的数据</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    StreamTokenizer tokenizer = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));</span><br><span class="line">tokenizer.eolIsSignificant(true); // 设置行末为分隔符</span><br><span class="line">        while (tokenizer.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">        String s = tokenizer.sval; // 读取字符串</span><br><span class="line">        // 处理数据...</span><br><span class="line">        if (tokenizer.ttype == StreamTokenizer.TT_EOL) &#123;</span><br><span class="line">        // 处理换行符</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>读取不同类型的数据</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    StreamTokenizer tokenizer = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));</span><br><span class="line">tokenizer.wordChars(&#x27;_&#x27;, &#x27;_&#x27;); // 允许下划线作为单词字符</span><br><span class="line">        while (tokenizer.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">        switch (tokenizer.ttype) &#123;</span><br><span class="line">        case StreamTokenizer.TT_NUMBER:</span><br><span class="line">        int n = (int) tokenizer.nval; // 读取数字</span><br><span class="line">        // 处理数字...</span><br><span class="line">        break;</span><br><span class="line">        case StreamTokenizer.TT_WORD:</span><br><span class="line">        String s = tokenizer.sval; // 读取字符串</span><br><span class="line">        // 处理字符串...</span><br><span class="line">        break;</span><br><span class="line">        case &#x27;_&#x27;:</span><br><span class="line">        // 处理下划线...</span><br><span class="line">        break;</span><br><span class="line">default:</span><br><span class="line">        // 处理其他类型...</span><br><span class="line">        break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="第一次补充"><a href="#第一次补充" class="headerlink" title="第一次补充"></a>第一次补充</h3><p><img src="/posts/54254/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230318104953.png"></p><p>&#96;&#96;字符串数字混合读取</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class p07 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line">        st.nextToken();</span><br><span class="line">        int n = (int)st.nval;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            String a = st.sval;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int hx = (int)st.nval;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            int mb = (int)st.nval;</span><br><span class="line"></span><br><span class="line">            if (!(hx &gt;= 15 &amp;&amp; hx &lt;= 20) || !(mb &gt;=50 &amp;&amp; mb &lt;= 70)) &#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#96;读取单个字符</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class p08 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line">        st.nextToken();</span><br><span class="line">        int n = (int)st.nval;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            int b = bf.read();</span><br><span class="line">            st.nextToken();</span><br><span class="line">            double h = st.nval;</span><br><span class="line"></span><br><span class="line">            if (b == (int)&#x27;M&#x27;) &#123;</span><br><span class="line">                System.out.printf(&quot;%.2f&quot;, h / 1.09);</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.printf(&quot;%.2f&quot;, h * 1.09);</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/54254/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320071952.png"></p><h3 id="第二次补充"><a href="#第二次补充" class="headerlink" title="第二次补充"></a>第二次补充</h3><p>这次遇到的问题是对时间的读取</p><p><img src="/posts/54254/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230325110136.png"></p><p>先上自己写的读取模板</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.awt.image.BufferedImageFilter;</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line">public class 模板 &#123;</span><br><span class="line">    static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">    static StreamTokenizer st = new StreamTokenizer(bf);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        System.out.println(readInt());</span><br><span class="line">        st.nextToken();</span><br><span class="line">        System.out.println(readInt());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int readInt () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return (int)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String readStr () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char readChar () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.charAt(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static char[] readCharArray () throws IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        return st.sval.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来是想用模板中的readCharArray()将一整串直接作为字符串读取，但是发现报错</p><p>st的原理是将输入流分割成不同的标记，比如单词，数字，标点符号等，显然，对于上面的时间而言就直接被分割成了，数字标点数字的形式，此时使用获取下一个标记，输出字符串的操作显然会返回一个空字符串，因为我们获取不到字符串</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    String a = readStr();</span><br><span class="line">&#125;</span><br><span class="line">//输入50：20</span><br><span class="line">//输出null</span><br></pre></td></tr></table></figure><p>此时如果我们想要将输入作为字符串来读取可以使用bufferreader，bf.readLine(),这样的操作能使我们获取中间的特殊字符：</p><p>（<code>BufferedReader</code> 类中的 <code>read()</code> 方法用于读取一个字符。它会从输入流中读取下一个字符，并将其作为整数返回。如果已经到达输入流的末尾，则返回 <code>-1</code>。）</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    String a = bf.readLine();</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line">//输入50：20</span><br><span class="line">//输出50:20</span><br></pre></td></tr></table></figure><p>需要注意的是，readline会读取换行符之前的所有字符，但不会读取换行符</p><p>那我们想读取 555 50：20 aaa这样的数据的时候又该怎么办呢？</p><p>利用循环，使用bufferreader中的read方法逐个读取，读取到空格返回这可能是一个思路，但是我们可以直接使用read中的重载方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int read(char[] cbuf) throws IOException</span><br></pre></td></tr></table></figure><p>读取字符到指定的字符数组 <code>cbuf</code> 中，并返回读取的字符数。如果已经到达输入流的末尾，则返回 <code>-1</code>。该方法会一直阻塞，直到有字符可读，或者抛出异常。</p><p>下面是使用示例</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    System.out.println(readInt());</span><br><span class="line">    System.out.println(readSP());</span><br><span class="line">    System.out.println(readInt());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static char[] readSP () throws IOException &#123;</span><br><span class="line">    char aa[] = new char[5];</span><br><span class="line">    bf.read(aa);</span><br><span class="line">    return  aa;</span><br><span class="line">&#125;</span><br><span class="line">//输入500 50:20 555</span><br><span class="line">//输出</span><br><span class="line">//500</span><br><span class="line">//50:20</span><br><span class="line">//555</span><br></pre></td></tr></table></figure><p>下面是另一些read重载方法的介绍</p><ol><li></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int read(char[] cbuf, int off, int len) throws IOException</span><br></pre></td></tr></table></figure><p>读取字符到指定的字符数组 <code>cbuf</code> 中的指定位置，并返回读取的字符数。参数 <code>off</code> 指定读取的起始位置，参数 <code>len</code> 指定最多读取的字符数。如果已经到达输入流的末尾，则返回 <code>-1</code>。该方法会一直阻塞，直到有字符可读，或者抛出异常。</p><ol start="2"><li></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public long skip(long n) throws IOException</span><br></pre></td></tr></table></figure><p>跳过输入流中的 <code>n</code> 个字符。如果已经到达输入流的末尾，则返回 <code>0</code>。该方法会一直阻塞，直到跳过指定数量的字符，或者抛出异常。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>打字游戏小结</title>
      <link href="/posts/14869.html"/>
      <url>/posts/14869.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="小小的打字游戏"><a href="#小小的打字游戏" class="headerlink" title="小小的打字游戏"></a>小小的打字游戏</h1><p>本学期专业引导大作业，模仿假期写的一个拼图游戏写的，算是对假期所学知识的巩固</p><p>直接上代码</p><p>1.ResultJFrame</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package come.P531.ui;</span><br><span class="line"></span><br><span class="line">import javax.swing.*;</span><br><span class="line">import java.awt.*;</span><br><span class="line">import java.awt.event.MouseEvent;</span><br><span class="line">import java.awt.event.MouseListener;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ResultJFrame extends JFrame implements MouseListener &#123;</span><br><span class="line">    double result;</span><br><span class="line">    double speed;</span><br><span class="line">    String fileName;</span><br><span class="line">    boolean flag;</span><br><span class="line"></span><br><span class="line">    JButton save;</span><br><span class="line">    JButton replay;</span><br><span class="line">    JButton Menu;</span><br><span class="line">    JButton search;</span><br><span class="line">    JMenuItem poor;</span><br><span class="line">    JTextField name;</span><br><span class="line">    JButton enterName;</span><br><span class="line">    JDialog Enter;</span><br><span class="line"></span><br><span class="line">    //构造方法</span><br><span class="line">    public ResultJFrame(double result, double speed, String fileName) &#123;</span><br><span class="line">        this.result = result;</span><br><span class="line">        this.speed = speed;</span><br><span class="line">        this.fileName = fileName;</span><br><span class="line">        this.flag = false;</span><br><span class="line">        initJFrame();</span><br><span class="line">        initView();</span><br><span class="line"></span><br><span class="line">        this.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化界面</span><br><span class="line">    private void initView() &#123;</span><br><span class="line">        this.getContentPane().removeAll();</span><br><span class="line">        JMenuBar jMenuBar = new JMenuBar();</span><br><span class="line"></span><br><span class="line">        int a = (int)(result * 100);</span><br><span class="line">        int b = (int)(speed * 100);</span><br><span class="line">        double bb = (double) b / 100;</span><br><span class="line"></span><br><span class="line">        JLabel first = new JLabel(&quot;正确率:%&quot;+ a);</span><br><span class="line">        first.setBounds(125,150,200,100);</span><br><span class="line">        first.setFont(new Font(&quot;宋体&quot;,Font.BOLD,30));</span><br><span class="line">        this.add(first);</span><br><span class="line"></span><br><span class="line">        JLabel second = new JLabel(&quot;速度:&quot;+bb+&quot;个每秒&quot;);</span><br><span class="line">        second.setBounds(50, 250,275,100);</span><br><span class="line">        second.setFont(new Font(&quot;宋体&quot;,Font.BOLD,30));</span><br><span class="line">        this.add(second);</span><br><span class="line"></span><br><span class="line">        save = new JButton(&quot;保存记录&quot;);</span><br><span class="line">        save.setBounds(400,100,150,75);</span><br><span class="line">        replay = new JButton(&quot;重新开始&quot;);</span><br><span class="line">        replay.setBounds(400,200,150,75);</span><br><span class="line">        Menu = new JButton(&quot;返回菜单&quot;);</span><br><span class="line">        Menu.setBounds(400,300,150,75);</span><br><span class="line">        search = new JButton(&quot;查看记录&quot;);</span><br><span class="line">        search.setBounds(400,400,150,75);</span><br><span class="line">        poor = new JMenuItem(&quot;快吃不起饭了&quot;);</span><br><span class="line"></span><br><span class="line">        save.addMouseListener(this);</span><br><span class="line">        replay.addMouseListener(this);</span><br><span class="line">        Menu.addMouseListener(this);</span><br><span class="line">        search.addMouseListener(this);</span><br><span class="line">        poor.addMouseListener(this);</span><br><span class="line"></span><br><span class="line">        this.getContentPane().add(save);</span><br><span class="line">        this.getContentPane().add(replay);</span><br><span class="line">        this.getContentPane().add(Menu);</span><br><span class="line">        this.getContentPane().add(search);</span><br><span class="line">        jMenuBar.add(poor);</span><br><span class="line">        this.setJMenuBar(jMenuBar);</span><br><span class="line"></span><br><span class="line">        this.getContentPane().repaint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化窗口</span><br><span class="line">    private void initJFrame() &#123;</span><br><span class="line">        this.setSize(600,600);</span><br><span class="line">        this.setTitle(&quot;测试结果&quot;);</span><br><span class="line">        this.setAlwaysOnTop(true);</span><br><span class="line">        this.setLocationRelativeTo(null);</span><br><span class="line">        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">        this.setLayout(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //展示成绩记录</span><br><span class="line">    private void showList() throws FileNotFoundException &#123;</span><br><span class="line">        //gettext first</span><br><span class="line">        File file =  new File(&quot;List/aList.txt&quot;);</span><br><span class="line">        Scanner sc = new Scanner(file);</span><br><span class="line"></span><br><span class="line">        String content = &quot;&lt;html&gt;&quot;;</span><br><span class="line">        while (sc.hasNextLine()) &#123;</span><br><span class="line">            content += sc.nextLine();</span><br><span class="line">        &#125;</span><br><span class="line">        content += &quot;&lt;html&gt;&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JDialog jDialog = new JDialog();</span><br><span class="line">        JLabel jLabel = new JLabel(content);</span><br><span class="line">        jLabel.setHorizontalAlignment(SwingConstants.CENTER);</span><br><span class="line">        jLabel.setVerticalAlignment(SwingConstants.CENTER);</span><br><span class="line">        jLabel.setFont(new Font(&quot;宋体&quot;, Font.BOLD, 15));</span><br><span class="line">        jLabel.setBounds(0, 0, 300, 200);</span><br><span class="line"></span><br><span class="line">        JScrollPane scrollPane = new JScrollPane(jLabel);</span><br><span class="line">        jDialog.getContentPane().add(scrollPane);</span><br><span class="line">        scrollPane.setMaximumSize(new Dimension(Integer.MAX_VALUE, 200));</span><br><span class="line">        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);</span><br><span class="line"></span><br><span class="line">        jDialog.setSize(400,400);</span><br><span class="line">        jDialog.setAlwaysOnTop(true);</span><br><span class="line">        jDialog.setLocationRelativeTo(null);</span><br><span class="line">        jDialog.setModal(true);</span><br><span class="line">        jDialog.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //保存成绩——窗口</span><br><span class="line">    private void save () &#123;</span><br><span class="line">        JLabel tip = new JLabel(&quot;&lt;html&gt;请输入玩家名&lt;br&gt;不多于15个字符&lt;br&gt;&lt;html&gt;&quot;);</span><br><span class="line">        tip.setBounds(75,50,150,100);</span><br><span class="line"></span><br><span class="line">        name = new JTextField();</span><br><span class="line">        name.setBounds(75,150,150,30);</span><br><span class="line"></span><br><span class="line">        enterName = new JButton(&quot;确定&quot;);</span><br><span class="line">        enterName.setBounds(100,200,100,50);</span><br><span class="line">        enterName.addMouseListener(this);</span><br><span class="line"></span><br><span class="line">        Enter = new JDialog();</span><br><span class="line">        Enter.setLayout(null);</span><br><span class="line">        Enter.getContentPane().add(name);</span><br><span class="line">        Enter.getContentPane().add(tip);</span><br><span class="line">        Enter.getContentPane().add(enterName);</span><br><span class="line">        Enter.setSize(300,300);</span><br><span class="line">        Enter.setAlwaysOnTop(true);</span><br><span class="line">        Enter.setLocationRelativeTo(null);</span><br><span class="line">        Enter.setModal(true);</span><br><span class="line">        Enter.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //警告窗口</span><br><span class="line">    private void showJDialog() &#123;</span><br><span class="line">        JDialog jDialog = new JDialog();</span><br><span class="line">        jDialog.setSize(300,300);</span><br><span class="line">        jDialog.setAlwaysOnTop(true);</span><br><span class="line">        jDialog.setLocationRelativeTo(null);</span><br><span class="line">        jDialog.setModal(true);</span><br><span class="line"></span><br><span class="line">        JLabel warning = new JLabel(new ImageIcon(&quot;pictures/damie.jpg&quot;));</span><br><span class="line">        JLabel warnText = new JLabel(&quot;请重新输入！！！SD&quot;);</span><br><span class="line">        warning.setBounds(75, 75, 100, 100);</span><br><span class="line">        warnText.setBounds(100, 175,100,50);</span><br><span class="line">        jDialog.getContentPane().add(warnText);</span><br><span class="line">        jDialog.getContentPane().add(warning);</span><br><span class="line"></span><br><span class="line">        jDialog.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //保存成绩——数据</span><br><span class="line">    private void getIn(String a) throws IOException &#123;</span><br><span class="line">        a += &quot;&lt;br&gt;&quot;;</span><br><span class="line">        String text = &quot;&quot;;</span><br><span class="line">        File file = new File(&quot;List/aList.txt&quot;);</span><br><span class="line">        Scanner sc = new Scanner(file);</span><br><span class="line">        if (sc.hasNextLine()) &#123;</span><br><span class="line">            text += sc.nextLine();</span><br><span class="line">        &#125;</span><br><span class="line">        text = a + text;</span><br><span class="line"></span><br><span class="line">        BufferedWriter bw = Files.newBufferedWriter(Paths.get(&quot;List/aList.txt&quot;));</span><br><span class="line">        try &#123;</span><br><span class="line">            bw.write(&quot;&quot;);</span><br><span class="line">            bw.write(text);</span><br><span class="line">            bw.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mouseClicked(MouseEvent e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mousePressed(MouseEvent e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mouseReleased(MouseEvent e) &#123;</span><br><span class="line">        if (e.getSource() == Menu) &#123;</span><br><span class="line">            this.setVisible(false);</span><br><span class="line">            new StartJFrame();</span><br><span class="line">        &#125; else if (e.getSource() == replay) &#123;</span><br><span class="line">            this.setVisible(false);</span><br><span class="line">            try &#123;</span><br><span class="line">                new TypeJFrame(fileName);</span><br><span class="line">            &#125; catch (IOException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (e.getSource() == poor) &#123;</span><br><span class="line">            System.out.println(&quot;按下poor&quot;);</span><br><span class="line"></span><br><span class="line">            JDialog jDialog = new JDialog();</span><br><span class="line">            JLabel jLabel = new JLabel(new ImageIcon(&quot;pictures/hehehe.png&quot;));</span><br><span class="line">            jLabel.setBounds(0,0,100,100);</span><br><span class="line">            jDialog.getContentPane().add(jLabel);</span><br><span class="line">            jDialog.setSize(1400,1200);</span><br><span class="line">            jDialog.setAlwaysOnTop(true);</span><br><span class="line">            jDialog.setLocationRelativeTo(null);</span><br><span class="line">            jDialog.setModal(true);</span><br><span class="line">            jDialog.setVisible(true);</span><br><span class="line">        &#125; else if (e.getSource() == search) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                showList();</span><br><span class="line">            &#125; catch (FileNotFoundException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (e.getSource() == save) &#123;</span><br><span class="line">            save();</span><br><span class="line">        &#125; else if (e.getSource() == enterName) &#123;</span><br><span class="line">            System.out.println(&quot;点击了确定&quot;);</span><br><span class="line">            int aa = (int)(result * 100);</span><br><span class="line">            int b = (int)(speed * 100);</span><br><span class="line">            double bb = (double) b / 100;</span><br><span class="line">            String a = name.getText();</span><br><span class="line">            if (a.length() &lt;= 15) &#123;</span><br><span class="line">                a += &quot; &quot; + aa + &quot; &quot; + bb;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                try &#123;</span><br><span class="line">                    getIn(a);</span><br><span class="line">                &#125; catch (IOException ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                Enter.setVisible(false);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                showJDialog();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mouseEntered(MouseEvent e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mouseExited(MouseEvent e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.StartJFrame</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package come.P531.ui;</span><br><span class="line"></span><br><span class="line">import javax.swing.*;</span><br><span class="line">import java.awt.*;</span><br><span class="line">import java.awt.event.MouseEvent;</span><br><span class="line">import java.awt.event.MouseListener;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class StartJFrame extends JFrame implements MouseListener &#123;</span><br><span class="line"></span><br><span class="line">    JLabel testArticleJB;</span><br><span class="line">    JRadioButton englishRB;</span><br><span class="line">    JRadioButton chineseRB;</span><br><span class="line">    JComboBox&lt;String&gt; testArticleJCB;;</span><br><span class="line">    JButton startJB;</span><br><span class="line"></span><br><span class="line">    JMenuItem aboutUs;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    String filename;</span><br><span class="line">    String path = &quot;data&quot;;</span><br><span class="line"></span><br><span class="line">    //构造方法</span><br><span class="line">    public StartJFrame() &#123;</span><br><span class="line"></span><br><span class="line">        initJFram();</span><br><span class="line">        initView(1);</span><br><span class="line">        initJMenuBar();</span><br><span class="line"></span><br><span class="line">        this.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化界面</span><br><span class="line">    public void initView(int botton) &#123;</span><br><span class="line">        this.getContentPane().removeAll();</span><br><span class="line"></span><br><span class="line">        JLabel title = new JLabel(&quot;531打字通&quot;);</span><br><span class="line">        title.setFont(new Font(&quot;宋体&quot;, Font.BOLD, 24));</span><br><span class="line">        title.setBounds(200,25,200,50);</span><br><span class="line">        this.getContentPane().add(title);</span><br><span class="line"></span><br><span class="line">        JLabel lang = new JLabel(&quot;打字类型&quot;);</span><br><span class="line">        lang.setFont(new Font(&quot;打字类型&quot;, Font.ITALIC, 15));</span><br><span class="line">        lang.setBounds(80,100,65,50);</span><br><span class="line">        this.getContentPane().add(lang);</span><br><span class="line"></span><br><span class="line">        englishRB =  new JRadioButton(&quot;英文打字&quot;);</span><br><span class="line">        chineseRB = new JRadioButton(&quot;中文打字&quot;);</span><br><span class="line">        englishRB.setBounds(175,100,100,50);</span><br><span class="line">        chineseRB.setBounds(275,100,100,50);</span><br><span class="line">        //englishRB.setSelected(true);</span><br><span class="line">        this.getContentPane().add(englishRB);</span><br><span class="line">        this.getContentPane().add(chineseRB);</span><br><span class="line">        if (botton == 1) &#123;</span><br><span class="line">            englishRB.setSelected(true);</span><br><span class="line">            chineseRB.setSelected(false);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            englishRB.setSelected(false);</span><br><span class="line">            chineseRB.setSelected(true);</span><br><span class="line">        &#125;</span><br><span class="line">        englishRB.addMouseListener(this);</span><br><span class="line">        chineseRB.addMouseListener(this);</span><br><span class="line"></span><br><span class="line">        testArticleJB = new JLabel(&quot;测试文章&quot;,SwingConstants.RIGHT);</span><br><span class="line">        testArticleJCB = new JComboBox&lt;String&gt;();</span><br><span class="line">        testArticleJCB.setEditable(false);</span><br><span class="line">        testArticleJCB.setMaximumRowCount(7);</span><br><span class="line">        testArticleJCB.setBounds(250,200,150,25);</span><br><span class="line">        addEnglishArticleToJComBox();</span><br><span class="line">        this.getContentPane().add(testArticleJCB);</span><br><span class="line"></span><br><span class="line">        JLabel choose = new JLabel(&quot;文章选择&quot;);</span><br><span class="line">        choose.setFont(new Font(&quot;文章选择&quot;, Font.ITALIC, 15));</span><br><span class="line">        choose.setBounds(130, 200,65,25);</span><br><span class="line">        this.getContentPane().add(choose);</span><br><span class="line"></span><br><span class="line">        startJB = new JButton(&quot;开始打字&quot;);</span><br><span class="line">        startJB.setBounds(200,300,100,50);</span><br><span class="line">        this.getContentPane().add(startJB);</span><br><span class="line">        startJB.addMouseListener(this);</span><br><span class="line"></span><br><span class="line">        this.getContentPane().repaint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将文章名加入到 combox中</span><br><span class="line">    public void addEnglishArticleToJComBox() &#123;</span><br><span class="line">        File f = new File(path);</span><br><span class="line">        File[] files = f.listFiles();</span><br><span class="line">        for (int i = 0; i &lt; files.length; i++) &#123;</span><br><span class="line">            if (files[i].toString().endsWith(&quot;.txt&quot;)) &#123;</span><br><span class="line">                testArticleJCB.addItem(files[i].getName().toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化窗口</span><br><span class="line">    private void initJFram() &#123;</span><br><span class="line">        JLabel textTypeJLabel = new JLabel(&quot;测试类型：&quot;, SwingConstants.RIGHT);</span><br><span class="line">        JPanel jp = new JPanel(new GridLayout(4, 3));</span><br><span class="line"></span><br><span class="line">        this.setSize(500, 500);</span><br><span class="line">        this.setTitle(&quot;531打字通&quot;);</span><br><span class="line">        this.setDefaultCloseOperation(3);</span><br><span class="line">        this.setLocationRelativeTo(null);</span><br><span class="line">        this.setAlwaysOnTop(true);</span><br><span class="line">        this.setLayout(null);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化菜单</span><br><span class="line">    private void initJMenuBar() &#123;</span><br><span class="line">        JMenuBar jMenuBar = new JMenuBar();</span><br><span class="line">        aboutUs =  new JMenuItem(&quot;关于我们&quot;);</span><br><span class="line">        jMenuBar.add(aboutUs);</span><br><span class="line">        aboutUs.addMouseListener(this);</span><br><span class="line">        this.setJMenuBar(jMenuBar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mouseClicked(MouseEvent e) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mousePressed(MouseEvent e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mouseReleased(MouseEvent e) &#123;</span><br><span class="line">        if (e.getSource() == startJB) &#123;</span><br><span class="line">            System.out.println(&quot;你松开了开始键&quot;);</span><br><span class="line">            this.setVisible(false);</span><br><span class="line">            filename = testArticleJCB.getSelectedItem().toString();</span><br><span class="line">            try &#123;</span><br><span class="line">                new TypeJFrame(path +&quot;/&quot;+filename);</span><br><span class="line">            &#125; catch (IOException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (e.getSource() == englishRB) &#123;</span><br><span class="line">            System.out.println(&quot;你松开了英文键&quot;);</span><br><span class="line">            chineseRB.setSelected(false);</span><br><span class="line">            englishRB.setSelected(true);</span><br><span class="line">            path = &quot;data&quot;;</span><br><span class="line">            initView(1);</span><br><span class="line">        &#125; else if (e.getSource() == chineseRB) &#123;</span><br><span class="line">            System.out.println(&quot;你松开了中文键&quot;);</span><br><span class="line">            englishRB.setSelected(false);</span><br><span class="line">            chineseRB.setSelected(true);</span><br><span class="line">            path = &quot;atad&quot;;</span><br><span class="line">            initView(2);</span><br><span class="line">        &#125; else if (e.getSource()  == aboutUs) &#123;</span><br><span class="line">            System.out.println(&quot;你松开了关于我们&quot;);</span><br><span class="line"></span><br><span class="line">            JDialog jDialog = new JDialog();</span><br><span class="line">            JLabel jLabel = new JLabel((new ImageIcon(&quot;pictures/aboutus.png&quot;)));</span><br><span class="line">            jLabel.setBounds(0,0,400,450);</span><br><span class="line">            jDialog.getContentPane().add(jLabel);</span><br><span class="line">            jDialog.setSize(800,800);</span><br><span class="line">            jDialog.setAlwaysOnTop(true);</span><br><span class="line">            jDialog.setLocationRelativeTo(null);</span><br><span class="line">            jDialog.setModal(true);</span><br><span class="line">            jDialog.setVisible(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mouseEntered(MouseEvent e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mouseExited(MouseEvent e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.TypeJFrame</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package come.P531.ui;</span><br><span class="line"></span><br><span class="line">import come.P531.util.TimeCounter;</span><br><span class="line"></span><br><span class="line">import javax.swing.*;</span><br><span class="line">import java.awt.*;</span><br><span class="line">import java.awt.event.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class TypeJFrame extends JFrame implements  KeyListener, MouseListener &#123;</span><br><span class="line">    String playerText = &quot;&quot;;</span><br><span class="line">    String text = &quot;&quot;;</span><br><span class="line">    JTextArea textArea;</span><br><span class="line">    char[] pt;</span><br><span class="line">    char[] t;</span><br><span class="line">    int cont;</span><br><span class="line">    int score;</span><br><span class="line">    int typeNum;</span><br><span class="line">    int time;</span><br><span class="line">    double acc;</span><br><span class="line">    double speed;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    String filename;</span><br><span class="line">    JMenuItem returnMenu;</span><br><span class="line">    JMenuItem backMenu;</span><br><span class="line"></span><br><span class="line">    TimeCounter timeCounter;</span><br><span class="line"></span><br><span class="line">    //构造方法</span><br><span class="line">    public TypeJFrame(String file) throws IOException &#123;</span><br><span class="line">        this.filename = file;</span><br><span class="line">        initJFram();</span><br><span class="line">        initView();</span><br><span class="line">        initJMenuBar();</span><br><span class="line">        timeCounter = new TimeCounter();</span><br><span class="line">        this.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化界面，获得文本信息（内容，字数）</span><br><span class="line">    private void initView() throws IOException &#123;</span><br><span class="line">        this.getContentPane().removeAll();</span><br><span class="line"></span><br><span class="line">        JLabel textLB = new JLabel();</span><br><span class="line">        textLB.setHorizontalAlignment(JLabel.LEFT);</span><br><span class="line">        textLB.setVerticalAlignment(JLabel.TOP);</span><br><span class="line">        textLB.setFont(new Font(&quot;text&quot;,Font.BOLD,15));</span><br><span class="line">        String text = getText();</span><br><span class="line">        getCont();</span><br><span class="line">        textLB.setText(text);</span><br><span class="line">        textLB.setBounds(50,50,450,650);</span><br><span class="line">        this.getContentPane().add(textLB);</span><br><span class="line"></span><br><span class="line">        textArea = new JTextArea(32, 55);</span><br><span class="line">        textArea.setBounds(600,50,450,650);</span><br><span class="line">        textArea.setFont(new Font(&quot;text&quot;,Font.BOLD,15));</span><br><span class="line">        textArea.addKeyListener(this);</span><br><span class="line">        this.getContentPane().add(textArea);</span><br><span class="line"></span><br><span class="line">        this.getContentPane().repaint();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化菜单</span><br><span class="line">    private void initJMenuBar() &#123;</span><br><span class="line"></span><br><span class="line">        returnMenu = new JMenuItem(&quot;返回&quot;);</span><br><span class="line">        backMenu = new JMenuItem(&quot;结束&quot;);</span><br><span class="line"></span><br><span class="line">        JMenuBar jMenuBar = new JMenuBar();</span><br><span class="line">        jMenuBar.add(returnMenu);</span><br><span class="line">        jMenuBar.add(backMenu);</span><br><span class="line">        returnMenu.addMouseListener(this);</span><br><span class="line">        backMenu.addMouseListener(this);</span><br><span class="line"></span><br><span class="line">        this.setJMenuBar(jMenuBar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //打印文本</span><br><span class="line">    private String getText () throws FileNotFoundException &#123;</span><br><span class="line">        File file = new File(filename);</span><br><span class="line">        Scanner sc = new Scanner(file);</span><br><span class="line">        String content = &quot;&lt;html&gt;&quot;;</span><br><span class="line">        while (sc.hasNextLine()) &#123;</span><br><span class="line">            String cur = sc.nextLine();</span><br><span class="line">            content += cur + &quot;&lt;br&gt;&quot;;</span><br><span class="line">            text += cur +&#x27;\n&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        content += &quot;&lt;html&gt;&quot;;</span><br><span class="line">        sc.close();</span><br><span class="line"></span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化窗口</span><br><span class="line">    private void initJFram() &#123;</span><br><span class="line">        this.setSize(1200, 800);</span><br><span class="line">        this.setTitle(&quot;531打字通&quot;);</span><br><span class="line">        this.setDefaultCloseOperation(3);</span><br><span class="line">        this.setLocationRelativeTo(null);</span><br><span class="line">        this.setAlwaysOnTop(true);</span><br><span class="line">        this.setLayout(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取目标文本数目，根据目标文本数目创建数组</span><br><span class="line">    private void getCont() throws IOException &#123;</span><br><span class="line">        FileReader fileReader = new FileReader(filename);</span><br><span class="line"></span><br><span class="line">        BufferedReader bufferedReader =  new BufferedReader(fileReader);</span><br><span class="line">        int c;</span><br><span class="line">        while ((c = bufferedReader.read()) != -1) &#123;</span><br><span class="line">            if (c != &#x27;\n&#x27; &amp;&amp; c != &#x27;\r&#x27;) &#123;</span><br><span class="line">                cont++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //比较目标文本与玩家输入，获取正确数目</span><br><span class="line">    private void compareText () &#123;</span><br><span class="line">        for (int i = 0; i &lt; cont; i++) &#123;</span><br><span class="line">            if (i == pt.length || i == t.length) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if ( pt[i] == t[i]) &#123;</span><br><span class="line">                score++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取结果</span><br><span class="line">    private void getResult() &#123;</span><br><span class="line"></span><br><span class="line">        playerText = textArea.getText();</span><br><span class="line">        pt = playerText.toCharArray();</span><br><span class="line">        t = text.toCharArray();</span><br><span class="line"></span><br><span class="line">        compareText();</span><br><span class="line"></span><br><span class="line">        acc = score*1.0 / cont;</span><br><span class="line">        speed = score*1.0 / time;</span><br><span class="line">        System.out.printf(&quot;%d %d %d&quot;,score, cont,time);</span><br><span class="line"></span><br><span class="line">        System.out.printf(&quot;%.2f &quot;, acc);</span><br><span class="line">        System.out.printf(&quot;%.2f &quot;, speed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void keyTyped(KeyEvent e) &#123;</span><br><span class="line">        int code = e.getKeyCode();</span><br><span class="line">        if (typeNum == cont) &#123;</span><br><span class="line">            time = timeCounter.count();</span><br><span class="line">            getResult();</span><br><span class="line">            new ResultJFrame(acc,speed,filename);</span><br><span class="line">            this.setVisible(false);</span><br><span class="line">        &#125; else if (code == 8) &#123;</span><br><span class="line">            typeNum--;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            typeNum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void keyPressed(KeyEvent e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void keyReleased(KeyEvent e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mouseClicked(MouseEvent e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mousePressed(MouseEvent e) &#123;</span><br><span class="line">        if (e.getSource() == returnMenu) &#123;</span><br><span class="line">            System.out.println(&quot;按下返回键&quot;);</span><br><span class="line"></span><br><span class="line">            this.setVisible(false);</span><br><span class="line">            new StartJFrame();</span><br><span class="line">        &#125; else if (e.getSource() == backMenu) &#123;</span><br><span class="line">            System.out.println(&quot;按下结束&quot;);</span><br><span class="line">            time = timeCounter.count();</span><br><span class="line">            getResult();</span><br><span class="line">            new ResultJFrame(acc,speed,filename);</span><br><span class="line">            this.setVisible(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mouseReleased(MouseEvent e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mouseEntered(MouseEvent e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void mouseExited(MouseEvent e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.TimeCounter</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package come.P531.util;</span><br><span class="line"></span><br><span class="line">import come.P531.ui.TypeJFrame;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.time.Duration;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line">import java.util.Timer;</span><br><span class="line">import java.util.TimerTask;</span><br><span class="line"></span><br><span class="line">public class TimeCounter extends  TimerTask&#123;</span><br><span class="line"></span><br><span class="line">    LocalDateTime start;</span><br><span class="line">    LocalDateTime end;</span><br><span class="line"></span><br><span class="line">    int Record;</span><br><span class="line"></span><br><span class="line">    //构造方法</span><br><span class="line">    public TimeCounter() &#123;</span><br><span class="line">        this.Start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //一个失败的尝试</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        this.End();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //记录开始时间</span><br><span class="line">    public void Start () &#123;</span><br><span class="line">        start = LocalDateTime.now();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //记录结束时间</span><br><span class="line">    public void End () &#123;</span><br><span class="line">        end = LocalDateTime.now();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取时间之差</span><br><span class="line">    public int count () &#123;</span><br><span class="line">        this.End();</span><br><span class="line">        Duration duration =  Duration.between(start, end);</span><br><span class="line">        Record = (int)duration.getSeconds();</span><br><span class="line">        System.out.println(Record);</span><br><span class="line">        return Record;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前期分析的时候打字软甲主要有三个界面，开始界面选择打字类型及打字文章，打字界面，结果界面，我们将这三个界面抽象为一种类，分别对其进行设计，因为我们打算实现的是一个带图形化界面的，所以我们让每个类分别继承Java中自带的JFram类，实现鼠标或键盘监听，因为打字游戏的实现逻辑比较简单所以我们将实现的逻辑作为方法写进类中，因为实现需要我后面又加了一个工具类进行计时</p><p>当时我是打算按着自己的直觉思路写下去，没有进行任何前期设计，只是在克服几个技术难点（对我来说），然后就开始编码，但是在不久后便遇到了不小困难，当我想修改程序的一小部分的时候我竟然找不到那个部分在哪。。。。。。虽然确实很尴尬但是确实发生了，并且在后期‘找’这个操作就占了我大部分的时间，如果<strong>前期程序的结构，数据结构，算法没有提前设计好的话，对后期的维护，修改，升级，将会产生巨大的影响</strong>，前期设计，相当重要</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java.sort</title>
      <link href="/posts/10609.html"/>
      <url>/posts/10609.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Arrays-sort"><a href="#Arrays-sort" class="headerlink" title="Arrays.sort()"></a>Arrays.sort()</h1><p>我觉得这个东西我得单独写一篇，为啥嘞，好用，强大，虽然不稳定</p><p>这是Java中一个用于对数组进行排序的方法，可以按照升序或降序的方式排序</p><p>该方法有多种重载形式，其中最常见的形式是传入一个数组作为参数，该数组将被按照默认升序排序方式进行排序</p><p>例如：</p><p><code>int[] arr = &#123;3, 5, 6 , 2, 1&#125;;  Arrays.sort(arr)</code></p><p>如果需要降序排序，想办法反转数组即可</p><p>该方法还可以对对象类型数组进行排序，但徐娅保证对象实现了Comparable接口或传入一个Comparator比较器对象作为参数</p><p><code>实例</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class pg implements Comparable&lt;pg&gt; &#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">    public pg(int x, int y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public pg() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(pg o) &#123;</span><br><span class="line">        return this.y - o.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象数组排序"><a href="#对象数组排序" class="headerlink" title="对象数组排序"></a>对象数组排序</h2><p>该对象在实现接口之后就可以使用 Arrays.sort()对该对象数组进行排序，需要注意的是，该数组中不能含有非空引用（在这里报错了一次）对这个的解决方法是在排序之前先将数组中的空引用过滤掉，可以使用<code>Arrays.stream()</code>方法将数组转换成流，然后使用<code>filter()</code>方法过滤掉空引用，最后使用<code>toArray()</code>方法将流转换回数组即可，示例如下：</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    YourObject[] arr = new YourObject[10];</span><br><span class="line">// 假设数组中有一些元素是 null</span><br><span class="line"></span><br><span class="line">    // 使用 Arrays.stream() 方法将数组转换成流，使用 filter() 方法过滤掉空引用，最后转换回数组</span><br><span class="line">    YourObject[] sortedArr = Arrays.stream(arr)</span><br><span class="line">            .filter(Objects::nonNull)</span><br><span class="line">            .sorted(/* 排序规则 */)</span><br><span class="line">            .toArray(YourObject[]::new);</span><br></pre></td></tr></table></figure><p>实现Comparable接口的类必须保证compareTo()方法满足自反性，对称性和传递性</p><p><img src="/posts/10609/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230313171553.png"></p><h2 id="二维数组排序"><a href="#二维数组排序" class="headerlink" title="二维数组排序"></a>二维数组排序</h2><p>Arrays.sort()方法可以对一维数组进行排序，但不能直接对二维数组排序，但是我们可以通过实现Comparator接口或者Comparable接口来对二维数组进行排序</p><p>首先，我们可以实现comparator接口，定义一个比较方法compare(),该方法接受两个参数，分别是待比较的两个数组，在该方法中，我们可以指定按照哪个元素进行比较。例如，假如有一个二维数组arr，包含若干个长度为2的一维数组，我们可以按照一维数组的第一个元素进行排序</p><p>&#96;&#96;这个好</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int [] arr = &#123;&#123;1,2&#125;,&#123;3,1&#125;,&#123;1,2&#125;,&#123;3,1&#125;&#125;;</span><br><span class="line">Arrays.sort(arr, new Comparator&lt;int[]&gt;()</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(int[] o1, int[] o2) &#123;</span><br><span class="line">            return o1[0] - o2[0];</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>（不太懂）另外，如果二维数组的每个一维数组实现了Comparable接口，那么我们也可以使用Arrays.sort()方法对二维数组进行排序，在这种情况下，Arrays.sort()方法会自动调用每个以为数组的compareTo()方法进行排序</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Pair implements Comparable&lt;Pair&gt; &#123;</span><br><span class="line"></span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line"></span><br><span class="line">    public Pair(int x, int y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Pair o) &#123;</span><br><span class="line">        return this.x - o.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pair[][] pairs = &#123;&#123;new Pair(1, 2), new Pair(3,1)&#125;, &#123;new Pair(5, 6), new Pair(8, 9)&#125;&#125;;</span><br><span class="line"></span><br><span class="line">Arrays.sort(pairs[0]);</span><br><span class="line">Arrays.sort(pairs[1]);//使用匿名内部类</span><br><span class="line">Arrays.sort(pairs, new Comparator&lt;Pair[]&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Pair[] o1, Pair[] o2) &#123;</span><br><span class="line">        return o1[0].x - o2[0].x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>多维数组使用Arrays.sort方法排序的另外一种方式</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">    int[][] aa = new int[5][2];</span><br><span class="line">    for (int i = 0; i &lt; aa.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; aa[i].length; j++) &#123;</span><br><span class="line">            aa[i][j] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//使用Lambda表达式进行比较</span><br><span class="line"></span><br><span class="line">    Arrays.sort(aa,  (a, b) -&gt; Integer.compare(a[1], b[1]));</span><br><span class="line"></span><br><span class="line">    for (int[] ints : aa) &#123;</span><br><span class="line">        for (int anInt : ints) &#123;</span><br><span class="line">            System.out.print(anInt+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个代码中，我们将一个Lambda表达式作为参数传递给函数</p><p>Lambda表达式的语法形式为（参数列表） - &gt;表达式或者参数列表 - &gt; {代码块}</p><p>这个表达式可以用来代替某些匿名内部类的定义，尤其是对于函数式接口，使用Lambda表达式可以更加简洁，易读，Lambda表达式也可以用于函数式编程，它提供了一种更加函数化的编程风格</p><p>实现不同的比较器</p><p>（个人猜想：sort排序最主要的是要一个值来判断是否要交换位置，然而在我们传入对象，多维数组的时候内置的方法就不能进行求值，这个时候我们重写求值的方法，或者传递一个表达式来求值就可以完成操作）</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>Java中Arrays.sort()方法使用的是一种改进的快速排序算法（也称为双轴快速排序），该算法可以在最坏情况下以O(n log n)的时间复杂度完成排序，具有较好的性能。</p><p>具体实现思路如下：</p><ol><li>对于数组中的元素，选择一个基准元素（pivot），通常可以选择第一个元素或者最后一个元素。</li><li>定义两个指针，一个指向数组的开头（left），另一个指向数组的结尾（right）。</li><li>从左向右扫描数组，找到第一个大于等于基准元素的元素。</li><li>从右向左扫描数组，找到第一个小于等于基准元素的元素。</li><li>如果left指针小于等于right指针，交换left和right位置上的元素，然后将left指针向右移动，right指针向左移动。</li><li>重复3-5步骤，直到left指针大于right指针。</li><li>将基准元素与right指针所在位置上的元素交换。</li><li>对基准元素左侧的子数组和右侧的子数组分别进行递归排序，直到整个数组有序。</li></ol><p>需要注意的是，为了避免最坏情况下快速排序的时间复杂度退化到O(n^2)，Arrays.sort()方法还使用了一些优化技巧，如在数组大小较小时使用插入排序，以及在递归过程中使用堆排序等。</p><p>&#96;&#96;</p><h3 id="第一次更新"><a href="#第一次更新" class="headerlink" title="第一次更新"></a>第一次更新</h3><p>添加使用sort对对象数组和二维数组排序的实例，纠正一个思维漏洞，结合题目</p><p><img src="/posts/10609/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320113525.png"></p><h4 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h4><p>首先是对对象数组进行排序</p><p><img src="/posts/10609/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320113633.png"></p><p>使用匿名内部类重写比较方法，比较元素顺序跟框里一样就是从小到大，反过来就是从大到小，字符串之间比较大小就是比较的字典序，虽然我这里没有用string存name</p><p><img src="/posts/10609/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320113649.png"></p><p>对上面的方法进行简化</p><p><img src="/posts/10609/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320114002.png"></p><p>直接使用比较类中的比较方法，同样，里面的元素反过来就是从大到小排序</p><p>而且我们还可以使用lambda表达式来使代码得到进一步的简化</p><p><img src="/posts/10609/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320114339.png"></p><p>顺便了解一下compareTo接口</p><p><img src="/posts/10609/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320114557.png"></p><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>在对二维数组使用sort进行排序的时候，我们需要知道sort中的元素交换方法是不能改的，只能是一个什么东西与另一个什么东西进行交换，对于这个题目，我最开始的数据安排是这样的</p><p><img src="/posts/10609/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320114812.png"></p><p>每一列存储一条信息，因为第一行存的是收入，按照通产思路对第一排进行排序，如果第一行第一个元素大于第一行第二个元素，那么我们就要将第一行的元素与第二行的元素进行交换，这个sort显然是做不到的，因为我们一次就要交换三个什么东西，除非我们自己写sort方法，要不然肯定不行</p><p>所以我把数据结构给改成了这样</p><p><img src="/posts/10609/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320115116.png"></p><p>对于Java来说，二维数组中的元素就是里面的一维数组，此时我们第一列存收入，如果第一列第一个元素大于第二列第一个元素，那么我们直接交换第一行和第二行，也就是交换二维数组中的第一个元素与第二个元素即可</p><p>所以排序的代码这样写</p><p><img src="/posts/10609/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320115330.png"></p><p>使用lambda表达式</p><p><img src="/posts/10609/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230320115357.png"></p><h3 id="第二次更新"><a href="#第二次更新" class="headerlink" title="第二次更新"></a>第二次更新</h3><p>要重写比较器，就不能是基本数据类型</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>移除元素</title>
      <link href="/posts/51619.html"/>
      <url>/posts/51619.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>递归计算行列式的值</title>
      <link href="/posts/62292.html"/>
      <url>/posts/62292.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​n阶行列式不断展开再相加的过程是一个不断重复的过程，完全展开之后就是一个树的形状，我们采用递归的方法去实现，首先要考虑递归结束的条件，那就是当行列式的阶数为2的时候直接套用公式计算并给出返回值，如果阶数大于2，那么我们展开第一行的所有元素并使每一行的元素与其对应的算数余子式相乘，将所有结果相加之后即是答案，那么我们在递归的时候要考虑传递的就是展开后的新余子式，将该余子式，与余子式阶数，作为新一轮递归的条件继续往下进行分解</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package text;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class free &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入行列式阶数&quot;);</span><br><span class="line">        int n = sc.nextInt();</span><br><span class="line">        //读取最初的行列式</span><br><span class="line">        int[][] a = new int[n][n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j  = 0; j &lt; n; j++) &#123;</span><br><span class="line">                a[i][j] = sc.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = hls(a, n);</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //处理行列式</span><br><span class="line">    public static int hls(int[][] a, int n) &#123;</span><br><span class="line">        //如果阶数为2，直接使用公式返回结果</span><br><span class="line">        if (n == 2) &#123;</span><br><span class="line">            return a[0][0] * a[1][1] - a[0][1] * a[1][0];</span><br><span class="line">        &#125; else &#123; //如果阶数不为2，展开第一行</span><br><span class="line">            int ans = 0; //用于接受每一行展开后所计算得出的值</span><br><span class="line">            for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">                if (a[0][i] == 0) &#123;</span><br><span class="line">                &#125; else if (i % 2 == 0) &#123;</span><br><span class="line">                    //构造新的行列式</span><br><span class="line">                    int[][] num = new int[n - 1][n - 1];</span><br><span class="line">                    szcl(a, num, i);</span><br><span class="line">                    ans += a[0][i] * hls(num, n - 1);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    int[][] num = new int[n - 1][n - 1];</span><br><span class="line">                    szcl(a, num, i);</span><br><span class="line">                    ans += -1*a[0][i] * hls(num, n - 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //构造新的行列式，省略第一行，及第lie列</span><br><span class="line">    public static void szcl(int[][] a, int[][] b, int lie) &#123;</span><br><span class="line">        int h = 0, l = 0;</span><br><span class="line">        //直接省略第一行，从第二行开始</span><br><span class="line">        for (int i = 1; i &lt; a.length; i ++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; a.length; j++) &#123;</span><br><span class="line">                if (j != lie) &#123;</span><br><span class="line">                    b[h][l++] = a[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            l = 0;</span><br><span class="line">            h++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>逆波兰表达式求值</title>
      <link href="/posts/16133.html"/>
      <url>/posts/16133.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/"></a></p><p><img src="/posts/16133/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230127045353.png"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接用栈，简单明了，我觉得更难的是怎么把一个中缀式改成后缀式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int evalRPN(String[] tokens) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = new LinkedList();</span><br><span class="line">        for (String s : tokens) &#123;</span><br><span class="line">            if (&quot;+&quot;.equals(s)) &#123;        // leetcode 内置jdk的问题，不能使用==判断字符串是否相等</span><br><span class="line">                stack.push(stack.pop() + stack.pop());      // 注意 - 和/ 需要特殊处理</span><br><span class="line">                //因为存在除数与被除数，减数与被减数的关系，直接弹出顺序会反</span><br><span class="line">            &#125; else if (&quot;-&quot;.equals(s)) &#123;</span><br><span class="line">                stack.push(-stack.pop() + stack.pop());</span><br><span class="line">            &#125; else if (&quot;*&quot;.equals(s)) &#123;</span><br><span class="line">                stack.push(stack.pop() * stack.pop());</span><br><span class="line">            &#125; else if (&quot;/&quot;.equals(s)) &#123;</span><br><span class="line">                int temp1 = stack.pop();</span><br><span class="line">                int temp2 = stack.pop();</span><br><span class="line">                stack.push(temp2 / temp1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                stack.push(Integer.valueOf(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>删除相邻重复项</title>
      <link href="/posts/22431.html"/>
      <url>/posts/22431.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/"></a></p><p><img src="/posts/22431/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230127034735.png"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>与左右括号匹配的题目类似，逐个扫描，如果栈顶元素与扫描字符不同，入栈，如果相同，栈顶元素出栈</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String removeDuplicates(String s) &#123;</span><br><span class="line">        Stack&lt;Character&gt; a = new Stack&lt;&gt;();</span><br><span class="line">        char ch;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            ch = s.charAt(i);</span><br><span class="line">            if (a.isEmpty() || a.peek() != ch) &#123;</span><br><span class="line">                a.push(ch);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                a.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">//非常细节，每次加入都是加在本体的左边，本来以为因为出栈顺序的原因可能最后还要反转字符串，多虑了</span><br><span class="line">        String str = &quot;&quot;;</span><br><span class="line">        while (!a.isEmpty()) &#123;</span><br><span class="line">            str = a.pop()+str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = new StringBuilder(str);</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String removeDuplicates(String s) &#123;</span><br><span class="line">        // 将 res 当做栈</span><br><span class="line">        // 也可以用 StringBuilder 来修改字符串，速度更快</span><br><span class="line">        // StringBuilder res = new StringBuilder();</span><br><span class="line">        StringBuffer res = new StringBuffer();</span><br><span class="line">        // top为 res 的长度</span><br><span class="line">        int top = -1;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            char c = s.charAt(i);</span><br><span class="line">            // 当 top &gt; 0,即栈中有字符时，当前字符如果和栈中字符相等，弹出栈顶字符，同时 top--</span><br><span class="line">            if (top &gt;= 0 &amp;&amp; res.charAt(top) == c) &#123;</span><br><span class="line">                res.deleteCharAt(top);</span><br><span class="line">                top--;</span><br><span class="line">            // 否则，将该字符 入栈，同时top++</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res.append(c);</span><br><span class="line">                top++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String removeDuplicates(String s) &#123;</span><br><span class="line">        char[] ch = s.toCharArray();</span><br><span class="line">        int fast = 0;</span><br><span class="line">        int slow = 0;</span><br><span class="line">        while(fast &lt; s.length())&#123;</span><br><span class="line">            // 直接用fast指针覆盖slow指针的值</span><br><span class="line">            ch[slow] = ch[fast];</span><br><span class="line">            // 遇到前后相同值的，就跳过，即slow指针后退一步，下次循环就可以直接被覆盖掉了</span><br><span class="line">            if(slow &gt; 0 &amp;&amp; ch[slow] == ch[slow - 1])&#123;</span><br><span class="line">                slow--;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(ch,0,slow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>有效括号</title>
      <link href="/posts/42010.html"/>
      <url>/posts/42010.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://leetcode.cn/problems/valid-parentheses/"></a></p><p><img src="/posts/42010/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230127030449.png"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>1.匹配问题，计算机处理左右括号似乎也是用栈来处理的我们逐个扫描字符串，如果是左括号，压入右括号，如果是做括号，判断栈顶元素与该括号是否匹配，如果匹配，出栈，如果不匹配，则字符串无效（括号搭配错了），如果在匹配到右括号时栈已空（多了右括号），则字符串无效，如果字符串扫描完毕，但栈不为空栈（多了左括号），则字符串无效</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        Deque&lt;Character&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line">        char ch;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            ch = s.charAt(i);</span><br><span class="line">            //碰到左括号，就把相应的右括号入栈</span><br><span class="line">            if (ch == &#x27;(&#x27;) &#123;</span><br><span class="line">                deque.push(&#x27;)&#x27;);</span><br><span class="line">            &#125;else if (ch == &#x27;&#123;&#x27;) &#123;</span><br><span class="line">                deque.push(&#x27;&#125;&#x27;);</span><br><span class="line">            &#125;else if (ch == &#x27;[&#x27;) &#123;</span><br><span class="line">                deque.push(&#x27;]&#x27;);</span><br><span class="line">            &#125; else if (deque.isEmpty() || deque.peek() != ch) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                deque.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return deque.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>用队列实现栈</title>
      <link href="/posts/24266.html"/>
      <url>/posts/24266.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/"></a></p><p><img src="/posts/24266/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230127020709.png"></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>1.队列的规则是先进后出，栈的规则是先进先出（可以直接用双端队列，把操作限制在一段，虽然这样感觉不太高明）我们可以使用两个队列，在添加元素时我们可以先将元素添加到辅助队列中，然后再将主队列里的元素依次全部转移给辅助队列，这时出栈只要控制主队列正常出列即可，栈顶元素就是队头的元素，主队列空则栈空</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line">    Queue&lt;Integer&gt; q1;</span><br><span class="line">    Queue&lt;Integer&gt; q2;</span><br><span class="line"></span><br><span class="line">    public MyStack() &#123;</span><br><span class="line">        q1 =  new LinkedList&lt;&gt;();</span><br><span class="line">        q2 = new LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        q2.offer(x);</span><br><span class="line">        while (!q1.isEmpty()) &#123;</span><br><span class="line">            q2.offer(q1.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //主辅队列交换</span><br><span class="line">        Queue&lt;Integer&gt; qTemp;</span><br><span class="line">        qTemp = q1;</span><br><span class="line">        q1 = q2;</span><br><span class="line">        q2 = qTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        return q1.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return q1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return q1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.简化，使用一个队列实现，依然主要是对元素进入队列时进行处理，每次都把元素加到栈顶就可以</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; q;</span><br><span class="line"></span><br><span class="line">    public MyStack() &#123;</span><br><span class="line">        q = new LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        //先将元素加入队列</span><br><span class="line">        q.offer(x);</span><br><span class="line">        //求队列长度</span><br><span class="line">        int size = q.size();</span><br><span class="line">        //这个过程挺有意思的，感觉就像贪吃蛇</span><br><span class="line">        while (size-- &gt; 1) &#123;</span><br><span class="line">            q.offer(q.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        return q.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return q.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return q.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.使用一个双端队列实现，这次我们对出队列的时候进行处理，设置一个主队列，一个辅助队列，每次要出栈的时候，我们将主队列中的所有元素除了第一个以外全部转移到辅助队列中，将辅助队列变为主队列，然后重新new一个辅助队列</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line">    Deque&lt;Integer&gt; q;</span><br><span class="line">    Deque&lt;Integer&gt; q1;</span><br><span class="line"></span><br><span class="line">    public MyStack() &#123;</span><br><span class="line">        q = new ArrayDeque&lt;&gt;();</span><br><span class="line">        q1 = new ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        q.addLast(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        int size = q.size();</span><br><span class="line">        while (size-- &gt; 1) &#123;</span><br><span class="line">            q1.addLast(q.poolFirst());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int res = q.pollFirst();</span><br><span class="line">        //交换引用对象</span><br><span class="line">        q = q1;</span><br><span class="line">        //辅助队列变为空</span><br><span class="line">        q1 = new ArrayDeque&lt;&gt;();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return q.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return q.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.只使用一个双端队列，跟上面思路相差不多，在出栈的时候我们将队列中除最后一个元素之外的元素全部依次从队头移到队尾，直到原本队尾的元素变为队头的元素，队头元素出列，完毕</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; q;</span><br><span class="line"></span><br><span class="line">    public MyStack() &#123;</span><br><span class="line">        q = new ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        q.addLast(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        int size = q.size();</span><br><span class="line">        while (size-- &gt; 1) &#123;</span><br><span class="line">            q.addLast(q.pollFirst());</span><br><span class="line">        &#125;</span><br><span class="line">        int res = q.pollFirst();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return q.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return q.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.最简单方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; q;</span><br><span class="line"></span><br><span class="line">    public MyStack() &#123;</span><br><span class="line">        q = new ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        q.addLast(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        return q.pollLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return q.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return q.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>栈实现队列</title>
      <link href="/posts/18433.html"/>
      <url>/posts/18433.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​<a href="https://leetcode.cn/problems/implement-queue-using-stacks/"></a></p><p><img src="/posts/18433/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126225518.png"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>栈是先进后出，并且进出只能从一端进行</p><p>队列是先进先出，一端进一段出，如果要用栈去模拟队列，创建两个开口方向不同的栈来实现，一个负责进一个负责出</p><p>进栈的时候</p><p><img src="/posts/18433/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126225911.png"></p><p>出栈的时候先把元素全部转移到出栈里</p><p><img src="/posts/18433/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126230028.png"></p><p>然后通过出栈实现pop</p><p><img src="/posts/18433/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126230123.png"></p><p><strong>必须保证出栈为空才可转移进栈中的元素，否则会导致元素错位从而出栈顺序混乱</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">class MyQueue &#123;</span><br><span class="line">    //队列是先进先出，栈是先进后出</span><br><span class="line"></span><br><span class="line">    //进栈，只负责进</span><br><span class="line">    Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    //出栈，只负责出</span><br><span class="line">    Stack&lt;Integer&gt; stackOut;</span><br><span class="line"></span><br><span class="line">    public MyQueue() &#123;</span><br><span class="line">        stackIn = new Stack&lt;&gt;();</span><br><span class="line">        stackOut = new Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        //正常压入即可</span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        //出栈的时候如果出栈不为空，则出栈继续出，如果出栈为空，把进栈里的东西全部转移到出栈里</span><br><span class="line">        pd();</span><br><span class="line">        return stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int peek() &#123;</span><br><span class="line">        //获取队头的元素</span><br><span class="line">        pd();</span><br><span class="line">        return stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        //空的情况为两个队列都空才算空</span><br><span class="line">        return stackOut.isEmpty() &amp;&amp; stackIn.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void pd() &#123;</span><br><span class="line">        //如果出栈为空，把进栈的东西全部装到出栈里</span><br><span class="line">        if (!stackOut.isEmpty()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            while (!stackIn.isEmpty()) &#123;</span><br><span class="line">                stackOut.push(stackIn.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>KMP</title>
      <link href="/posts/31301.html"/>
      <url>/posts/31301.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="KMP匹配模式算法"><a href="#KMP匹配模式算法" class="headerlink" title="KMP匹配模式算法"></a>KMP匹配模式算法</h1><p>本来以为串的知识点应该很简单，没想到，在最后两页栽了大跟头！！</p><p>克努特——莫里斯——普拉斯算法</p><p>串是由零个或多个字符组成的有序序列。对与串的基本操作有一部分与线性表十分相似，但是线性表更关注单个元素的操作，比如查找一个元素，插入或者删除一个元素，但是串中更多的是查找子串的位置，得到指定位置的字串，替换字串等。其中查询指定位置的子串相对而言比较重要，而KMP算法就是对一般查询字串位置的一种改进。</p><h2 id="朴素的匹配模式算法"><a href="#朴素的匹配模式算法" class="headerlink" title="朴素的匹配模式算法"></a>朴素的匹配模式算法</h2><p>查询子串位置的一般暴力解法——对主串做大循环，对每个字符开头做T的长度的小循环，直到匹配成功或者全部遍历完成为止</p><p>时间复杂度为O(（n-m+1）*m)</p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126212543.png"></p><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>这个算法。。。。。。我讲不明白。。。。。把我理解的图画一下吧，有时间再回炉重造。。。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>如果在子串中存在一部分相等的字符串，我们可通过修改短循环的起始位置来达到减少回溯次数作用，从而减少匹配所需的时间消耗</p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126213334.png"></p><p>如上图，在5位置匹配失败（这代表前面部分全部相等），果我们用暴力算法，那么下一步主串将会重新从子串的第一个开始继续匹配，但是我们研究子串中的前面部分，存在着两个完全相等的前后缀（ab），那么我们下一次匹配的时候完全可以从与后缀相等的前缀之后开始匹配从而达到减少操作次数的目的</p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126213834.png"></p><p>那么，我们在匹配失败的时候应该怎样知道应该回溯到什么地方呢？——构造next[], 最长相等前缀表</p><h3 id="前缀表"><a href="#前缀表" class="headerlink" title="前缀表"></a>前缀表</h3><p>图</p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126215218.png"></p><p>怎么理解j &#x3D; next[j]</p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126220704.png"></p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126220850.png"></p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126221114.png"></p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126221632.png"></p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126221646.png"></p><p>改进版本该怎么理解（右端空格里的东西应该也是A）</p><p><img src="/posts/31301/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126221702.png"></p><p>一图值千言！！！！</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p>这个怎么说呢。。。。。这个思路，我理解了这么久，但是，最后就只有这几行代码，确实非常震撼</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int kmp(String s, String t) &#123;</span><br><span class="line">    //细节，多次使用的数据先获取</span><br><span class="line">    int sl = s.length();</span><br><span class="line">    int tl = t.length();</span><br><span class="line">    //特判</span><br><span class="line">    if (sl &lt; tl) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取next数组</span><br><span class="line">    int[] next = kmpNext(t);</span><br><span class="line"></span><br><span class="line">    //开始匹配</span><br><span class="line">    int i = 0, j = 0;</span><br><span class="line">    while(i &lt; sl &amp;&amp; j &lt; tl) &#123;</span><br><span class="line">        //这里的位置不能换，要么在j为-1的时候可能会出错</span><br><span class="line">        if (j == -1 || s.charAt(i) == t.charAt(j)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (j == tl) &#123;</span><br><span class="line">        return i - j;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return  -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int[] kmpNext(String t) &#123;</span><br><span class="line">    int len = t.length();</span><br><span class="line">    int[] next = new int[len];</span><br><span class="line">    //这里必须初始化数组</span><br><span class="line">    next[0] = -1;</span><br><span class="line">    int i = 0, j = -1;</span><br><span class="line">    while (i &lt; len - 1) &#123;</span><br><span class="line">        if (j == -1 || t.charAt(j) == t.charAt(i)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            i++;</span><br><span class="line">            //此处为改进版本</span><br><span class="line">            if (t.charAt(j) == t.charAt(i)) &#123;</span><br><span class="line">                next[i] = next[j];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                next[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>拼图游戏知识点整理</title>
      <link href="/posts/63503.html"/>
      <url>/posts/63503.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一个简单的拼图游戏"><a href="#一个简单的拼图游戏" class="headerlink" title="一个简单的拼图游戏"></a>一个简单的拼图游戏</h1><p>最近看网课跟着网课老师写了一个简单的拼图游戏，感觉自己对平时常用的这些软件有了全新的认识，原来图片的移动不是移动，原来关闭窗口不用真的关闭。。。。。总之有点。。。难受。</p><p>学到的东西也很多，但还是自己整理一遍比较好，纸上得来终觉浅，深知此事要躬行。</p><p>对对象，跟方法的使用和程序设计有了更深的理解</p><h3 id="一些知识点"><a href="#一些知识点" class="headerlink" title="一些知识点"></a>一些知识点</h3><p>（初步认识）</p><p><strong>JFrame</strong>-Java的GUI程序的基本思路是以JFrame为基础，它是屏幕上window的对象，通过这个对象我们能给程序设计各种窗口，通过一些方法我们可以实现窗口的最大化，最小化，选择关闭模式等基础功能</p><p><em><strong>这是一个容器，允许程序员把其他组件添加到它里面，把他们组织起来并把他们呈现给用户。</strong></em></p><p>包含方法</p><p><img src="/posts/63503/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230121013051.png"></p><p><img src="/posts/63503/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230121013134.png"></p><p><img src="/posts/63503/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230121013148.png"></p><p><strong>JPanel</strong>-Java图形用户界面工具包swing中的面板容器类，包含在javax.swing包中可以进行嵌套，功能是<em><strong>对窗体中具有相同逻辑功能的组件进行组合</strong></em>，是一种轻量级容器，可以加到JFrame窗体中。</p><p>是一种面板容器类，是一种轻量级容器，可以加到JFrame窗体中，自身可以嵌套组合，在不同子容器中可以包含其他组件如JButton、JTextArea、JTextField 等，功能是对窗体上的这些控件进行组合</p><p><strong>JLabel</strong>-该对象可以显示文本、图像，或同时显示二者。可以通过设置垂直和水平对齐方式，制定标签显示区中标签内容在何处对其。默认情况下，标签在其显示区域内居中对齐。默认情况下，只显示文本的标签是开始边对齐；而只显示图像的标签则水平居中对齐（需要注意的是，添加对象的顺序会导致我们设置的一些东西失效，比如文字位置，先加的在上面，后加的在下面，如果出现设置失效的情况可以试着改变添加的顺序）</p><p>用于管理显示图片或文本</p><p><strong>JMenuBar</strong>菜单栏JMenuBar，菜单JMenu，菜单项JMenuItem,一旦A有子菜单项，则A为菜单JMenu，而不是菜单项JMenuItem,菜单可以互相包含</p><p><strong>JDialog</strong>-对话框（<em>Jdialog</em>）与框架（JFrame）有一些相似，但它一般是一个临时的窗口，主要用于显示提示信息或接受用户输入。</p><p><strong>JTextField</strong>-一个轻量级组件，它允许编辑单行文本。</p><p><strong>JPasswordField</strong>-允许我们输入一行字像输入框，大师隐藏星号或点创建密码</p><p><strong>JButton</strong>-JButton类的实例。用于创建按钮</p><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>先说游戏的实现思路，初始化一个二维数组，根据数组中的值显示对应图片，此时记录空白图片的位置，根据用户的输入与记录的空白图片位置去对数组中的值进行改变，然后根据新数组中的值再去打印对应的图片实现移动图片的操作，如果每次移动对数组中的值进行判断，符合一定规律结束程序</p><p>游戏主要针对三个窗口进行设计，登录界面，注册界面，游戏界面，所以需要设计三个窗口类，我们直接新建class文件继承Java中原有的窗口类JFrame即可，通过添加新的方法或者对父类中的方法进行修改来设计我们自己的窗口，并且我们还需要通过键盘或者鼠标来对这些窗口中的组件进行操作所以还要实现鼠标监听接口或者键盘监听接口，然后在重写的方法中实现我们希望它实现的逻辑</p><h3 id="游戏界面"><a href="#游戏界面" class="headerlink" title="游戏界面"></a>游戏界面</h3><p>成员变量</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//图片位置</span><br><span class="line">int data[][] = new int[4][4];</span><br><span class="line"></span><br><span class="line">int win[][] =  new int[][]&#123;</span><br><span class="line">        &#123;1,2,3,4&#125;,</span><br><span class="line">        &#123;5,6,7,8&#125;,</span><br><span class="line">        &#123;9,10,11,12&#125;,</span><br><span class="line">        &#123;13,14,15,0&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">//记录空白方块在二维数组中的位置</span><br><span class="line">int x = 0,y = 0;</span><br><span class="line">//记录步数</span><br><span class="line">int count = 0;</span><br><span class="line">//隐藏功能</span><br><span class="line">public int flag;</span><br><span class="line"></span><br><span class="line">//考验字符串操作，通过修稿字符串中的特定内容我们可以让软件显示不同的图片</span><br><span class="line">String path = &quot;image/animal/animal2/&quot;;</span><br><span class="line"></span><br><span class="line">//因为actionlistener需要获取这些对象（用于判断该实现什么逻辑），所以不把他们单独写在菜单初始化方法中</span><br><span class="line">//创建菜单下条目的对象</span><br><span class="line">JMenuItem replayItem = new JMenuItem(&quot;重新游戏&quot;);</span><br><span class="line">JMenuItem reLoginItem = new JMenuItem(&quot;重新登录&quot;);</span><br><span class="line">JMenuItem closeItem = new JMenuItem(&quot;关闭游戏&quot;);</span><br><span class="line">JMenuItem girlItem = new JMenuItem(&quot;美女&quot;);</span><br><span class="line">JMenuItem animalItem = new JMenuItem(&quot;动物&quot;);</span><br><span class="line">JMenuItem sportItem = new JMenuItem(&quot;运动&quot;);</span><br><span class="line">JMenuItem textItem = new JMenuItem(&quot;游戏说明&quot;);</span><br><span class="line"></span><br><span class="line">JMenuItem accountItem = new JMenuItem(&quot;微信&quot;);</span><br></pre></td></tr></table></figure><p>初始化容器</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public GameJFrame(int flag) &#123;</span><br><span class="line">    //在创建界面的时候顺带创建了一个隐藏的管理容器（根容器），我们可以把图片，按钮，菜单这些东西交给他，但要使用getContentPane方法</span><br><span class="line"></span><br><span class="line">//这里下面的一些步骤，比如初始化图片需要在其他方法中多次使用，所以直接写成方法，逻辑不可改变</span><br><span class="line">    //初始化界面</span><br><span class="line">    initJFrame();</span><br><span class="line">    //初始化菜单</span><br><span class="line">    initJMenuBur();</span><br><span class="line">    //初始化数据</span><br><span class="line">    initData();</span><br><span class="line">    //初始化,添加图片（根据初始化后的数据打印图片）</span><br><span class="line">    initImage();</span><br><span class="line">    this.flag = flag;</span><br><span class="line"></span><br><span class="line">    //界面默认隐藏，设置是否可见（放最后）</span><br><span class="line">    this.setVisible(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化游戏数据</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void initData() &#123;</span><br><span class="line">    int num[] = &#123;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15&#125;;</span><br><span class="line">    Random r = new Random();</span><br><span class="line">    for (int i = 0; i &lt; num.length; i++) &#123;</span><br><span class="line">        int index = r.nextInt(num.length);</span><br><span class="line">        int temp = num[i];</span><br><span class="line">        num[i] = num[index];</span><br><span class="line">        num[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; 4; j++) &#123;</span><br><span class="line">            if (num[count] == 0) &#123;</span><br><span class="line">                x = i;</span><br><span class="line">                y = j;</span><br><span class="line">            &#125;</span><br><span class="line">            data[i][j] = num[count++];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化图像</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void initImage() &#123;</span><br><span class="line"></span><br><span class="line">    //因为我们会多次调用这个方法，所以每次调用这个方法前都先清空所有组件</span><br><span class="line">    //容器中的内容是是先添加的在上面，后添加的在下面，每次都先清空这些组件然后再添加内容保证新内容不被覆盖</span><br><span class="line">    this.getContentPane().removeAll();</span><br><span class="line">//添加顺序比较重要</span><br><span class="line">//如果胜利，显示胜利的图片</span><br><span class="line">    if (victory()) &#123;</span><br><span class="line">        JLabel win = new JLabel(new ImageIcon(&quot;image/win.png&quot;));</span><br><span class="line">        win.setBounds(203,283,197,73);//设置边界</span><br><span class="line">        通过这个对象，获取他的默认容器，添加窗口</span><br><span class="line">        this.getContentPane().add(win);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//添加步数窗口</span><br><span class="line">    JLabel stepCount = new JLabel(&quot;步数：&quot;+count);</span><br><span class="line">    stepCount.setBounds(50,30,100,20);</span><br><span class="line">    this.getContentPane().add(stepCount);</span><br><span class="line"></span><br><span class="line">    //添加背景图片（先加载的图片在上方,后加载的图片在下方）</span><br><span class="line">    //所以背景图片最后加</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; 4; j++) &#123;</span><br><span class="line">            //创建一个管理容器</span><br><span class="line">            JLabel jLabel = new JLabel(new ImageIcon(path+data[i][j]+&quot;.jpg&quot;));</span><br><span class="line">            //指定图片位置</span><br><span class="line">            jLabel.setBounds(105*j+83,105*i+134,105,105);</span><br><span class="line">            //给图片添加边框</span><br><span class="line">            //参数为斜面方向</span><br><span class="line">            jLabel.setBorder(new BevelBorder(0));</span><br><span class="line">            //把管理容器添加到界面中</span><br><span class="line">            this.getContentPane().add(jLabel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ImageIcon bg = new ImageIcon(&quot;image/background.png&quot;);</span><br><span class="line">    JLabel backGround = new JLabel(bg);</span><br><span class="line">    backGround.setBounds(40,40,508,560);</span><br><span class="line">    //把图片添加到控制容器中</span><br><span class="line">    this.getContentPane().add(backGround);</span><br><span class="line"></span><br><span class="line">    //刷新界面（显示新的界面）</span><br><span class="line">    this.getContentPane().repaint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化游戏菜单</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void initJMenuBur() &#123;</span><br><span class="line">    //初始化菜单</span><br><span class="line">    //创建整个菜单的对象</span><br><span class="line">    JMenuBar jMenuBar = new JMenuBar();</span><br><span class="line">    //创建菜单上两个选项的对象（功能  关于我们）</span><br><span class="line">    JMenu functionJMenu = new JMenu(&quot;功能&quot;);</span><br><span class="line">    JMenu aboutJMenu = new JMenu(&quot;关于我们&quot;);</span><br><span class="line">    JMenu changeImage = new JMenu(&quot;更换图片&quot;);</span><br><span class="line">    changeImage.add(girlItem);</span><br><span class="line">    changeImage.add(animalItem);</span><br><span class="line">    changeImage.add(sportItem);</span><br><span class="line"></span><br><span class="line">    //将选项组合,添加条目</span><br><span class="line">    //一级整合</span><br><span class="line">    functionJMenu.add(replayItem);</span><br><span class="line">    functionJMenu.add(reLoginItem);</span><br><span class="line">    functionJMenu.add(closeItem);</span><br><span class="line">    functionJMenu.add(changeImage);</span><br><span class="line"></span><br><span class="line">    aboutJMenu.add(accountItem);</span><br><span class="line"></span><br><span class="line">    //给条目绑定事件</span><br><span class="line">    replayItem.addActionListener(this);</span><br><span class="line">    reLoginItem.addActionListener(this);</span><br><span class="line">    closeItem.addActionListener(this);</span><br><span class="line">    accountItem.addActionListener(this);</span><br><span class="line">    girlItem.addActionListener(this);</span><br><span class="line">    animalItem.addActionListener(this);</span><br><span class="line">    sportItem.addActionListener(this);</span><br><span class="line">    textItem.addActionListener(this);</span><br><span class="line"></span><br><span class="line">    //二级整合</span><br><span class="line">    jMenuBar.add(functionJMenu);</span><br><span class="line">    jMenuBar.add(aboutJMenu);</span><br><span class="line">    jMenuBar.add(textItem);</span><br><span class="line"></span><br><span class="line">    //给整个界面设置菜单</span><br><span class="line">    this.setJMenuBar(jMenuBar);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化主界面</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void initJFrame() &#123;</span><br><span class="line">    //设置窗口</span><br><span class="line">    //设置界面宽高</span><br><span class="line">    this.setSize(603,680);</span><br><span class="line">    //设置界面标题</span><br><span class="line">    this.setTitle(&quot;拼图单机版 v1.0&quot;);</span><br><span class="line">    //设置界面置顶</span><br><span class="line">    this.setAlwaysOnTop(true);</span><br><span class="line">    //设置界面居中</span><br><span class="line">    this.setLocationRelativeTo(null);</span><br><span class="line">    //设置关闭模式</span><br><span class="line">    //关闭模式0，啥都不干 1，默认 2，多个界面，只有关掉最后一个界面才会关闭虚拟机（所有界面都要这样设置） 3，关掉一个，虚拟机结束</span><br><span class="line">    this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">    //取消默认居中放置，取消之后才能按照我的想法(xy轴形式)放置图片</span><br><span class="line">    this.setLayout(null);</span><br><span class="line">    //给整个界面添加监听事件</span><br><span class="line">    //这样this.getContentPane().addKeyListener(this);为什么错了，中间那一段到底是什么意思</span><br><span class="line">    //这个窗口的管理容器中添加了一个监听对象？</span><br><span class="line">    </span><br><span class="line">    //在当前对象上添加键盘监听</span><br><span class="line">    this.addKeyListener(this);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>游戏说明，这里添加顺序比较重要</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void showJDialog() &#123;</span><br><span class="line">    //创建一个弹框对象</span><br><span class="line">    JDialog dialog = new JDialog();</span><br><span class="line">    //设置弹框大小</span><br><span class="line">    dialog.setSize(600, 500);</span><br><span class="line">    //让弹框制定</span><br><span class="line">    dialog.setAlwaysOnTop(true);</span><br><span class="line">    //让弹框居中</span><br><span class="line">    dialog.setLocationRelativeTo(null);</span><br><span class="line">    //弹框不关闭无法操作下面界面</span><br><span class="line">    dialog.setModal(true);</span><br><span class="line"></span><br><span class="line">    //创建管理文字对象并添加到弹框中</span><br><span class="line">    JLabel text = new JLabel(new ImageIcon(&quot;image/img.png&quot;));</span><br><span class="line">    text.setBounds(0,0,500,400);</span><br><span class="line">    dialog.getContentPane().add(text);</span><br><span class="line">    //显示弹框</span><br><span class="line">    dialog.setVisible(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否胜利（可优化，节省储存正确答案的空间）</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean victory() &#123;</span><br><span class="line">    for (int i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; data[i].length; j++) &#123;</span><br><span class="line">            if (data[i][j] != win[i][j]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写的监听方法</p><p>这里的思路是监听到对应事件后，判断监听源，想写啥写啥，这个时候上面写的方法就十分重要了</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override检测单击</span><br><span class="line">public void actionPerformed(ActionEvent e) &#123;</span><br><span class="line">    Object obj = e.getSource();</span><br><span class="line">    if (obj == replayItem) &#123;//重新开始</span><br><span class="line">        //计步器清零</span><br><span class="line">        count = 0;</span><br><span class="line">        //打乱数据</span><br><span class="line">        initData();</span><br><span class="line">        //加载图片</span><br><span class="line">        initImage();</span><br><span class="line"></span><br><span class="line">    &#125; else if (obj == reLoginItem) &#123;//重新登录，匿名对象知识点</span><br><span class="line">        //返回登录界面</span><br><span class="line">        //关闭界面</span><br><span class="line">        this.setVisible(false);</span><br><span class="line">        //打开登录界面</span><br><span class="line">        new LoginJFrame();</span><br><span class="line"></span><br><span class="line">    &#125; else if (obj == closeItem) &#123;//关闭</span><br><span class="line">        System.exit(0);</span><br><span class="line"></span><br><span class="line">    &#125; else if (obj == accountItem) &#123;//关于我。。。。。。看半天才看出来是啥，直到我看了一眼图片</span><br><span class="line">        //创建一个弹框对象</span><br><span class="line">        JDialog jDialog = new JDialog();</span><br><span class="line">        //创建一个管理图片的容器对象</span><br><span class="line">        JLabel jLabel = new JLabel(new ImageIcon(&quot;image/1673683779539.jpg&quot;));</span><br><span class="line">        //设置位置和宽高</span><br><span class="line">        jLabel.setBounds(0,0,355,431);</span><br><span class="line">        //把图片添加到弹框中</span><br><span class="line">        //弹框只是一个框架，</span><br><span class="line">        jDialog.getContentPane().add(jLabel);</span><br><span class="line">        //给弹框设置大小</span><br><span class="line">        jDialog.setSize(405,481);</span><br><span class="line">        //让弹框指定</span><br><span class="line">        jDialog.setAlwaysOnTop(true);</span><br><span class="line">        //让弹框居中</span><br><span class="line">        jDialog.setLocationRelativeTo(null);</span><br><span class="line">        //弹框不关闭，无法操作下面的界面</span><br><span class="line">        jDialog.setModal(true);</span><br><span class="line">        //让弹框显示出来</span><br><span class="line">        jDialog.setVisible(true);</span><br><span class="line"></span><br><span class="line">    &#125; else if (obj == girlItem) &#123;//改变成员变量path中的内容，考察字符串操作</span><br><span class="line">        System.out.println(&quot;切换美女&quot;);</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        int pictureNumb;</span><br><span class="line">        if (flag == 0) &#123;</span><br><span class="line">            pictureNumb = r.nextInt(11) + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pictureNumb = r.nextInt(2) + 12;</span><br><span class="line">        &#125;</span><br><span class="line">        path = &quot;image/girl/girl&quot;+pictureNumb+&quot;/&quot;;</span><br><span class="line">        count = 0;</span><br><span class="line">        initData();</span><br><span class="line">        initImage();</span><br><span class="line">    &#125; else if (obj == animalItem) &#123;</span><br><span class="line">        System.out.println(&quot;切换动物&quot;);</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        int pictureNumb = r.nextInt(8)+1;</span><br><span class="line">        path = &quot;image/animal/animal&quot;+pictureNumb+&quot;/&quot;;</span><br><span class="line">        count = 0;</span><br><span class="line">        initData();</span><br><span class="line">        initImage();</span><br><span class="line">    &#125; else if (obj == sportItem) &#123;</span><br><span class="line">        System.out.println(&quot;切换运动&quot;);</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        int pictureNumb = r.nextInt(10)+1;</span><br><span class="line">        path = &quot;image/sport/sport&quot;+pictureNumb+&quot;/&quot;;</span><br><span class="line">        count = 0;</span><br><span class="line">        initData();</span><br><span class="line">        initImage();</span><br><span class="line">    &#125; else if (obj == textItem) &#123;</span><br><span class="line">        showJDialog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测键盘输入</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void keyTyped(KeyEvent e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//按下调用</span><br><span class="line">@Override//显示原图</span><br><span class="line">public void keyPressed(KeyEvent e) &#123;</span><br><span class="line">    int code = e.getKeyCode();</span><br><span class="line">    if (code == 65) &#123;</span><br><span class="line">        this.getContentPane().removeAll();</span><br><span class="line">        JLabel all = new JLabel(new ImageIcon(path+&quot;all.jpg&quot;));</span><br><span class="line">        all.setBounds(83,134,420,420);</span><br><span class="line">        this.getContentPane().add(all);</span><br><span class="line"></span><br><span class="line">        ImageIcon bg = new ImageIcon(&quot;image/background.png&quot;);</span><br><span class="line">        JLabel backGround = new JLabel(bg);</span><br><span class="line">        backGround.setBounds(40,40,508,560);</span><br><span class="line">        //把图片添加到根界面中</span><br><span class="line">        this.getContentPane().add(backGround);</span><br><span class="line">        this.getContentPane().repaint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void keyReleased(KeyEvent e) &#123;</span><br><span class="line">    //如果胜利，此方法直接结束,就不能再移动了</span><br><span class="line">    if (victory()) &#123;//胜利之后图片就不应该动了</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果还没胜利</span><br><span class="line">    //左37 右39 上38 下40</span><br><span class="line">    //这里应该是错的，猜测不管按啥都会导致步数++</span><br><span class="line">    count++;</span><br><span class="line">    //获取按键值</span><br><span class="line">    int code = e.getKeyCode();</span><br><span class="line">    if (code == 37) &#123;</span><br><span class="line">        if (y == 3) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;向左移动&quot;);</span><br><span class="line">        data[x][y] = data[x][y + 1];</span><br><span class="line">        data[x][y + 1] = 0;</span><br><span class="line">        y++;</span><br><span class="line">        initImage();</span><br><span class="line">    &#125; else if (code == 38) &#123;</span><br><span class="line">        if (x == 3) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;向上移动&quot;);</span><br><span class="line">        data[x][y] = data[x + 1][y];</span><br><span class="line">        data[x + 1][y] = 0;</span><br><span class="line">        x++;</span><br><span class="line">        initImage();</span><br><span class="line">    &#125; else if (code == 39) &#123;</span><br><span class="line">        if (y == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;向右移动&quot;);</span><br><span class="line">        data[x][y] = data[x][y - 1];</span><br><span class="line">        data[x][y - 1] = 0;</span><br><span class="line">        y--;</span><br><span class="line">        initImage();</span><br><span class="line">    &#125; else if (code == 40) &#123;</span><br><span class="line">        if (x == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;向下移动&quot;);</span><br><span class="line">        data[x][y] = data[x - 1][y];</span><br><span class="line">        data[x - 1][y] = 0;</span><br><span class="line">        x--;</span><br><span class="line">        initImage();</span><br><span class="line">    &#125; else if (code == 65) &#123;//重新开始</span><br><span class="line">        initImage();</span><br><span class="line">    &#125; else if (code == 87) &#123;//作弊代码</span><br><span class="line">        data = new int[][]&#123;</span><br><span class="line">                &#123;1,2,3,4&#125;,</span><br><span class="line">                &#123;5,6,7,8&#125;,</span><br><span class="line">                &#123;9,10,11,12&#125;,</span><br><span class="line">                &#123;13,14,15,0&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        initImage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>跟着网课老师写了大部分，自己补了隐藏功能及更换图片，游戏说明的部分，还有登录部分（最后还是改成老师的代码），首先游戏一开始就创建的登录部分，登录部分包含一个集合，里面包含的初始化的用户信息，如果信息对的上，那么窗口隐身，实现游戏窗口，需要注意的是先判断用户名或密码是否为空，然后判断验证码，最后判断正误，整体还是比较简单，用户注册的功能猜测可以用数据库，主要逻辑是隐藏登录界面，新建注册界面，初始化注册界面，加载组件，判断输入内容，如果合法，添加到数据库中 ，返回登录界面，注册界面隐藏，然而单机版的化估计可以用文件输入输出，可以总结出一些固定操作</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java自带的栈与队列 类</title>
      <link href="/posts/49362.html"/>
      <url>/posts/49362.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作为高级语言，Java肯定是自带了Stack类跟Queue类，学习使用现成的还是有必要的</p><h1 id="Stack-类"><a href="#Stack-类" class="headerlink" title="Stack 类"></a>Stack 类</h1><p>栈是Vector的一个子类，它实现类一个标准的后进先出栈</p><p><strong>构造函数</strong></p><p>Stack()</p><p><strong>包含方法</strong></p><p>除了Vector中定义的所有方法外，自己的方法有</p><p><img src="/posts/49362/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230113162000.jpg"></p><p><strong>实例</strong></p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package stack;</span><br><span class="line"></span><br><span class="line">import java.util.EmptyStackException;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class StackDemo &#123;</span><br><span class="line"></span><br><span class="line">    static void showpush(Stack&lt;Integer&gt; st, int a) &#123;</span><br><span class="line">        st.push(new Integer(a));</span><br><span class="line">        System.out.println(&quot;push(&quot; + a + &quot;)&quot;);</span><br><span class="line">        System.out.println(&quot;stack: &quot; + st);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void showpop(Stack&lt;Integer&gt; st) &#123;</span><br><span class="line">        System.out.print(&quot;pop -&gt; &quot;);</span><br><span class="line">        Integer a = (Integer) st.pop();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(&quot;stack: &quot; + st);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; st = new Stack&lt;Integer&gt;();</span><br><span class="line">        System.out.println(&quot;stack: &quot; + st);</span><br><span class="line">        showpush(st, 42);</span><br><span class="line">        showpush(st, 66);</span><br><span class="line">        showpush(st, 99);</span><br><span class="line">        showpop(st);</span><br><span class="line">        showpop(st);</span><br><span class="line">        showpop(st);</span><br><span class="line">        try &#123;</span><br><span class="line">            showpop(st);</span><br><span class="line">        &#125; catch (EmptyStackException e) &#123;</span><br><span class="line">            System.out.println(&quot;empty stack&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/49362/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230113163206.png" alt="运行结果"></p>]]></content>
      
      
      <categories>
          
          <category> 栈与队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>队列——java</title>
      <link href="/posts/49269.html"/>
      <url>/posts/49269.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>这里是我比较不确定的，感觉不太稳，但是不想测试了，如果真的有错。。。。。。日后再改</p><h2 id="静态队列"><a href="#静态队列" class="headerlink" title="静态队列"></a>静态队列</h2><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Queue;</span><br><span class="line">//现在有两种思路，一种是动态的，一种是静态的，为了巩固静态链表，我在这里只写静态的</span><br><span class="line">//队列各元素之前也具有前驱后继关系</span><br><span class="line">//采用一种取巧的方法，如果后面排满了，前面有位置，那么整体前移</span><br><span class="line">//我上面说的屁话，还是直接用循环队列的好，循环队列多香啊！</span><br><span class="line">class SqQueue&#123;</span><br><span class="line">    int maxSize = 100;</span><br><span class="line">    int data[];</span><br><span class="line">    int front;</span><br><span class="line">    int rear;</span><br><span class="line">    int count;</span><br><span class="line"></span><br><span class="line">    public SqQueue() &#123;</span><br><span class="line">        this.data = new int[maxSize];</span><br><span class="line">        front = 0;</span><br><span class="line">        rear = 1;</span><br><span class="line">        count = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int QueueLength() &#123;</span><br><span class="line">        return count;</span><br><span class="line">        //return (rear - front + maxSize) % maxSize</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void EnQueue(int x) &#123;</span><br><span class="line">        if(rear == maxSize - 1 &amp;&amp; front != 0) &#123;</span><br><span class="line">            data[rear] = x;</span><br><span class="line">            count++;</span><br><span class="line">            rear = 0;</span><br><span class="line">        &#125; else if ((rear + 1) != front) &#123;</span><br><span class="line">            data[rear] = x;</span><br><span class="line">            count++;</span><br><span class="line">            rear++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //感觉比较不太稳的地方</span><br><span class="line">    public int DeQueue() &#123;</span><br><span class="line">        int pos = -1;</span><br><span class="line">        if(front == maxSize - 1 &amp;&amp; count != 0)&#123;</span><br><span class="line">            pos = data[front];</span><br><span class="line">            front = 0;</span><br><span class="line">            count--;</span><br><span class="line">        &#125; else if (count != 0) &#123;</span><br><span class="line">            pos = data[front];</span><br><span class="line">            front++;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        return pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyQueue &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h2><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Queue;</span><br><span class="line"></span><br><span class="line">class QueueNode &#123;</span><br><span class="line">    int data;</span><br><span class="line">    QueueNode next;</span><br><span class="line"></span><br><span class="line">    public QueueNode() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public QueueNode(int data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LinkQueue &#123;</span><br><span class="line">    QueueNode front ;</span><br><span class="line">    QueueNode rear ;</span><br><span class="line">    int count;</span><br><span class="line"></span><br><span class="line">    public LinkQueue() &#123;</span><br><span class="line">        front = new QueueNode();</span><br><span class="line">        rear = front;</span><br><span class="line">        count = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void EnQueue(int x) &#123;</span><br><span class="line">        QueueNode node = new QueueNode(x);</span><br><span class="line">        rear.next = node;</span><br><span class="line">        rear = node;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void DeQueue() &#123;</span><br><span class="line">        if (front.next.next != null) &#123;</span><br><span class="line">            front.next = front.next.next;</span><br><span class="line">            count--;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            rear = front;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 栈与队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈——java</title>
      <link href="/posts/40188.html"/>
      <url>/posts/40188.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>直接上我写的栈的代码，栈其实只是一种特殊的线性表，以下的栈几乎都没有经过测试，如有错误，之后再改吧</p><h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><p>普通的顺序栈</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package stack.SXstack;</span><br><span class="line"></span><br><span class="line">class SElem &#123;</span><br><span class="line">    final int maxSize = 100;</span><br><span class="line">    //储存数据</span><br><span class="line">    public int data[];</span><br><span class="line">    //储存栈顶位置</span><br><span class="line">    int top;</span><br><span class="line"></span><br><span class="line">    public SElem() &#123;</span><br><span class="line">        this.data = new int[maxSize];</span><br><span class="line">        this.top = -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //入栈，返回入栈是否成功</span><br><span class="line">    boolean Push(int x) &#123;</span><br><span class="line">        if (top == maxSize - 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            data[++top] = x;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出栈，返回出栈的元素</span><br><span class="line">    int Pop() &#123;</span><br><span class="line">        if (top == -1) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return data[top--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//栈的操作让我们不必担心数组下标这些多余操作，更加直面问题的本质</span><br><span class="line">public class SXstack &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SElem a = new SElem();</span><br><span class="line">        a.Push(1);</span><br><span class="line">        a.Push(2);</span><br><span class="line">        a.Push(3);</span><br><span class="line">        a.Push(4);</span><br><span class="line">        a.Push(5);</span><br><span class="line">        System.out.println(a.Pop());</span><br><span class="line">        System.out.println(a.Pop());</span><br><span class="line">        System.out.println(a.Pop());</span><br><span class="line">        System.out.println(a.Pop());</span><br><span class="line">        System.out.println(a.Pop());</span><br><span class="line">        System.out.println(a.Pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两栈共用空间</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package stack.SXstack;</span><br><span class="line">/*虽然是两栈共享空间，但是我们不用真的创建两个栈，两个栈一起操作还是会带来很多麻烦的，临界情况不太好考虑</span><br><span class="line">我们只需要用一个栈，来模拟两个栈对接在一起的情况即可，有点类似双向链表</span><br><span class="line">这种结构主要用于解决两个栈的空间需求有相反关系</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class SqDoubleStack &#123;</span><br><span class="line">    int maxSize = 100;</span><br><span class="line">    int data[] = new int[maxSize];</span><br><span class="line">    int top1;</span><br><span class="line">    int top2;</span><br><span class="line"></span><br><span class="line">    public SqDoubleStack() &#123;</span><br><span class="line">        top1 = -1;</span><br><span class="line">        top2 = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean Push(int x, int w) &#123;</span><br><span class="line">        if (top2 + top1 + 1== maxSize) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (w == 1) &#123;</span><br><span class="line">                data[++top1] = x;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                data[--top2] = x;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int Pop(int x, int w) &#123;</span><br><span class="line">        if(w == 1) &#123;</span><br><span class="line">            if(top1 == -1)&#123;</span><br><span class="line">                return -1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return data[top1--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (w == 2) &#123;</span><br><span class="line">            if (top2 == maxSize) &#123;</span><br><span class="line">                return -1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return data[top2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DoubleStack &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;肯定没问题 ，我就不测试了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h2><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package stack.LSstack;</span><br><span class="line"></span><br><span class="line">class StackNode&#123;</span><br><span class="line">    int data;</span><br><span class="line">    StackNode next;</span><br><span class="line"></span><br><span class="line">    public StackNode(int data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LinkStack &#123;</span><br><span class="line">    StackNode top;</span><br><span class="line">    int count;</span><br><span class="line"></span><br><span class="line">    public LinkStack() &#123;</span><br><span class="line">        count = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        if (top == null) &#123;</span><br><span class="line">            top = new StackNode(x);</span><br><span class="line">            count++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            StackNode pos = new StackNode(x);</span><br><span class="line">            pos.next = top;</span><br><span class="line">            top = pos;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        if (top == null) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int pos = top.data;</span><br><span class="line">            top = top.next;</span><br><span class="line">            count--;</span><br><span class="line">            return pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 栈与队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>静态链表</title>
      <link href="/posts/50363.html"/>
      <url>/posts/50363.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><h2 id="静态单链表"><a href="#静态单链表" class="headerlink" title="静态单链表"></a>静态单链表</h2><p>静态单链表是使用数组来模拟链表，静态链表本身是为了让那些没有指针的语言也能使用链表结构，但是对于其他有指针的语言而言，在算法比赛中，静态链表的使用要多得多，因为他用数组模拟，会更快，学长的说法是你不断的去new一个什么东西是很慢的，我的静态链表采用的思路跟动态链表基本相同，两个数组，一个e代表数据域，一个ne代表指针域，相同数组下标为一个结点，通过对应结点的指针域中所储存的值去寻找下一个结点，虽然储存的形式类似于顺序结构，但是因为有额外的空间用于储存该数据的逻辑结构，所以依然是链表。。。感觉好绕。。。。。。。不过重要的是，指针域中储存的是逻辑结构，<strong>只要能通过结点的指针域中的数值去找到下一个结点就可以</strong>，指针域中的数值可能是无序且不连续的，储存的只是相对位置，具体思路见下图，该图演示了一个静态链表在经历头插，插入，删除操作时其中数据的变化情况，我们可以很清楚的看到，静态链表的使用会造成空间的碎片，经过删除操作之后结点的顺序并不连续，所以指针域中所储存的数值根本就没有啥意义，只是相对位置罢了，理解透这一点剩下的操作就跟动态链表的操作完全一样</p><p><img src="/posts/50363/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230112012057.jpg"></p><p>此静态单链表的问题还是相当严重的，完全没有考虑输入错误的情况，默认所有操作完全合法，但是啊。。。。。如果真的要考虑用户输入这些东西的话我更宁愿用动态链表，如果只是比赛的话默认所有操作完全合法应该还是没问题的</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package leetcote;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    static int N = 1000;</span><br><span class="line">    static int e[] = new int[N];</span><br><span class="line">    static int ne[] = new int[N];</span><br><span class="line">    static int head = -1;</span><br><span class="line">    static int idx = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">            addToHead(i);</span><br><span class="line">        &#125;</span><br><span class="line">        print();</span><br><span class="line">        remove(2);</span><br><span class="line">        print();</span><br><span class="line">        addAtIndex(6,3);</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //头插法</span><br><span class="line">    //链表的逻辑顺序是不会变的，就是说永远能根据当前元素找到下一个元素，所以尾插法只是头指针的数值变不变而已</span><br><span class="line">    //绝对不要把idx当成判断链表大小的条件</span><br><span class="line">    static void addToHead(int x) &#123;</span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = head;</span><br><span class="line">        head = idx;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据下标返回数据</span><br><span class="line">    static int searchNum(int k) &#123;</span><br><span class="line">        int pos = head;</span><br><span class="line">        for (int i = 1; i &lt; k; i++)&#123;</span><br><span class="line">            pos = ne[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        return e[pos];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找数据返回下标（直接遍历？？？，不行，就算遍历你也不知道这到底是第几个元素，指针域的数据不能当作判断的标准）</span><br><span class="line">    static int searchIdx(int x) &#123;</span><br><span class="line">        int pos = head;</span><br><span class="line">        int num = -1;</span><br><span class="line">        do&#123;</span><br><span class="line">            num++;</span><br><span class="line">            if(e[pos] == x) &#123;</span><br><span class="line">                return num;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                pos = ne[pos];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;while(pos != -1);</span><br><span class="line"></span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //插入，先找前驱，再进行插入，可以直接使用上面的查找方法</span><br><span class="line">    //现在我更加怀疑学长的代码是有问题的</span><br><span class="line">    //现在可以十分确定我已经完全理解了静态链表，还是得靠自己实操画图~~~~~~，虽然过程真TM头疼</span><br><span class="line"></span><br><span class="line">    static void addAtIndex(int x, int k) &#123;</span><br><span class="line">        if (k == 0) &#123;</span><br><span class="line">            addToHead(x);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int pos = head;</span><br><span class="line">        for (int i = 0; i &lt; k - 1; i++) &#123;</span><br><span class="line">            pos = ne[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = ne[pos];</span><br><span class="line">        ne[pos] = idx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void remove(int k) &#123;</span><br><span class="line">        if (k == 0) &#123;</span><br><span class="line">            head = ne[head];</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int pos = head;</span><br><span class="line">            for (int i = 0; i &lt; k - 1; i++) &#123;</span><br><span class="line">                pos = ne[pos];</span><br><span class="line">            &#125;</span><br><span class="line">            ne[pos] = ne[ne[pos]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //打印数组中元素</span><br><span class="line">    static void print() &#123;</span><br><span class="line">        int pos = head;</span><br><span class="line">        while (pos != -1) &#123;</span><br><span class="line">            System.out.println(e[pos]);</span><br><span class="line">            pos = ne[pos];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ps:学长的代码是头插法，然后头插完之后的数据是5 4 3 2 1，插完之后再remove一个2，移除第二个元素，移除完之后的数据是5 4 3 1，感觉不对，如果是如果是移除第二个元素那么结构应该要么是5 3 2 1 要么是5 4 2 1 </p><p>这里附上学长的代码以供参考，万一是我错了嘞？？？</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">        using namespace std;</span><br><span class="line">        int n;</span><br><span class="line">        const int N = 1e5+10;</span><br><span class="line">        int head,e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line">        void init()</span><br><span class="line">        &#123;</span><br><span class="line">        head = -1;</span><br><span class="line">        idx = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void add_to_head(int x)</span><br><span class="line">        &#123;</span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = head;</span><br><span class="line">        head = idx;</span><br><span class="line">        idx++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void add(int k, int x)</span><br><span class="line">        &#123;</span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = ne[k];</span><br><span class="line">        ne[k] = idx;</span><br><span class="line">        idx++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void remove(int k)</span><br><span class="line">        &#123;</span><br><span class="line">        ne[k] = ne[ne[k]];</span><br><span class="line">        &#125;</span><br><span class="line">        int main()</span><br><span class="line">        &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        init();</span><br><span class="line">        for(int i = 1; i &lt;= n ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">        int x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        add_to_head(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = head ; i != -1; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">        cout &lt;&lt; e[i] &lt;&lt; &#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        puts(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">        remove(2);</span><br><span class="line"></span><br><span class="line">        for(int i = head ; i != -1; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">        cout &lt;&lt; e[i] &lt;&lt; &#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="静态双链表"><a href="#静态双链表" class="headerlink" title="静态双链表"></a>静态双链表</h2><p>这里我不再重新写一个静态双链表，用一个题目说明一切</p><p>[题目连接](<a href="https://www.luogu.com.cn/record/99490970">记录详情 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a>)</p><p><img src="/posts/50363/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230112161708.jpg"></p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class P1160 &#123;</span><br><span class="line">    static final int N = 101100;</span><br><span class="line">    static int e[] = new int[N];</span><br><span class="line">    static int l[] = new int[N];</span><br><span class="line">    static int r[] = new int[N];</span><br><span class="line">    static int head, tail, size, idx;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        inIt();</span><br><span class="line">        int n = sc.nextInt();</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            int k = sc.nextInt();</span><br><span class="line">            int p = sc.nextInt();</span><br><span class="line">            cr(i,k,p);</span><br><span class="line">        &#125;</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            int k = sc.nextInt();</span><br><span class="line">            remove(k);</span><br><span class="line">        &#125;</span><br><span class="line">        int s = 2;</span><br><span class="line">        int pos = r[head];</span><br><span class="line">        for (int i = 0; pos != 1; i++) &#123;</span><br><span class="line">            System.out.print(e[pos]+&quot; &quot;);</span><br><span class="line">            pos = r[pos];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static void inIt() &#123;</span><br><span class="line">        l[0] = -1;</span><br><span class="line">        r[0] = 2;</span><br><span class="line">        l[1] = 2;</span><br><span class="line">        r[2] = -1;</span><br><span class="line">        e[2] = 1;</span><br><span class="line">        l[2] = 0;</span><br><span class="line">        r[2] = 1;</span><br><span class="line">        head = 0;</span><br><span class="line">        tail = 1;</span><br><span class="line">        size = 1;</span><br><span class="line">        idx = 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void cr(int num, int x, int w) &#123;</span><br><span class="line">        //num = 2, x = 1, w = 1</span><br><span class="line">        e[idx] = num;</span><br><span class="line">        if (w == 1) &#123;</span><br><span class="line">            l[idx] = x+1;</span><br><span class="line">            r[idx] = r[x+1];</span><br><span class="line">            l[r[x+1]] = idx;</span><br><span class="line">            r[x+1] = idx;</span><br><span class="line">            size++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            r[idx] = x+1;</span><br><span class="line">            l[idx] = l[x+1];</span><br><span class="line">            r[l[x+1]] = idx;</span><br><span class="line">            l[x+1] = idx;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void remove(int x) &#123;</span><br><span class="line">        if((l[x + 1] == -1 &amp;&amp; r[x + 1] == -1) || x &lt;= 0 || x &gt; size) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            r[l[x+1]] = r[x+1];</span><br><span class="line">            l[r[x+1]] = l[x+1];</span><br><span class="line">            l[x+1] = -1;</span><br><span class="line">            r[x+1] = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及到链表，最好画图，除非熟练度够，这个题目特殊的地方在于元素与地址是一一对应的，我们将元素1<del>n,依次储存在数组的2</del>n+1,而且我们是添加完所有元素之后才对数组进行删除操作，也就是说，只要知道元素的值我们可以马上知到它位于链表的什么位置，一般对链表元素进行操作的时候都要找到他的前驱，通过前驱对元素进行操作，这个题目特殊就在于，我们只要知道元素的值，就能直接推出他在链表中的位置，所以删除操作是非常简单的，这应该也算是一种特殊情况，元素的值竟然跟他所处的位置一一对应，话说这个题目感觉也不太像真正的双链表。。。。。。。。总之，这是一种特殊情况，不需要找前驱的特殊情况</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>环形链表</title>
      <link href="/posts/51245.html"/>
      <url>/posts/51245.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h1><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/"></a></p><p><img src="/posts/51245/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102210240.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>我们定义一个快指针，定义一个慢指针，快指针走两步，慢指针走一步，如果链表中存在环，那么这两个指针一定会相遇，这时候我们再让快指针跟慢指针开始一步一步走，那么相遇的地方就是进入循环的地方（需要数学证明）</p><p>当两个指针相遇后，让快指针从头开始跟慢指针一起一步一步走，那么相遇的点一定是入口</p><p><img src="/posts/51245/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102212216.png"></p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode detectCycle(ListNode head) &#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            if (slow == fast) &#123;</span><br><span class="line">                ListNode index1 = fast;</span><br><span class="line">                ListNode index2 = head;</span><br><span class="line">                while (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                return index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希集合"><a href="#哈希集合" class="headerlink" title="哈希集合"></a>哈希集合</h3><p>施工中</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表相交</title>
      <link href="/posts/31522.html"/>
      <url>/posts/31522.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/"></a></p><p><img src="/posts/31522/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102204219.png" alt="微信截图_20230102204219"></p><p><img src="/posts/31522/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102204240.png"></p><p><img src="/posts/31522/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102204248.png"></p><p><img src="/posts/31522/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102204256.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>关键还是要明确这个相交链表的形状，如果相交，那么形状只有可能是一个y形，并且开口只能朝左，如果方向不一样我就要怀疑他是二叉树了，所以如果两个相交链表不一样长，那么只有可能是开头的部分不一样长，从相交点到尾部的长度一定一样（感觉自己在说一堆废话但是道理就是这个道理）</p><p>按照这个道理，我们可以先确定两个链表的长度，然后让长的链表先走，直到长链表剩下的长度跟短链表一样长，然后让长链表跟短链表一起走，（相交点只可能出现于这个部分），如果有交点，返回，如果没有交点，结束</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">        ListNode cur1 = headA;</span><br><span class="line">        int a = 0;</span><br><span class="line">        ListNode cur2 = headB;</span><br><span class="line">        int b = 0;</span><br><span class="line">        //确定a长度</span><br><span class="line">        while (cur1 != null) &#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">        //确定b长度</span><br><span class="line">        while (cur2 != null) &#123;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">            b++;</span><br><span class="line">        &#125;</span><br><span class="line">        //为了不改变链表结构</span><br><span class="line">        cur1 = headA;</span><br><span class="line">        cur2 = headB;</span><br><span class="line">        //确定差值</span><br><span class="line">        int cz = Math.abs(a-b);</span><br><span class="line">        //让长链表先走</span><br><span class="line">        if (a &gt; b) &#123;</span><br><span class="line">            for (int i = 0; i &lt; cz; i++) &#123;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (a &lt; b) &#123;</span><br><span class="line">            for (int i = 0; i &lt; cz; i++) &#123;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">//一起走，找交点</span><br><span class="line">        while (cur1 !=  cur2 &amp;&amp; cur2 != null &amp;&amp; cur1 != null) &#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">            if (cur1 == cur2 &amp;&amp; cur1 != null) &#123;</span><br><span class="line">                return cur1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur1;</span><br><span class="line">        //这个地方不可以改成null你可能会想，上面负责找交点的部分都没找到，为什么不可以返还null嘞？</span><br><span class="line">        //关键在于上面找焦点的部分工作的前提条件是第一个点，不是交点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希集合"><a href="#哈希集合" class="headerlink" title="哈希集合"></a>哈希集合</h3><p>施工中</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除链表的倒数第N个节点</title>
      <link href="/posts/52002.html"/>
      <url>/posts/52002.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="删除倒数第N个结点"><a href="#删除倒数第N个结点" class="headerlink" title="删除倒数第N个结点"></a>删除倒数第N个结点</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/"></a></p><p><img src="/posts/52002/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102202508.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="一般"><a href="#一般" class="headerlink" title="一般"></a>一般</h3><p>先确定链表长度，然后根据n的值在从前往后遍历，只不过这样就进行了两次扫描</p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><blockquote><p>&#96;&#96;</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummyhead = new ListNode();</span><br><span class="line">        dummyhead.next = head;</span><br><span class="line">        ListNode fast = dummyhead.next;</span><br><span class="line">        ListNode slow = dummyhead;</span><br><span class="line">        for (int i = 0; i &lt; n; i++ ) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(fast != null) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        return dummyhead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义两个指针一个fast，一个slow</p><p><img src="/posts/52002/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102203334.png"></p><p>先让快指针走n+1步</p><p><img src="/posts/52002/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102203342.png"></p><p>再让两个指针一起走直到快指针为null</p><p><img src="/posts/52002/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102203349.png"></p><p>这时满指针就是倒数第n个元素的前驱，进行标准操作即可</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>施工中ing</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两两交换链表中的结点</title>
      <link href="/posts/45642.html"/>
      <url>/posts/45642.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/"></a></p><p><img src="/posts/45642/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102190556.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>为啥我要先写递归法嘞，因为我自己最先写的就是递归法，渐渐发现递归的一些规律</p><p>首先现在发现的递归有两种，循环到最后一次就结束，还有一种是循环到最后一次后还要再往回走一遍，其实应该是都要往回走一遍的，毕竟函数进栈之后还要出栈对吧，但是我说的最后一次就结束是指往回的过程中没有操作，只是出栈，但是第二种的主要操作是在出栈的时候再执行，两种的区别是，一种在压栈的时候进行主要操作，一种是在出栈的时候进行主要操作，我写的是第一种</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">    //特判空链表和只有一个元素的链表</span><br><span class="line">        if (head == null || head.next == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建虚拟头节点，使用虚拟头节点对链表进行操作</span><br><span class="line">        ListNode dummyhead = new ListNode();</span><br><span class="line">        dummyhead.next = head;</span><br><span class="line">        swap(dummyhead, head);</span><br><span class="line">        return dummyhead.next;</span><br><span class="line">        //不能返回head，head已经被修改返回虚拟头节点的下一个节点也就是链表第一个节点</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ListNode swap(ListNode pre, ListNode now) &#123;</span><br><span class="line">    //如果当前节点为空，或者当前节点的下一个节点为空，返回前一个节点</span><br><span class="line">    //当前节点的下一个节点为空则说明该链表为奇数链表</span><br><span class="line">        if (now == null || now.next == null) &#123;</span><br><span class="line">            return pre;</span><br><span class="line">        &#125;</span><br><span class="line">        //关键，防止断链</span><br><span class="line">        ListNode temp = now.next.next;</span><br><span class="line">        //保证pre节点连接正确</span><br><span class="line">        ListNode cur = pre;</span><br><span class="line">        pre = pre.next.next;</span><br><span class="line">        pre.next = now;</span><br><span class="line">        now.next = temp;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        return swap(now, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉我的递归更像是循环，把整个操作看成许多个小节，每个小节的操作相同，关键是控制进入下一个循环的变量是啥谁是pre，谁是now。循环到最后一个小结修改完成，出栈<img src="/posts/45642/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102193133.png"></p><p>这个就是明显的主要操作在出栈时候的</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">//这里的head是头节点不是头指针</span><br><span class="line">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">    //特判空链表和单元素链表</span><br><span class="line">        if (head == null || head.next == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        //用new节点来记录当前节点处理完之后要连接的结点。</span><br><span class="line">        ListNode newNode = swapPairs(next.next);</span><br><span class="line">        next.next = head;</span><br><span class="line">        head.next = newNode;</span><br><span class="line"></span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/45642/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102201650.png"></p><p>用new来记录当前节点要连接的节点</p><h3 id="指针法"><a href="#指针法" class="headerlink" title="指针法"></a>指针法</h3><p>&#96;&#96;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虚拟头结点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummyNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (prev.next != <span class="literal">null</span> &amp;&amp; prev.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next.next; <span class="comment">// 缓存 next</span></span><br><span class="line">      prev.next = head.next;          <span class="comment">// 将 prev 的 next 改为 head 的 next</span></span><br><span class="line">      head.next.next = head;          <span class="comment">// 将 head.next(prev.next) 的next，指向 head</span></span><br><span class="line">      head.next = temp;               <span class="comment">// 将head 的 next 接上缓存的temp</span></span><br><span class="line">      prev = head;                    <span class="comment">// 步进1位</span></span><br><span class="line">      head = head.next;               <span class="comment">// 步进1位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/45642/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102202128.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻转链表</title>
      <link href="/posts/9249.html"/>
      <url>/posts/9249.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h1><p><a href="https://leetcode.cn/problems/reverse-linked-list/"></a></p><p><img src="/posts/9249/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102175824.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="指针法"><a href="#指针法" class="headerlink" title="指针法"></a>指针法</h3><p>​这个题目总体来说还是不难的，使用双指针法进行操作，但是不知道其他语言是咋样的，Java要使用三指针，要不然会断链。</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        if (head == null) &#123;//特判头节点为空的情况</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        ListNode now = head;</span><br><span class="line">        ListNode pre = null;</span><br><span class="line">        while (next != null) &#123;</span><br><span class="line">            now.next = pre;</span><br><span class="line">            pre = now;</span><br><span class="line">            now = next;</span><br><span class="line">            next = next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //循环完之后的情况见下图，还要对now进行一次操作之后再返回，因为执行循环结束之后now是独立的</span><br><span class="line">        now.next = pre;</span><br><span class="line">        head = now;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/9249/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102180554.png"></p><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>第一种递归，分小段进行类似循环的处理，在没有到最后一个的时候继续压栈，到最后一个的时候全部释放，链表在压栈的时候就已经修改完毕</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        return reverse(null, head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ListNode reverse(ListNode now, ListNode next) &#123;</span><br><span class="line">        if(next == null) &#123;</span><br><span class="line">            return now;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode temp = next.next;</span><br><span class="line">        next.next = now;</span><br><span class="line">        return reverse(next, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/9249/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102182630.png"></p><p>第二种递归</p><p>这种递归的方式给我的感觉像是子弹上膛，我们先从前往后把子弹一颗一颗的塞到弹匣里，塞满之后再从后往前的一颗一颗的对子弹进行操作，直到打完所有弹匣，</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        //递归终止条件是当前为空，或者下一个节点为空</span><br><span class="line">        //如果链表为空或者链表只有一个元素不会递归</span><br><span class="line">        if(head==null || head.next==null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = reverseList(head.next);</span><br><span class="line">        //cur永远是最后一个节点</span><br><span class="line">        //一次递归就对一个节点进行操作</span><br><span class="line">        //跟上一个递归解法不同的是，上个递归在到最后一个元素时链表便已经完成修改</span><br><span class="line">        //让当前节点下一个节点的下一个节点为当前节点，当前节点的下一个节点改为空节点</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = null;</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/9249/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102184955.png"></p><p><img src="/posts/9249/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230102190324.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>707.设计链表</title>
      <link href="/posts/61137.html"/>
      <url>/posts/61137.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h1><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>[设计链表](<a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表 - 力扣（LeetCode）</a>)</p><p><img src="/posts/61137/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221222193145.jpg"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>经常用到的操作，<strong>设置中间变量</strong>，<strong>找前驱</strong>，<strong>标准操作</strong>（使用虚拟节点也是为了方便找前驱）</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//节点类</span><br><span class="line">class ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode()&#123;&#125;</span><br><span class="line">    ListNode(int val)&#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//单向链表</span><br><span class="line">//链表元素下标为[0-index)</span><br><span class="line">//链表大小为（0-index]  [1-index]</span><br><span class="line">class MyLinkedList &#123;</span><br><span class="line">    int size;</span><br><span class="line">    ListNode head;</span><br><span class="line">//构造方法</span><br><span class="line">    public MyLinkedList() &#123;</span><br><span class="line">        int size = 0;</span><br><span class="line">        head = new ListNode();</span><br><span class="line">    &#125;</span><br><span class="line">//获取节点元素</span><br><span class="line">    public int get(int index) &#123;//获取数值</span><br><span class="line">    //判断下标是否合法</span><br><span class="line">        if(index &lt; 0 || index &gt;= size)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        //设置中间变量</span><br><span class="line">            ListNode cur = head;</span><br><span class="line">            //寻找该节点</span><br><span class="line">//头节点——头指针，指向的下一个元素才是第一个节点，我们要找下标为0的节点其实就是头节点的下一个节点</span><br><span class="line">//时刻记住我们是在对头节点进行操作</span><br><span class="line">//这里的head节点相当于dummyhead,如果要查看n位置的节点，就移动n+1次</span><br><span class="line">            for(int i = 0; i &lt;= index; i++)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            return cur.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addAtHead(int val) &#123;//头插</span><br><span class="line">        addAtIndex(0,val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addAtTail(int val) &#123;//尾插</span><br><span class="line">        addAtIndex(size,val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addAtIndex(int index, int val) &#123;//根据下标插入</span><br><span class="line">        if(index &gt; size)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(index &lt; 0)&#123;//我觉得这里可以return</span><br><span class="line">            index = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        //只要下标合法，size++,所以链表大小为（0-index]  [1-index]</span><br><span class="line">        size++;</span><br><span class="line">        ListNode pred = head;</span><br><span class="line">//找前驱</span><br><span class="line">//这里的head节点相当于虚拟头节点，在第n个位置插入就移动n次</span><br><span class="line">        for(int i = 0; i &lt; index; i++)&#123;//细节，只要找到前一个就可以</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //需要插入的节点</span><br><span class="line">        ListNode toAdd = new ListNode(val);</span><br><span class="line">        //对前驱进行标准操作</span><br><span class="line">        toAdd.next = pred.next;</span><br><span class="line">        pred.next = toAdd;</span><br><span class="line">    &#125;</span><br><span class="line">//删除某位置的节点</span><br><span class="line">    public void deleteAtIndex(int index) &#123;</span><br><span class="line">    //判断是否合法</span><br><span class="line">        if(index &lt; 0 || index &gt;= size)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果合法，链表大小--；</span><br><span class="line">        size--;</span><br><span class="line">        //如果为0，则让头节点向前移动一位</span><br><span class="line">        //如果是循环链表，直接让头节点向前移动估计不行</span><br><span class="line">        if(index == 0)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果是头节点之外的其他节点，找前驱，进行标准操作</span><br><span class="line">        ListNode pred = head;</span><br><span class="line">        for(int i = 0; i &lt; index; i++)&#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pred.next = pred.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//节点类</span><br><span class="line">class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next,prev;//下一个上一个</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//双向链表（双向链表！=循环链表）</span><br><span class="line">class MyLinkedList &#123;</span><br><span class="line">    ListNode head,tail;//前驱，后继，相当于dummyhead</span><br><span class="line">    int size;//链表长度</span><br><span class="line"></span><br><span class="line">//构造方法</span><br><span class="line">    public MyLinkedList() &#123;</span><br><span class="line">        this.size = 0;</span><br><span class="line">        this.head = new ListNode(0);</span><br><span class="line">        this.tail = new ListNode(0);</span><br><span class="line">        //这一步非常关键，否则在加入头结点的操作中会出现null.next的错误！！！</span><br><span class="line">        //让头的后继，尾的前驱不为空，让两个节点相连形成一个双向链</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">//获取某位置的元素</span><br><span class="line">    public int get(int index) &#123;</span><br><span class="line">    //不合法返回-1</span><br><span class="line">        if(index &lt; 0 || index &gt;= size) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    //设置中间变量，对中间变量进行操作，毕竟头节点不能变对吧</span><br><span class="line">        ListNode cur = this.head;</span><br><span class="line">    //优化，如果离头近就从头往前找，如果离尾近就从头往后找</span><br><span class="line">        if (index &gt;= size / 2) &#123;</span><br><span class="line">            cur = tail;</span><br><span class="line">            for (int i = 0; i &lt; size - index; i++) &#123;</span><br><span class="line">                cur = cur.prev;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt;= index; i++) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">//头插法</span><br><span class="line">    public void addAtHead(int val) &#123;</span><br><span class="line">        addAtIndex(0,val);</span><br><span class="line">    &#125;</span><br><span class="line">//尾插法</span><br><span class="line">    public void addAtTail(int val) &#123;</span><br><span class="line">        addAtIndex(size,val);</span><br><span class="line">    &#125;</span><br><span class="line">//在对应位置插入节点</span><br><span class="line">    public void addAtIndex(int index, int val) &#123;</span><br><span class="line">    //判断下标是否合法</span><br><span class="line">        if (index &gt; size) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (index &lt; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    //如果下标合法</span><br><span class="line">        size++;</span><br><span class="line">    //设置中间变量</span><br><span class="line">        ListNode pre = this.head;</span><br><span class="line">    //寻找index的前驱，第一个节点的前驱就是头节点</span><br><span class="line">        for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">    //需要插入的节点</span><br><span class="line">        ListNode node = new ListNode(val);</span><br><span class="line">    //标准操作</span><br><span class="line">    //先让当前节点与两边节点产生联系</span><br><span class="line">        node.prev = pre;</span><br><span class="line">        node.next = pre.next;</span><br><span class="line">    //前驱下一个节点的前驱设置为当前节点</span><br><span class="line">        pre.next.prev = node;</span><br><span class="line">    //前驱的下一个节点设置为当前节点</span><br><span class="line">        pre.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">//删除指定位置的元素</span><br><span class="line">    public void deleteAtIndex(int index) &#123;</span><br><span class="line">    //判断下标是否合法</span><br><span class="line">        if (index &lt; 0 || index &gt;= size) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果下标合法</span><br><span class="line">        size--;</span><br><span class="line">        //设置中间变量</span><br><span class="line">        ListNode pre = this.head;</span><br><span class="line">        //寻找该位置前驱</span><br><span class="line">        for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">            pre =pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //标准操作</span><br><span class="line">        pre.next.next.prev = pre;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="line"> * MyLinkedList obj = new MyLinkedList();</span><br><span class="line"> * int param_1 = obj.get(index);</span><br><span class="line"> * obj.addAtHead(val);</span><br><span class="line"> * obj.addAtTail(val);</span><br><span class="line"> * obj.addAtIndex(index,val);</span><br><span class="line"> * obj.deleteAtIndex(index);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>收获还是挺大，事实再次证明只有真正动手实操才能真正掌握一门技术，光懂原理不实操是完全不行的</p><p>在对链表的操作中有很多都要涉及到对范围的判断，所以以后统一链表长度为[1-index]，链表元素的下标为[0-index)</p><p>重点理解，头指针跟头节点的区别，因为Java没有指针，只有引用数据类型，而且head还是用节点类进行创建的，但head并不是头节点，里面是没有数据的，他的的下一个节点才是头节点，而head相当于dummyhead或者头指针</p><p>而且我们的操作几乎都是建立在头指针上的，所以用了许多创建中间变量的方法保证头指针始终指向头节点</p><p>双向链表不等于循环链表，只要一直保证头指针指向第一个节点，尾指针指向最后一个节点就行，关于查找的优化操作需要注意范围的限制</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>203.移除链表元素</title>
      <link href="/posts/10614.html"/>
      <url>/posts/10614.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/posts/10614/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221222175350.png"></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeElements(ListNode head, int val) &#123;</span><br><span class="line">        ListNode mid = new ListNode();</span><br><span class="line">        if(head == null)&#123;//似乎多余？？？</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        while(head.val == val &amp;&amp; head != null)&#123;</span><br><span class="line">            head = head.next;//转移头节点</span><br><span class="line">            if(head == null)&#123;</span><br><span class="line">                return head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = head;</span><br><span class="line">        while(mid.next != null)&#123;</span><br><span class="line">            if(mid.next.val == val)&#123;</span><br><span class="line">                mid.next = mid.next.next;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = mid.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缝缝补补做出</p><p>关键在第一个节点的操作上，因为我们删除一个节点是对这个节点的上一个节点进行操作</p><p>ps</p><p>1.如果节点头为空，直接返回</p><p>2.在第一节点特判时，如果为空，直接返回</p><p>3.创建中间变量对中间变量进行操作保证头节点一直是头节点</p><p>4.中间变量只是引用数据类型，会改变实际的值，但是head不变就可以</p><h2 id="大佬的思路——虚拟头节点"><a href="#大佬的思路——虚拟头节点" class="headerlink" title="大佬的思路——虚拟头节点"></a>大佬的思路——虚拟头节点</h2><p><strong>优势</strong>：在一般操作的情况下，我们删除或者增添节点的时候对头节点和其他节点的操作不同，如果使用头节点，那么我们可以使增删头节点的方式与其他节点相同，起到统一操作的作用</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeElements(ListNode head, int val) &#123;</span><br><span class="line">    //重要操作</span><br><span class="line">        ListNode dummyHead = new ListNode();</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode cur = dummyHead;</span><br><span class="line">        while(cur.next != null)&#123;</span><br><span class="line">            if(cur.next.val == val)&#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps:</p><p>不能返回原来的头节点，因为可能已经被删除（这里应该具体研究一下），<strong>返回cur.next</strong></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>让所有值不等于val的节点连接成一个新的节点</p><p>有点考逻辑，但是如果用一句话来形容的话——我来组成下一个节点，感觉像拼火车？？？</p><p>这个程序给我的感觉是先全部展开，再依次收拢</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeElements(ListNode head, int val) &#123;</span><br><span class="line">        if(head==null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next=removeElements(head.next,val);//</span><br><span class="line">        if(head.val==val)&#123;//特判头节点，返回的值一定为head,只不过主体部分已经修改完毕，不对</span><br><span class="line">        //判断当前节点的值是否等于val，如果是返回下一个节点，否则返回当前节点</span><br><span class="line">            return head.next;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/posts/54862.html"/>
      <url>/posts/54862.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="线性表的顺序储存结构"><a href="#线性表的顺序储存结构" class="headerlink" title="线性表的顺序储存结构"></a>线性表的顺序储存结构</h2><h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><p>​<img src="/posts/54862/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221222165127.png"></p><p>元素之间有序，不存在空位，第一个元素无前驱，最后一个元素无后继，其他每个元素有且只有一个前驱和后记，并且有限</p><h3 id="关键操作"><a href="#关键操作" class="headerlink" title="关键操作"></a>关键操作</h3><p><strong>赋值&amp;&amp;扩容</strong></p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void InitList(int data) &#123;//给线性表从0开始依次赋值</span><br><span class="line">    if(size==L.length)&#123;//如果满容，进行扩容</span><br><span class="line">        this.L= Arrays.copyOf(this.L,this.L.length*2);</span><br><span class="line">    &#125;</span><br><span class="line">    L[size++]=data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入元素，删除元素</strong></p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void remove(int key) &#123;//删除链表中的某个值</span><br><span class="line">    int index=this.search(key);</span><br><span class="line">    if(index==-1)&#123;</span><br><span class="line">        System.out.println(&quot;没找到要删除的数字&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=index;i&lt;size-1;i++)&#123;//将pos之后的元素集体左移</span><br><span class="line">        this.L[i]=this.L[i+1];</span><br><span class="line">    &#125;</span><br><span class="line">    this.size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void add(int pos, int data) &#123;//插入元素</span><br><span class="line">    if(pos&lt;0||pos&gt;=size)&#123;//如果插入坐标不在线性表坐标之内，抛出异常</span><br><span class="line">        System.out.println(&quot;坐标不合法&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        for(int i=size-1;i&gt;pos;i--)&#123;//坐标合法，将pos之后的（包括pos）元素右移，然后给pos位置的元素赋值</span><br><span class="line">            L[i]=L[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        L[pos]=data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优</strong></p><p>无需为元素之间的逻辑关系额外增加储存空间</p><p>科快速存取任意位置的表中元素</p><p><strong>缺</strong></p><p>插入和删除操作需要移动大量元素</p><p>容易造成储存空间的”碎片“</p><h3 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package List.shunxulist;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class MyArrylist implements SeqList&#123;</span><br><span class="line">    public int L[];</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    public MyArrylist()&#123;//构造函数，先构造一个长度为10的数组，如果长度不够，可以扩容</span><br><span class="line">        this.L=new int[10];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;//打印线性表中的所有元素</span><br><span class="line">        for(int i=0;i&lt;size;i++)&#123;</span><br><span class="line">            System.out.print(L[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void InitList(int data) &#123;//给线性表从0开始依次赋值</span><br><span class="line">        if(size==L.length)&#123;//如果满容，进行扩容</span><br><span class="line">            this.L= Arrays.copyOf(this.L,this.L.length*2);</span><br><span class="line">        &#125;</span><br><span class="line">        L[size++]=data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void add(int pos, int data) &#123;//插入元素</span><br><span class="line">        if(pos&lt;0||pos&gt;=size)&#123;//如果插入坐标不在线性表坐标之内，抛出异常</span><br><span class="line">            System.out.println(&quot;坐标不合法&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            for(int i=size-1;i&gt;pos;i--)&#123;//坐标合法，将pos之后的（包括pos）元素右移，然后给pos位置的元素赋值</span><br><span class="line">                L[i]=L[i-1];</span><br><span class="line">            &#125;</span><br><span class="line">            L[pos]=data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean contains(int toFind) &#123;//查找是否含有某个元素</span><br><span class="line">        for(int i=0;i&lt;this.size;i++)&#123;</span><br><span class="line">            if(toFind==L[i])&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int search(int toFind) &#123;//查找某个对应元素的坐标</span><br><span class="line">        for(int i=0;i&lt;this.size;i++)&#123;</span><br><span class="line">            if(toFind==L[i])&#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getPos(int pos) &#123;//查找某个坐标上的值</span><br><span class="line">        if(pos&lt;0||pos&gt;=size)&#123;</span><br><span class="line">            System.out.println(&quot;数组下标错误&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return this.L[pos];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stePos(int pos, int value) &#123;//将某个位置的值替换为某个值</span><br><span class="line">        if(pos&lt;0||pos&gt;=size)&#123;</span><br><span class="line">            System.out.println(&quot;数组下标错误&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        this.L[pos] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void remove(int key) &#123;//删除链表中的某个值</span><br><span class="line">        int index=this.search(key);</span><br><span class="line">        if(index==-1)&#123;</span><br><span class="line">            System.out.println(&quot;没找到要删除的数字&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=index;i&lt;size-1;i++)&#123;//将pos之后的元素集体左移</span><br><span class="line">            this.L[i]=this.L[i+1];</span><br><span class="line">        &#125;</span><br><span class="line">        this.size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int size() &#123;//获取链表长度</span><br><span class="line">        return this.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void clear() &#123;//重置链表</span><br><span class="line">        this.size=0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性表的链式储存结构"><a href="#线性表的链式储存结构" class="headerlink" title="线性表的链式储存结构"></a>线性表的链式储存结构</h2><p><img src="/posts/54862/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221222170215.png"></p><p>在链式储存中，每个元素除了储存该元素本身的信息之外，还需储存下一个元素的地址</p><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><p>头指针：链表中第一个节点的存储位置</p><p>头结点：单链表的第一个节点前附设一个结点，可不储存任何信息，头节点的指针域指向第一个节点的指针</p><p>ps:</p><p>1.头指针</p><p>头指针是指向链表的第一个节点的指针，若链表有头节点，则是指向头节点的指针</p><p>头指针具有表示作用，常用链表的名字作为头指针的名字</p><p>无论链表是否为空，头指针均不为空，头指针是链表的必要元素</p><p>2.头节点</p><p>存在头节点时，对第一元素节点前插入节点和删除第一节点与其他操作就统一了</p><p>头节点不一定是链表的必要元素</p><h3 id="关键操作-1"><a href="#关键操作-1" class="headerlink" title="关键操作"></a>关键操作</h3><p>&#96;&#96;</p><p>添加</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//头插法</span><br><span class="line">public void addFirst(int data)&#123;</span><br><span class="line">    Node node = new Node(data);//创建新节点</span><br><span class="line">    //注意理解我们这里是在什么对象的角度去进行操作的</span><br><span class="line">    if(this.head==null)&#123;//如果第一个节点是空的，复制给第一个节点</span><br><span class="line">        this.head = node;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //如果第一个节点不空，执行标准化操作</span><br><span class="line">        node.next = this.head;//新节点的指针域指向旧节点</span><br><span class="line">        this.head = node;//现在我们是下一个操作对象的新节点</span><br><span class="line">    &#125;</span><br><span class="line">    //跟C的思路好像有点不同</span><br><span class="line">    //开始回忆，C是创建新节点，把新节点的指针域赋值为旧节点的指针域（换屁股），然后把就节点的指针域赋值为当前节点（头插进屁股里）</span><br><span class="line">    this.usedSize++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>//为了节约时间直接把尾插法写在这里//这个尾插法不存粹，不够快，好处是可以跟这个头插法的代码一起用//原理是从第一个遍历到最后一个，然后再插入，比起存粹的尾插速度要慢很多，在数据大的时候public void addLast(int data)&#123;    //创建新节点    Node node = new Node(data);    if(this.head == null)&#123;        this.head = node;    &#125;else&#123;        Node cur = this.head;        while(cur.next!=null)&#123;            cur = cur.next;        &#125;        cur.next = node;    &#125;    this.usedSize++;&#125;`</code></pre><p>&#96;&#96;</p><p>插入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void addLast(int data)&#123;</span><br><span class="line">    //创建新节点</span><br><span class="line">    Node node = new Node(data);</span><br><span class="line">    if(this.head == null)&#123;</span><br><span class="line">        this.head = node;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        Node cur = this.head;</span><br><span class="line">        while(cur.next!=null)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    this.usedSize++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package List.lianshilist;</span><br><span class="line"></span><br><span class="line">public class Node &#123;</span><br><span class="line">    public int value;//储存数据</span><br><span class="line">    public Node next;//-&gt;next，储存下一个节点的地址</span><br><span class="line"></span><br><span class="line">    public Node (int value)&#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package List.lianshilist;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* 这个对象只用创建一次，为链表中的第一个元素，头指针为这个对象的对象名</span><br><span class="line">* 之后不断往里面添加节点类就可以，头节点不变（头插法的话）</span><br><span class="line">* 所以获取其他值很难，只能从第一个开始往后循环去找，时间复杂度为O（n）</span><br><span class="line">* 但是插入跟删除异常方便，而且不用担心内存问题</span><br><span class="line">* */</span><br><span class="line"></span><br><span class="line">import java.nio.channels.Pipe;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedList &#123;</span><br><span class="line">    public Node head;//head永远是第一个</span><br><span class="line">    public int usedSize;</span><br><span class="line"></span><br><span class="line">    //头插法</span><br><span class="line">    public void addFirst(int data)&#123;</span><br><span class="line">        Node node = new Node(data);//创建新节点</span><br><span class="line">        //注意理解我们这里是在什么对象的角度去进行操作的</span><br><span class="line">        if(this.head==null)&#123;//如果第一个节点是空的，复制给第一个节点</span><br><span class="line">            this.head = node;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //如果第一个节点不空，执行标准化操作</span><br><span class="line">            node.next = this.head;//新节点的指针域指向旧节点</span><br><span class="line">            this.head = node;//现在我们是下一个操作对象的新节点</span><br><span class="line">        &#125;</span><br><span class="line">        //跟C的思路好像有点不同</span><br><span class="line">        //开始回忆，C是创建新节点，把新节点的指针域赋值为旧节点的指针域（换屁股），然后把就节点的指针域赋值为当前节点（头插进屁股里）</span><br><span class="line">        this.usedSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //为了节约时间直接把尾插法写在这里</span><br><span class="line">    //这个尾插法不存粹，不够快，好处是可以跟这个头插法的代码一起用</span><br><span class="line">    //原理是从第一个遍历到最后一个，然后再插入，比起存粹的尾插速度要慢很多，在数据大的时候</span><br><span class="line">    public void addLast(int data)&#123;</span><br><span class="line">        //创建新节点</span><br><span class="line">        Node node = new Node(data);</span><br><span class="line">        if(this.head == null)&#123;</span><br><span class="line">            this.head = node;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            Node cur = this.head;</span><br><span class="line">            while(cur.next!=null)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        this.usedSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //打印单链表</span><br><span class="line">    public void myToString()&#123;</span><br><span class="line">        Node cur = this.head;//从第一个开始遍历</span><br><span class="line">        while(cur != null)&#123;</span><br><span class="line">            System.out.print(cur.value+&quot; &quot;);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //单链表的查找</span><br><span class="line">    public boolean contains(int key)&#123;</span><br><span class="line">        Node cur = this.head;</span><br><span class="line">        while(cur!=null)&#123;</span><br><span class="line">            if(cur.value == key)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取单链表的长度</span><br><span class="line">    public int length()&#123;</span><br><span class="line">        return this.usedSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获得插入位置的前区节点</span><br><span class="line">    //为什么要获取前驱节点，因为我们只有通过前驱节点的指针域才能访问我们要的那个节点</span><br><span class="line">    public Node getIndex(int pos)&#123;</span><br><span class="line">        Node cur = this.head;</span><br><span class="line">        int index = 0;</span><br><span class="line">        while(index++ != pos-1)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //插入节点任意位置插入，第一个数据节点为0号下标</span><br><span class="line">    public void insert(int pos,int data)&#123;</span><br><span class="line">        if(pos&lt;0||pos&gt;this.usedSize)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;插入位置不合法&quot;);</span><br><span class="line">            //这是一条我没学过的代码，异常抛出？为啥不用return勒</span><br><span class="line">            //猜测，如果return，那么会接着执行主程序的吓一条代码，这里是直接结束程序</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(pos == 0)&#123;</span><br><span class="line">            addFirst(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(pos == this.usedSize)&#123;</span><br><span class="line">            addLast(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node node = new Node(data);</span><br><span class="line">        Node prev = getIndex(pos);//获得插入位置的前驱节点</span><br><span class="line">        node.next = prev.next;</span><br><span class="line">        prev.next = node;</span><br><span class="line">        this.usedSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //清空链表</span><br><span class="line">    public void clear()&#123;</span><br><span class="line">        this.head = null;</span><br><span class="line">        //当head设置为null后，之后的节点对象都变成未被引用的对象，垃圾回收器会自动回收这些未被引用的对象</span><br><span class="line">        //C要创建两个指针，一个一个的释放内存一个储存当前位置，一个储存下一位置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>单链表机构在有频繁插入跟删除元素的条件下表现非常优秀，时间复杂度仅为O(1)，但查找比较费时，而且用了多余的储存空间去储存了元素之间的逻辑结构，但是不用担心储存空间的分配，元素个数不被限制</p><p>需要理解的是，<strong>单链表结构的操作对象是当前的元素</strong>，类比和尚滚佛珠，还有插入删除操作的顺序一定不可以错</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>剪刀石头布</title>
      <link href="/posts/18553.html"/>
      <url>/posts/18553.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剪刀石头布"><a href="#剪刀石头布" class="headerlink" title="剪刀石头布"></a>剪刀石头布</h1><p>​跟我这种垃圾想出来的代码完全不一样，我的思路是用循环链表存储人类输入的数据然后根据根据人类前几次输入的结果去进行输出，如果前面出的布多，就增加出现剪刀的可能性，如果出现的石头多，就增加出现布的可能性</p><p>​不得不说，我的可能太低级了，只不过这确实是我的第一思路，但是老师的思路显然也有缺陷，太过死板，如果知道背后逻辑肯定可以100%取胜，不过对不知道的人的赢面还是不错的，<strong>他的代码，是通过判断人类下一步更可能出什么</strong>，就是人出了剪刀之后更可能会出什么，人出了石头之后更可能会出什么，人出了布之后更可能会出什么，虽然我们只需要统计数据计算然后让计算机去执行计算就可以，我们可以用九个变量去储存计算机的逻辑部分，分别统计人出拳之后再出拳的概率即可，但是老师的代码在数据结构的安排上显然“更有意思”</p><p>​<img src="/posts/18553/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221222005836.jpg"></p><p>​但是在知道数据库时，人在不出错并且知道底层逻辑的情况下依然可以完胜计算机（没错，就是我）</p><p>​我想，如果让我改进这个算法我会保留随机性，如果出剪刀之后出石头的可能性大，就增加出布的可能性，把二维数组换成由结构体组成的二维数组，一个储存次数（int），一个储存可能性（double），需要解决的问题是，如何根据可能性去生成计算机要出的结果（这个属于实现方面比较简单），还有一个是怎么去计算每次人出拳后计算机出拳的可能性，这个是数学问题，不太好想（人出拳的可能性是多少，那我下一局出布的可能性是多少？人出拳的概率对我下一回合出拳胜率的影响，似乎涉及到统计学跟概率学。。。。。。cao）</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package computer;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class text &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        int memory[][] = new int[3][3];</span><br><span class="line">        int counter=0;//记录猜拳的回合数</span><br><span class="line">        int human;//记录人类本次出拳</span><br><span class="line">        int computer;//记录计算机出拳</span><br><span class="line">        int id;//记录人类上次出拳后，出拳次数最多的是那种</span><br><span class="line">        int max;//记录根据id推出的计算机出拳</span><br><span class="line">        int prev=0;//记录人类上一次出拳</span><br><span class="line"></span><br><span class="line">        while(true)&#123;</span><br><span class="line">            counter++;</span><br><span class="line">            System.out.printf(&quot;该你出拳了！请输入:0-石头；1-剪刀；2-布\n&quot;);</span><br><span class="line">            human= sc.nextInt();</span><br><span class="line">            if(human!=0&amp;&amp;human!=1&amp;&amp;human!=2)&#123;</span><br><span class="line">                System.out.println(&quot;输入不合法，请重新输入&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;//输入012以外的数据退出循环</span><br><span class="line">            //此处代码可让学生优化，若非合理输入，用户循环实现合理输入为止</span><br><span class="line">            if(counter&lt;=12) &#123;//前十回合，计算机随机出拳，统计数据</span><br><span class="line">                computer = (int)(Math.random()*3);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                id=0;//我出剪刀的几率高</span><br><span class="line">                if(memory[prev][id]&lt;memory[prev][1])id=1;//我出石头的几率高</span><br><span class="line">                if(memory[prev][id]&lt;memory[prev][2])id=2;//我出布的几率高</span><br><span class="line">                if(id==0)max=2;//出布</span><br><span class="line">                else if(id==1)max=0;//出剪刀</span><br><span class="line">                else max=1;//出石头</span><br><span class="line">                computer=max;</span><br><span class="line">            &#125;</span><br><span class="line">            output(human,computer);//输出出拳信息和胜负信息</span><br><span class="line">            memory[prev][human]++;</span><br><span class="line">            for(int i=0;i&lt;3;i++)&#123;</span><br><span class="line">                for(int j=0;j&lt;3;j++)&#123;</span><br><span class="line">                    System.out.print(memory[i][j]+&quot; &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">            prev=human;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void output(int human,int computer)&#123;</span><br><span class="line">        if(human==computer)&#123;</span><br><span class="line">            System.out.println(&quot;你和计算机本局打平啦！&quot;);</span><br><span class="line">            switch(human)&#123;</span><br><span class="line">                case 0:</span><br><span class="line">                System.out.println(&quot;你和计算机都出了石头！&quot;);break;</span><br><span class="line">                case 1:</span><br><span class="line">                System.out.println(&quot;你和计算机都出了剪刀！&quot;);break;</span><br><span class="line">                case 2:</span><br><span class="line">                System.out.println(&quot;你和计算机都出了布！&quot;);break;</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(human==0)//你出了石头，计算机不是石头</span><br><span class="line">        &#123;</span><br><span class="line">            if(computer==1)</span><br><span class="line">                System.out.printf(&quot;你赢啦!你的出拳是石头，计算机出拳是剪刀！\n&quot;);</span><br><span class="line">            else</span><br><span class="line">                System.out.printf(&quot;计算机赢啦！你的出拳是石头，计算机出拳是布！\n&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(human==1)//你出了剪刀，计算机不是剪刀</span><br><span class="line">        &#123;</span><br><span class="line">            if(computer==2)</span><br><span class="line">                System.out.printf(&quot;你赢啦!你的出拳是剪刀，计算机出拳是布！\n&quot;);</span><br><span class="line">            else</span><br><span class="line">                System.out.printf(&quot;计算机赢啦！你的出拳是剪刀，计算机出拳是石头！\n&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(human==2)//你出了布，计算机不是布</span><br><span class="line">        &#123;</span><br><span class="line">            if(computer==0)</span><br><span class="line">                System.out.printf(&quot;你赢啦!你的出拳是布，计算机出拳是石头！\n&quot;);</span><br><span class="line">            else</span><br><span class="line">                System.out.printf(&quot;计算机赢啦！你的出拳是布，计算机出拳是剪刀！\n&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 有趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/posts/46132.html"/>
      <url>/posts/46132.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式，是一种类型的<strong>设计模式</strong>，是一种<strong>创建型模式</strong>，提供了一种创建对象的方式</p><p>这种模式涉及到一个单一的类，<strong>该类负责创建自己的对象</strong>，同时<strong>确保只有单个对象被创建</strong>，这个类<strong>提供了一种访问其唯一对象的方式</strong>，可以直接访问，<strong>不需要实例化该类的对象</strong></p><p>注意</p><p>单例类只能有一个实例</p><p>单例类必须自己创建自己的唯一实例</p><p>单例类必须给其他所有对象提供这一实例</p><p>要保证一个类仅有一个实例，并提供一个访问它的全局访问点</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><strong>主要解决</strong>：一个全局使用的类频繁的创建与销毁</p><p><strong>何时使用</strong>：当你想控制实例数目，节省系统资源的时候</p><p><strong>主要方法</strong>：判断系统是否已经有这个单例，如果有则返回，如果没有则创建</p><p><strong>关键代码</strong>：构造函数是私有的</p><p><strong>应用实例</strong>：</p><p>一个班级只有一个班主任</p><p>多线程程序操作一个文件的时候会不可避免的出现多个进程或者线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行</p><p>一些设备管理器常常设计为单例模式，比如一个电脑的两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件</p><p><strong>使用场景</strong>：</p><p>要求生产唯一的序列号</p><p>WEB中的技术器，不用每次刷新都在数据库里加一次，先用单例缓存起来</p><p>创建的一个对象需要消耗的资源过多，比如I&#x2F;O与数据库的连接</p><p><strong>优点</strong>：</p><p>内存里只有一个实例，减少内存的开销</p><p>避免对资源的多重占用</p><p>缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们创建一个a类，a类有它的私有构造函数和本身的一个静态实例，a类提供了一个静态方法，供外界获取它的静态实例</p><p>&#96;&#96;&#x2F;&#x2F;创建一个Singleton类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SingleObject &#123;</span><br><span class="line">    //创建 SingleObject 的一个对象</span><br><span class="line">    private static SingleObject instance = new SingleObject();</span><br><span class="line">    //让构造函数为 private，这样该类就不会被实例化</span><br><span class="line">    private SingleObject()&#123;&#125;</span><br><span class="line">    //获取唯一可用的对象</span><br><span class="line">    public static SingleObject getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    public void showMessage()&#123;</span><br><span class="line">        System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SingletonPatternDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //不合法的构造函数</span><br><span class="line">        //编译时错误：构造函数 SingleObject() 是不可见的</span><br><span class="line">        //SingleObject object = new SingleObject();</span><br><span class="line">        //获取唯一可用的对象</span><br><span class="line">        SingleObject object = SingleObject.getInstance();            //显示消息</span><br><span class="line">        object.showMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过类中公有的静态方法调用该类的私有构造函数并返回该类从而达成只生成唯一可用对象的目的，并可通过该对象调用该类中的方法</p><h2 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h2><p>1.懒汉式，线程不安全</p><p><strong>是否lazy初始化</strong>：是</p><p><strong>是否多线程安全</strong>：否</p><p><strong>实现难度</strong>：易</p><p>描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁synchronized所以严格意义上它并不算单例模式</p><p>这种方式lazy loading很明显，不要求多线程安全，在多线程不能正常工作</p><p>实例</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance;//私有静态属性</span><br><span class="line">    private Singleton ()&#123;&#125;//私有构造方法</span><br><span class="line">    public static Singleton getInstance() &#123;//共有静态方法</span><br><span class="line">        if (instance == null) &#123;//如果没有就创建一个对象并返回</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;//返回现有对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.懒汉式，线程安全</p><p><strong>是否lazy初始化</strong>：是</p><p><strong>是否多线程安全</strong>：是</p><p><strong>实现难度</strong>：易</p><p>描述：这种方式具备很好的lazy loading，能够在多线程中很好的工作，但是效率很低，99%情况下不需要同步，优点，第一次调用才初始化，避免内存浪费，缺点，必须加锁synchronized才能保证单例，但是加锁会影响效率，getlnstance()的性能对应用程序不是很关键（该方法使用不太频繁）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance;//静态私有属性</span><br><span class="line">    private Singleton ()&#123;&#125;//私有构造方法</span><br><span class="line">    public static synchronized Singleton getInstance() &#123;//这一行的那个关键字我不懂</span><br><span class="line">        if (instance == null) &#123;//如果没有对象就创建一个并返回</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;//直接返回现有对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.饿汉式</p><p><strong>是否lazy初始化</strong>：否</p><p><strong>是否多线程安全</strong>：是</p><p><strong>实现难度</strong>：易</p><p>描述：这种方式比较常用，但容易产生垃圾对象。</p><p>优点：没有加锁，执行效率会提高。</p><p>缺点：类加载时就初始化，浪费内存</p><p>它基于class loader机制避免了多线程的同步问题，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式种大多时调用getlnstance方法，但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到lazy loading的效果</p><p>实例</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = new Singleton();//加载类是就进行初始化</span><br><span class="line">    private Singleton ()&#123;&#125;//私有构造方法</span><br><span class="line">    public static Singleton getInstance() &#123;静态共有方法，返回创建的对象</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…………………………………………这一段跟后面的一大段看不懂，不抄了，感觉够用了——目前</p><p>4.双检锁&#x2F;双重校验锁（DLC,即double-checked locking）</p><p><strong>JDK 版本：</strong>JDK1.5 起</p><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>较复杂</p><p><strong>描述：</strong>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance() 的性能对应用程序很关键。</p><p>………………………………………</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象工厂模式</title>
      <link href="/posts/56455.html"/>
      <url>/posts/56455.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式，是<strong>围绕一个超级工厂创建其他工厂</strong>，该超级工厂又称为其他工厂的工厂，属于创建型模式</p><p>在抽象工厂模式中，<strong>接口是负责创建一个相关对象的工厂</strong>，不需要显示指定他们的类，每个工厂都能按照工厂模式提供对象</p><p>个人理解：抽象工厂模式可以使用一个工厂创造器根据传递的信息创造出实现了超级工厂的子类工厂，子类工厂再根据传递的信息生成具体的类</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图</strong>：提供一个<strong>创建一系列相关或互相依赖对象的接口，而无需指定他们具体的类</strong></p><p><strong>主要解决</strong>：主要解决接口选择问题</p><p><strong>何时使用</strong>：在一个产品族里面，定义多个产品</p><p><strong>关键代码</strong>：在一个工厂里聚合多个同类产品</p><p><strong>优点</strong>：当一个产品族中的多个对象被设计成一起工作时，他能保证客户端始终只使用同一个产品族中的对象</p><p><strong>缺点</strong>：产品族扩展非常困难，要增加一个系列的某一产品时，既要在抽象的creator中加代码，又要在具体的类里加代码</p><p><img src="/posts/56455/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221220170600.jpg"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>1.为形状创建一个接口</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Shape &#123;</span><br><span class="line">    //为形状创建的接口</span><br><span class="line">    void draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.创建实现接口的实体类</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Circle implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;circle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Square implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;square&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Rectangle implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;retangle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.为颜色创建一个接口</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Color &#123;</span><br><span class="line">    public abstract void fill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.创建实现接口的实体类</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Blue implements Color&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fill() &#123;</span><br><span class="line">        System.out.println(&quot;blue&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Red implements Color &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void fill() &#123;</span><br><span class="line">        System.out.println(&quot;red&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Green implements Color&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void fill() &#123;</span><br><span class="line">        System.out.println(&quot;green&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.为两个颜色和对象创建抽象类来获取工厂</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractFactory &#123;</span><br><span class="line">//其实这里是否抽象无所谓，但是你不希望别人直接创建超级工厂吧，没意义对不对</span><br><span class="line">    //为Color和Shape对象创建抽象类来获取工厂</span><br><span class="line">    public abstract Color getColor(String color);</span><br><span class="line">    public abstract Shape getShape(String shape);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.创建抽象工厂类，急于给定信息生成实体类的对象</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ColorFactory extends AbstractFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Color getColor(String color) &#123;</span><br><span class="line">        if(color == null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if(color.equalsIgnoreCase(&quot;RED&quot;))&#123;</span><br><span class="line">            return new Red();</span><br><span class="line">        &#125; else if(color.equalsIgnoreCase(&quot;GREEN&quot;))&#123;</span><br><span class="line">            return new Green();</span><br><span class="line">        &#125; else if(color.equalsIgnoreCase(&quot;BLUE&quot;))&#123;</span><br><span class="line">            return new Blue();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Shape getShape(String shape) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ShpeFactory extends AbstractFactory&#123;</span><br><span class="line">    //创建扩展超级工厂类的工厂类，基于给定信息生成实体类的对象</span><br><span class="line">    @Override</span><br><span class="line">    public Color getColor(String color) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Shape getShape(String shape) &#123;</span><br><span class="line">        if(shape == null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;if(shape.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123;</span><br><span class="line">            return new Circle();</span><br><span class="line">        &#125; else if(shape.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123;</span><br><span class="line">            return new Rectangle();</span><br><span class="line">        &#125; else if(shape.equalsIgnoreCase(&quot;SQUARE&quot;))&#123;</span><br><span class="line">            return new Square();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.创建一个工厂创造器&#x2F;生成器类，通过传递形状或颜色信息来获取工厂</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FactoryProducer &#123;</span><br><span class="line">    //根据传递的信息去生产超级工厂的子类</span><br><span class="line">    public static AbstractFactory getFactory(String choice)&#123;</span><br><span class="line">        if(choice.equalsIgnoreCase(&quot;SHAPE&quot;))&#123;</span><br><span class="line">            return new ShpeFactory();</span><br><span class="line">        &#125; else if(choice.equalsIgnoreCase(&quot;COLOR&quot;))&#123;</span><br><span class="line">            return new ColorFactory();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8.使用工厂创造器来获取抽象工厂，通过传递类型信息来获取实体类的对象</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class text &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //获取形状工厂</span><br><span class="line">        AbstractFactory shapeFactory = FactoryProducer.getFactory(&quot;SHAPE&quot;);</span><br><span class="line">        //超级工厂类型可以接收所有实现他的子类，这里使用FactoryProducer，根据传递的信息返回实现了超级工厂的子类，用超级工厂接收由工厂制造器返回的子类工厂</span><br><span class="line">        //获取形状为 Circle 的对象</span><br><span class="line">        Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);</span><br><span class="line">//传递信息给子类工厂，获取相应对象</span><br><span class="line">        //调用 Circle 的 draw 方法</span><br><span class="line">        shape1.draw();</span><br><span class="line"></span><br><span class="line">        //获取形状为 Rectangle 的对象</span><br><span class="line">        Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);</span><br><span class="line"></span><br><span class="line">        //调用 Rectangle 的 draw 方法</span><br><span class="line">        shape2.draw();</span><br><span class="line"></span><br><span class="line">        //获取形状为 Square 的对象</span><br><span class="line">        Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);</span><br><span class="line"></span><br><span class="line">        //调用 Square 的 draw 方法</span><br><span class="line">        shape3.draw();</span><br><span class="line"></span><br><span class="line">        //获取颜色工厂</span><br><span class="line">        AbstractFactory colorFactory = FactoryProducer.getFactory(&quot;COLOR&quot;);</span><br><span class="line"></span><br><span class="line">        //获取颜色为 Red 的对象</span><br><span class="line">        Color color1 = colorFactory.getColor(&quot;RED&quot;);</span><br><span class="line"></span><br><span class="line">        //调用 Red 的 fill 方法</span><br><span class="line">        color1.fill();</span><br><span class="line"></span><br><span class="line">        //获取颜色为 Green 的对象</span><br><span class="line">        Color color2 = colorFactory.getColor(&quot;GREEN&quot;);</span><br><span class="line"></span><br><span class="line">        //调用 Green 的 fill 方法</span><br><span class="line">        color2.fill();</span><br><span class="line"></span><br><span class="line">        //获取颜色为 Blue 的对象</span><br><span class="line">        Color color3 = colorFactory.getColor(&quot;BLUE&quot;);</span><br><span class="line"></span><br><span class="line">        //调用 Blue 的 fill 方法</span><br><span class="line">        color3.fill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9.输出结果</p><p><img src="/posts/56455/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221220170447.jpg"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>光看还是不行，要自己实际操作才能掌握其中细节</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/posts/6013.html"/>
      <url>/posts/6013.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式，属于创建型模式，提供了一种创建对象的方式</p><p>在工厂模式中，我们在创建对象是不会对客户端暴露创建模式逻辑，并且通过<strong>使用一个共同接口来指向新创建的对象</strong></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图</strong>：定义一个创建对象的接口，<strong>让其子类自己决定实例化哪一个工厂类</strong>，工厂模式使其创建过程延迟到子类进行</p><p><strong>主要解决</strong>：接口的选择问题</p><p><strong>如何解决</strong>：让其子类实现工厂接口，返回的也是一个抽象的产品</p><p><strong>关键代码</strong>：创建过程在其子类执行</p><p><strong>优点</strong>：1.知道名字就可以创建对象2.扩展性高，向增加一个产品，只要增加一个工厂类就可以3.屏蔽产品的具体实现，调用者只关心产品的接口</p><p><strong>缺点</strong>：1.每次增加产品，都需要增加一个具体类和对象的实现工厂，使系统中的类成倍增加，一定程度上增加了系统的复杂度，同时也增加了系统对具体类的依赖</p><p><strong>注意事项</strong>：作为一种创建类的模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式，负载的对象适合使用工厂模式，而简单的对象只需要使用new即可，会增加系统的复杂度</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>将创建一个pizz接口，和实现pizz接口的实体类，下一步是定义工厂类pizzafactory ，text类使用该工厂来获取pizza对象，text将向工厂传递信息，以便获取它所需对象的类型</p><p><img src="/posts/6013/image-20221214144758004.png" alt="类图"></p><p>1.创建一个接口</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Pizza &#123;</span><br><span class="line">    public abstract void prepare();</span><br><span class="line">    public abstract void bake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.创建实现接口的实体类</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ChessePizza implements Pizza&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void prepare() &#123;</span><br><span class="line">        System.out.println(&quot;准备面饼\n准备奶酪&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void bake() &#123;</span><br><span class="line">        System.out.println(&quot;烤奶酪披萨\n20分钟后可以使用 奶酪披萨&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FruitPizza implements Pizza&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void prepare() &#123;</span><br><span class="line">        System.out.println(&quot;准备面饼\n准备水果&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void bake() &#123;</span><br><span class="line">        System.out.println(&quot;烤水果披萨\n20分钟后可以使用 水果披萨&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.创建一个工厂，生成基于给定信息的实体类的对象</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PizzaFactory &#123;</span><br><span class="line">    public Pizza creat(String type)&#123;</span><br><span class="line">        if(type.equals(&quot;水果披萨&quot;))&#123;</span><br><span class="line">            return new ChessePizza();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return new FruitPizza();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.使用该工厂，通过传递类型信息来获取实体类的对象</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PizzaFactory &#123;</span><br><span class="line">    public Pizza creat(String type)&#123;</span><br><span class="line">        if(type.equals(&quot;水果披萨&quot;))&#123;</span><br><span class="line">            return new ChessePizza();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return new FruitPizza();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子数组和</title>
      <link href="/posts/60313.html"/>
      <url>/posts/60313.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/posts/60313/20221219131354.jpg"></p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>施工中</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>施工中</p>]]></content>
      
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deemo</title>
      <link href="/posts/42771.html"/>
      <url>/posts/42771.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>top_img: <img src="/posts/42771/deemo.jpg"></p><h1 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h1><p><img src="/posts/42771/deemo.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java static 关键字</title>
      <link href="/posts/36808.html"/>
      <url>/posts/36808.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>static关键字</p><p>​写作业的时候出错了，原因是对static的理解有问题（或者说是根本没有理解），今天就来整理一下static的作用跟用法</p><p>​static作用，修饰类的成员变量，成员方法以及代码块，被修饰的成员被成为静态成员</p><p>​<strong>静态变量</strong>：<strong>使用static修饰的成员变量</strong>，成为静态变量或类变量，<strong>他被类的所有对象共享</strong>（类似全局变量，不被某个对象所独有，每个对象都可对其进行修改）</p><p>​<strong>静态方法</strong>：使用static修饰的在某个类中的方法可以被<strong>直接调用而不需要创建某个具体的对象</strong>（不需依附实例即可使用）。作用，不需要创建对象就可以使用的方法</p><p>​在静态方法中不能访问类的非静态成员变量和非静态类成员方法，但在非静态成员方法中是可以访问静态成员方法和变量</p><p>​<strong>静态代码块</strong>（优化程序性能）：代码块可分为普通代码块，构造代码块，和同步代码块（在多线程部分）执行的优先级高于非静态的初始代码块，他会在<strong>类的初始化时执行一次，执行完成便销毁</strong>，仅能初始化类变量，static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来依次执行每个static块，并且只会执行一次。无论类的对象被创建多少次，由于Java虚拟机只加载一次类，所以静态代码只会执行一次</p><p>我的误区：java中的变量不会影响到被修饰的东西的作用域，在Java中能影响访问权限的只有private，public，protect。虽然对于静态方法来说没有this，但是我们在非静态方法中能够通过this访问静态方法成员变量。</p><p>​this 关键字（指向调用对象本身）</p><p>​作用，解决成员变量和局部变量名称相同的问题</p><p>1.通过this关键字调用成员变量解决与局部变量名称冲突的问题</p><p>2.通过this关键字调用成员方法，方法用static修饰则不能用this（静态方法没有this，可随处调用，并不依附与某个对象）</p><p>3.this关键字调用的构造方法可以在一个构造方法中使用”this（[参数]，[参数],……）“的形式来调用构造方法S</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>为了让同学们能更加理解static关键字，特此更新</p><p>首先回忆，Java程序的内存划分</p><p>Java程序在执行的时候内存区被划分为</p><h4 id="Java内存划分"><a href="#Java内存划分" class="headerlink" title="Java内存划分"></a>Java内存划分</h4><p>1.本地方法栈<br>本地方法栈用于支持执行本地（Native）方法，即使用其他编程语言（如C、C++）编写的方法。它保存了本地方法的调用和执行信息，包括方法参数、局部变量以及调用本地方法所需的相关数据。本地方法栈与Java虚拟机栈（栈）是分开的，专门用于处理本地方法的调用。</p><p>2.<strong>Java虚拟机栈</strong>——方法调用和执行的内存区——联系递归</p><p>我们程序在执行的时候会首先将main方法加载进栈，如果有其他方法依次加载进栈，方法执行完毕后出栈，main方法出栈后，程序执行完毕</p><p>Java虚拟机栈也称为栈，用于支持Java方法的调用和执行。<strong>每个线程在执行过程中都会有一个对应的栈</strong>，<strong>栈中保存了方法调用的状态信息，包括局部变量、方法参数、返回值以及方法执行过程中的临时数据</strong>。栈的大小在程序启动时可以预先设置，当线程调用的方法层次过多时，栈可能会发生溢出。</p><p>3.<strong>方法区</strong></p><p>方法区是用于存储类的元数据、常量池、静态变量、字节码等信息的区域。它是所有线程共享的内存区域，用于存储加载的类的结构信息和运行时常量池。方法区在较早的Java版本中也被称为永久代（Permanent Generation），但在Java 8及以后的版本中被移除或替换为元空间（Metaspace）。</p><p>4.寄存器</p><p>寄存器是位于CPU内部的一小块高速存储器，用于存储指令执行过程中的临时数据。寄存器对于程序执行速度非常重要，它可以提供快速的数据访问和处理能力。在Java中，我们不能直接控制和访问寄存器，它是由JVM和CPU来管理和使用的。</p><p>5.<strong>堆</strong></p><p>堆是用于存储对象实例和动态分配的内存区域。在Java中，<strong>所有的对象都被分配在堆中</strong>。堆是一个<strong>动态分配的内存区域</strong>（所有通过new关键字创建的对象都储存在里面），用于存储创建的对象和数组。堆的管理由Java虚拟机负责，它提供了垃圾回收机制来自动释放不再使用的对象内存。</p><h4 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h4><p><img src="/posts/36808/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230523171523.png"></p><p>我们主要关注三个区域，一个是栈，程序主要的运行空间。方法区，我们编译好的class文件储存在这个地方。堆区，我们创建好的对象都在这里。在程序进行编译的时候，Java会自动帮我们把写好的代码转换成.class文件，加载进方法区中，这里比如说我写了一个学生类</p><p><img src="/posts/36808/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230523172049.png"></p><p>在程序进行编译时，Java会将我们编写的代码转换成 <code>.class</code> 文件并加载到方法区中。但此时我们无法直接使用该类，因为其中的属性尚未进行初始化（没有给他们分配内存）。只有通过使用 <code>new</code> 关键字创建对象并对其进行初始化后，我们才能访问对象的属性和方法。例如，对于学生类，我们只有在创建学生对象并为其属性赋值后，该学生才真正存在，我们才能调用其属性和方法。而被static修饰的属性或方法则在.class文件被加载进方法区的时候就已经被初始化完毕。</p><p><img src="/posts/36808/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230523173635.png"></p><p>比如在这里，给学生添加了一个静态属性”种族“ &#x3D; 人类 因为我们在.class文件加载进栈的时候就已经完成了初始化，所以我们在这里可以通过类名直接进行调用，而同样的，被static方法修饰的方法同样也会直接在方法区中被分配内存（给局部变量分配内存），所以我们也可以直接通过类名进行调用。且被static修饰的属性属于该类本身（种族为人类肯定是所有学生共有的，不可能有学生不是人吧），而不是类的对象（实例）中，在创建该类的对象时被static修饰的属性或方法不会被复制到每个对象的内存空间中，而是直接从方法区中获取所以说被static修饰的内容会被该类的所有成员所共有，无论创建多少个对象，他们都共享一个static属性值，（如果上面学生类中的种族属性被修改，那么所有学生的种族都会被修改）在初始化时，被静态修饰的属性不会被分配给每个对象。，它们在方法区内分配了一块独立的内存空间，供所有对象共享。所有对象在使用该属性或者方法的时候，都会访问那个空间无论创建多少个对象，它们都使用同一块静态属性的内存空间。</p><p>总结，被静态修饰符修饰的东西——1.无需创建对象便可通过类名直接调用（因为已经被初始化了），所以可以通过类名去直接访问他们 2. 被该类所创建的所有对象所共有，而不是类的每个对象所拥有的。它们在类加载时就被初始化，并在方法区内分配了空间。因此，所有通过该类创建的对象共享同一个静态属性的值，修改一个对象的静态属性会影响到其他对象。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
