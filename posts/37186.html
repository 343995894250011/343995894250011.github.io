<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JAVA编程思想 | 嘟嘟可大骑士的技术日志</title><meta name="author" content="嘟嘟可大骑士"><meta name="copyright" content="嘟嘟可大骑士"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="对象入门抽象的优势 什么是面向对象 所有的编程语言的最终目的都是提供一种“抽象方法”，解决问题的复杂程度直接取决于抽象的问题种类及质量。汇编语言是对基础机器的少量抽象，命令式语言是对汇编语言的一种抽象，但是这些抽象原理依然需要我们着重考虑计算机的结构而非问题本身结构。而面向对象的程序设计则使我们可以使用一些工具表达问题空间内的元素。我们将问题空间中的元素以及他们在方案空间的表示物称为“对象”（Ob">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA编程思想">
<meta property="og:url" content="http://example.com/posts/37186.html">
<meta property="og:site_name" content="嘟嘟可大骑士的技术日志">
<meta property="og:description" content="对象入门抽象的优势 什么是面向对象 所有的编程语言的最终目的都是提供一种“抽象方法”，解决问题的复杂程度直接取决于抽象的问题种类及质量。汇编语言是对基础机器的少量抽象，命令式语言是对汇编语言的一种抽象，但是这些抽象原理依然需要我们着重考虑计算机的结构而非问题本身结构。而面向对象的程序设计则使我们可以使用一些工具表达问题空间内的元素。我们将问题空间中的元素以及他们在方案空间的表示物称为“对象”（Ob">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/top_img/10.jpg">
<meta property="article:published_time" content="2023-07-20T14:29:33.000Z">
<meta property="article:modified_time" content="2023-07-27T09:12:20.516Z">
<meta property="article:author" content="嘟嘟可大骑士">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/top_img/10.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/posts/37186"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JAVA编程思想',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-27 17:12:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">66</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/top_img/10.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">嘟嘟可大骑士的技术日志</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JAVA编程思想</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-20T14:29:33.000Z" title="发表于 2023-07-20 22:29:33">2023-07-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-27T09:12:20.516Z" title="更新于 2023-07-27 17:12:20">2023-07-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JAVA编程思想"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="对象入门"><a href="#对象入门" class="headerlink" title="对象入门"></a>对象入门</h1><p><em><strong>抽象的优势</strong></em></p>
<p>什么是面向对象</p>
<p>所有的编程语言的最终目的都是提供一种“抽象方法”，<strong>解决问题的复杂程度直接取决于抽象的问题种类及质量</strong>。汇编语言是对基础机器的少量抽象，命令式语言是对汇编语言的一种抽象，但是这些抽象原理依然需要我们着重考虑计算机的结构而非问题本身结构。而面向对象的程序设计则使我们可以使用一些工具表达问题空间内的元素。我们将问题空间中的元素以及他们在方案空间的表示物称为“对象”（Object）<strong>OOP允许我们根据问题来描述问题</strong>，<strong>在OOP中，我们将问题中的实体看作是对象，每个对象都有自己的属性（数据）和方法（行为）</strong>。而面向过程编程则更偏向于按照解决问题的步骤和流程来描述问题，它以过程或者函数为中心，强调问题的解决过程和步骤。在面向过程编程中，数据和函数是分开的，函数接收输入数据，进行一系列操作，然后返回结果，这种方式可能适合一些简单的线性的问题，但在处理复杂问题时，代码会变得冗长和难以维护，总结一下</p>
<ul>
<li>OOP允许我们根据问题来描述问题，通过对象的抽象和交互来建模。</li>
<li>面向过程编程更加强调按照步骤和流程来描述问题，以函数为中心。</li>
</ul>
<p><em><strong>面向对象的五大特征</strong></em></p>
<ul>
<li><p><strong>所有东西都是对象</strong>。可将对象看成是一种新型变量；它保存数据，但可要求它自身对自身进行操作。理论上讲，可从要解决的问题身上提出所有概念性的组件，然后在程序中将它表达为一个对象。</p>
</li>
<li><p><strong>程序是一大堆对象的组合</strong>；通过消息传递，对象知道自己该做些什么。为了向对象发出请求，需要向那个对象“发送一条消息”。可将消息想象为一个调用请求，它调用的是从所属目标对象的一个子例或函数</p>
</li>
<li><p><strong>每个对象都有自己的储存空间</strong>，可容纳其他对象。通过封装现有对象，可制作出新型对象（通过现有的零件，我们可以组装成不同的车辆）。</p>
</li>
<li><p><strong>每个对象都有一种类型</strong>。每个对象都是某个类的一个实例。Class 是和 Type 的同义词。<strong>一个类最重要的特征是，能将什么消息发给它</strong></p>
</li>
<li><p><strong>同一类的所有对象都能接收相同的消息</strong>。换一种理解，同意类的所有对象都能对他们发送相同的消息（调用相同的方法），让他们执行相同的行为，统一了对象之间的交互方式</p>
<p>PS：在面向对象语言中，调用一个方法可以理解问向对象发送了一条消息，能向对象发送什么消息由接口进行定义，或方法，方法是向对象外提供的接口，用于响应外部的请求和实现特定的行为</p>
</li>
</ul>
<p><em><strong>对象的接口</strong></em>（API）</p>
<p>在创建对象后，我们如何向对象发出请求，让他做一些实际的事情呢？每个对象仅能接收特定的请求，我们向对象发出的请求是通过它的接口定义的，对象的类型，或类则定义了它的接口形式；<strong>类型与接口的等价对应关系是面向对象程序设计的基础</strong></p>
<p><em><strong>实现方案的隐藏</strong></em></p>
<p><strong>为什么要控制对成员的访问</strong>：</p>
<ul>
<li>防止程序员接触他们不该接触的东西</li>
<li>允许库设计人员修改内部结构，不用担心它会对客户端造成什么影响</li>
</ul>
<p><strong>设置访问权限的关键字</strong>——访问修饰符</p>
<ul>
<li>public：该成员对所有类可见，包括其他包中的类</li>
<li>private：只对本类可见，其他类无法访问</li>
<li>protected：对本包中的类和其他包中该类的子类可见</li>
<li>friendly：对本包中的类可见，但其他包中的类不可见</li>
</ul>
<p><strong>类边界</strong>——用于泛型中设置泛型类型参数的类型范围</p>
<ul>
<li><p>extends：设置上界边界，限制泛型类型参数必须是指定类或者其他子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T <span class="keyword">extends</span> <span class="title class_">SomeClass</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>super：设置下界边界，限制泛型类型参数必须是执行类或其父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T <span class="built_in">super</span> SomeClass&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>默认为Object类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p><em><strong>方案的重用</strong></em></p>
<p>重复使用一个类，最简单的方法就是直接使用该类的对象，同时也能将那个类的一个对象置入一个新的对象，创建新类的时候，首先应考虑组织对象</p>
<p><em><strong>继承</strong></em>：重新使用接口</p>
<p><strong>继承的目标</strong>：直接利用现有的数据类型，对其进行克隆，再根据情况进行添加和修改，使用继承时，相当于创建了一个新类，这个心累不仅包含了现有类型的所有成员，也同时复制类基础类的接口。也就是说，可以向基础类的对向发送的消息也可以原样发送给衍生类的对象，也就是说<strong>衍生类具有于基础类相同的类型</strong></p>
<p><strong>如何区别新类于基础类</strong>：为衍生类添加 新函数（功能）、改变基础类一个现有函数的行为。（重写）</p>
<p><strong>等价与类似关系</strong>：如果基础类与衍生类之间只有重写关系，没有添加新的功能，那么我们就称这种关系为等价关系，例如：圆形就是一种几何形状，此时，我们可以完美的将新类型替换为基础类型。如果衍生类中有新的接口元素，此时我们虽然也可以将新类型替换为基础类型，但是我们无法在基础类型中访问新函数，此时这种替换并不完美，所以他们不是完全等价的</p>
<p><em><strong>多态</strong></em>：对象的互换使用</p>
<p>继承通常会导致一系列类建立在统一的接口基础上，对于这样的一系列类，我们可以将衍生类对象当作基础类的一个对象看待，统一他们的操作，忽略衍生类的特定细节，只与基础类打交道，使得程序更具有扩展性，这种类型处理的过程被称为Upcasting， 向上转型</p>
<p><strong>动态绑定</strong>：在我们给基础类引用发送消息的时候，它怎么会知道应该使用哪个衍生类型呢？通过多态，对于面向对象的程序设计语言来说，实现多态性的方法叫做”动态绑定“，编译器和运行期系统会负责对所有细节的控制，函数的动态绑定是自动进行的，我们无需关心</p>
<p><strong>抽象的基础类和接口</strong>：如果我们只希望基础类为自己的衍生类提供一个接口，只对向上转型称它，来使用他的接口，我们可以使用abstract关键字将他设置为一个抽象对象，也可以使用该关键字描述一个尚未实现的方法作为一个”根“使用，这说明这是用于从这个类继承的所有类型的一个接口函数，目前没有对他进行任何形式的实现，继承的类必须重写，否则也得设置为抽象类。interface关键字将抽象类的概念更延申了一部，它完全禁止所有的函数定义</p>
<p><em><strong>对象的创建和存在时间</strong></em></p>
<p>C++认为执行效率是最重要的一个问题，所以允许程序员自己做出选择对象的储存地点和存在时间</p>
<ul>
<li>在堆栈中创建，缺点，在编写程序时，必须知道对象的准确数量，存在时间以及类型；优点，编译器会自动判断对象的持续时间有多长，会自动破坏和清除对象</li>
<li>在内存池中动态创建，优点，创建十分灵活，想要就可以创建，缺点，内存分配储存空间的时间比在堆栈中创建的时间长很多（堆栈中创建一般只需将指针向上或向下易懂即可），由垃圾收集器进行破坏，会牺牲一定性能</li>
</ul>
<p><strong>单根结构</strong>：所有类都从单独的及一个基础类继承而来，Java的基础类为Object，优点为</p>
<ul>
<li>单根结构中所有对象都有一个通用的接口，最终都能归属于相同的类型</li>
<li>单根结构中所有的对象，都可以保证拥有一些特定的功能，一个单根结构，加上所有对象都在内存堆中创建，可以极大简化参数的传递，使用单根结构，可以方便的实现一个垃圾收集器</li>
<li>方便使用集合，容纳了Object的集合可以容纳任何东西，但是向下转型的时候要注意是否安全，或者使用泛型对集合进行限制</li>
</ul>
<p><strong>垃圾收集器</strong></p>
<p>垃圾收集器会自己知道一个对象在什么时候不再使用，然后会自动释放那个对象占据的内存空间，但是会付出一定性能的代价，并且由于在Java程序执行期间存在一种不连贯的因素，所以在某些特定的场合，我们必须避免使用它，比如在一个程序的执行必须保持稳定，连贯的时候</p>
<p><em><strong>违例控制</strong></em>：解决错误</p>
<p>Java的为例控制会保证为例不能被忽视，这与那些返回错误值不同，肯定能在某个地方得到处置，是必须使用的</p>
<p><em><strong>多线程</strong></em></p>
<p>在线程处理的时候，必须注意的一个问题：共享资源，如果有多个线程同时玉兴并且试图访问相同资源，那么一个线程可将资源锁定，在完成了他的任务后，再解开这个锁，让其他线程可以接着使用同样的资源，Java中的线程处理是在对象这一级支持的，所以一个线程可表示为一个对象，Java提供了有限资源的锁定方案，它能锁定任何对象占用的内存（内存实际是多种共享资源的一种），所以同一时间只能有一个线程使用特定的内存空间但是要实现Synchronized关键字</p>
<p><em><strong>设计Java程序步骤</strong></em></p>
<ol>
<li><p>明确制作内容，建立需求分析和系统规格</p>
<p>明确使用条件和应用场景，让程序知道需要做什么</p>
</li>
<li><p>明确设计方案，解释各类对象在外观上是什么样子，以及相互间是如何沟通的，可以使用（UML）语言进行建模，也可以对对象以及他们的接口进行文字化描述</p>
</li>
<li><p>开始创建</p>
</li>
<li><p>校订</p>
</li>
</ol>
<p><strong>命名空间</strong>：问题空间是指解决一个具体问题时所涉及到的所有可能情况和可行解的范围。</p>
<p><strong>组织</strong>：在现有类上组织一个新类，也称为包含关系</p>
<h1 id="一切都是对象"><a href="#一切都是对象" class="headerlink" title="一切都是对象"></a>一切都是对象</h1><p>Java是一种存粹的面向对象的程序设计语言，首先便假定了我们只希望进行面向对象的程序设计。尽管我们将一切都看作”对象“，但实际操纵的标识符却是指向对象的一个引用。引用不一定会有一个对应的对象与他连接，所以在创建一个引用的时候，我们无论如何也要对它进行初始化。如何创建一个对象呢？我们通常使用”new“关键字，创建一个对象，然后把他与一个引用相连。</p>
<p>程序保存数据的地方</p>
<ol>
<li>寄存器。最快的保存区域，但是我们没有直接控制权，也不能在程序中找到寄存器存在的痕迹</li>
<li>堆栈。驻留于常规RAM（随机访问储存器）区域，可通过它的堆栈指针获得处理的直接支持，堆栈指针若下移，则会创建新的内存，若上移，则会释放对应内存。缺点是Java编译器必须准确的知道堆栈内保存的所有数据的长度以及存在时间。这是由于它必须生成相应的代码以便向上和向下移动指针</li>
<li>堆。一种常规用途的内存池（也在RAM）区域，其中保存了Java对象，特点是编译器不须知道要从堆力分配多少储存空间，也不需要知道储存的诗句要在堆里停留多长时间。但是付出的代价则是分配储存空间会花费更长的时间</li>
<li>静态储存。位于固定位置，在程序运行期间，静态储存的数据将随时等候调用。但是对象本身永远也不会进入静态储存空间</li>
<li>常数储存。</li>
<li>非RAM储存。独立于一个程序之外，程序不运行时仍然存在，并在程序的控制范围之外</li>
</ol>
<p>Java中所有对象都是存储在堆中的，除了基本数据类型</p>
<p>对象本身不存在生命周期，只要我们愿意，就可以让他继续存在下去，一旦不被需要，就会自动被垃圾收集器自动回收，</p>
<p>对象方法的调用可以理解为，向一个对象发送一个消息</p>
<p>嵌入 式文档，使用javadoc命令，我们可以给一个项目快速生成可供阅读的html文档</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 一个类注释 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">docTest</span> &#123;</span><br><span class="line"><span class="comment">/** 一个变量注释 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> i;</span><br><span class="line"><span class="comment">/** 一个方法注释 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@see</span> 类名</span><br><span class="line"><span class="meta">@see</span> 完整类名</span><br><span class="line"><span class="meta">@see</span> 完整类名#方法名</span><br><span class="line">    </span><br><span class="line">会自动加入一个指向其他类文档的超链接</span><br></pre></td></tr></table></figure>

<p>类文档标记</p>
<blockquote>
<ol>
<li>@version<br>格式如下：<br>@version 版本信息<br>其中，“版本信息”代表任何适合作为版本说明的资料。若在 javadoc 命令行使用了“-version”标记，就<br>会从生成的 HTML 文档里提取出版本信息。</li>
<li>@author<br>格式如下：<br>@author 作者信息<br>其中，“作者信息”包括您的姓名、电子函件地址或者其他任何适宜的资料。若在javadoc 命令行使用了“-<br>author”标记，就会专门从生成的HTML 文档里提取出作者信息。<br>可为一系列作者使用多个这样的标记，但它们必须连续放置。全部作者信息会一起存入最终 HTML 代码的单独<br>一个段落里。</li>
</ol>
</blockquote>
<p>方法文档标记</p>
<blockquote>
<ol>
<li>@param 格式如下： 58 @param 参数名 说明 其中，“参数名”是指参数列表内的标识符，而“说明”代表一些可延续到后续行内的说明文字。一旦遇到 一个新文档标记，就认为前一个说明结束。可使用任意数量的说明，每个参数一个。 </li>
<li>@return 格式如下： @return 说明 其中，“说明”是指返回值的含义。它可延续到后面的行内。 </li>
<li>@exception 有关“违例”（Exception）的详细情况，我们会在第 9 章讲述。简言之，它们是一些特殊的对象，若某个方 法失败，就可将它们“扔出”对象。调用一个方法时，尽管只有一个违例对象出现，但一些特殊的方法也许 能产生任意数量的、不同类型的违例。所有这些违例都需要说明。所以，违例标记的格式如下： @exception 完整类名 说明 其中，“完整类名”明确指定了一个违例类的名字，它是在其他某个地方定义好的。而“说明”（同样可以 延续到下面的行）告诉我们为什么这种特殊类型的违例会在方法调用中出现。 </li>
<li>@deprecated 这是Java 1.1 的新特性。该标记用于指出一些旧功能已由改进过的新功能取代。该标记的作用是建议用户不 必再使用一种特定的功能，因为未来改版时可能摒弃这一功能。若将一个方法标记为@deprecated，则使用该 方法时会收到编译器的警告。</li>
</ol>
</blockquote>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><p>在Java中，标签（Label）是用于标识代码块的标识符。标签通常与循环语句（如for、while、do-while）和条件语句（如if、switch）一起使用，用于在嵌套结构中定位和跳转到特定的代码块。虽然标签在某些情况下可能会被认为是一种不推荐使用的控制流构造，但在特定的情况下，它们可以提供一种便捷的方式来实现控制流。</p>
<p>在Java中，标签的语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy codelabelName: <span class="comment">// 冒号是标签语法的一部分</span></span><br><span class="line"><span class="comment">// 代码块</span></span><br></pre></td></tr></table></figure>

<p>以下是标签的几个重要用途：</p>
<ol>
<li>跳出多重循环：通过使用标签，我们可以从内部循环直接跳出外部循环，从而避免使用嵌套的控制语句。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy codeouterLoop: <span class="comment">// 标签名为outerLoop</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i * j &gt; <span class="number">12</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span> outerLoop; <span class="comment">// 直接跳出外部循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i * j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在嵌套循环中使用continue：通过标签，我们可以在嵌套循环中使用<code>continue</code>语句跳过特定的外部循环迭代。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy codeouterLoop: <span class="comment">// 标签名为outerLoop</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i * j % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span> outerLoop; <span class="comment">// 跳过当前外部循环的迭代</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i * j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，在使用标签时要谨慎。滥用标签可能会导致代码可读性下降，并且可能使代码更难维护。大多数情况下，使用传统的循环控制语句（如<code>break</code>和<code>continue</code>）已经足够了。只有在处理复杂的嵌套结构时，才建议使用标签。在一般情况下，合理设计程序逻辑可以避免过度使用标签。</p>
<h1 id="初始化和清理"><a href="#初始化和清理" class="headerlink" title="初始化和清理"></a>初始化和清理</h1><p>Java会在用户使用对象之前（即对象刚创建完成）自动调用对象的构造器方法，从而保证初始化，<strong>构造器存在的意义就是保证在使用对象之前它进行了正确的初始化</strong>。为了避免构造方法命名冲突，要求构造器与类名完全相同</p>
<p>Java创建对象的步骤</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>类加载：在Java程序中使用某个类之前，需要先将该类加载到Java虚拟机（JVM）中。类加载是Java的类加载器执行的过程，它负责查找类的字节码文件，并将其加载到内存中。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>类加载后，JVM会在内存中为该类分配空间，包括类的字段、方法和其他成员变量。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>对象实例化：当使用<span class="built_in">new</span>关键字创建对象时，JVM会在内存中分配一块空间，用于存储对象的实例变量和引用类型。对象实例化是通过调用类的构造方法来完成的。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>初始化：在对象实例化后，JVM会调用对象的构造方法来完成对象的初始化。构造方法负责对实例变量进行初始化，可以执行其他必要的操作。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>内存分配：在对象初始化完成后，对象所需的内存空间已经分配完毕，并且对象可以在堆内存中被访问和使用。</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>对象引用：在创建对象后，可以使用对象的引用来访问和操作该对象。引用是一个指向对象在内存中地址的变量，通过引用可以访问对象的成员和方法。</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>对象使用和销毁：通过引用可以使用对象的方法和成员变量。当对象不再被引用时，Java的垃圾回收机制会自动回收该对象所占用的内存空间，以便将其用于存储其他对象。</span><br></pre></td></tr></table></figure>

<p><strong>方法重载</strong></p>
<p>因为Java（c++）规定构造器方法必须与类相同，而我们又想通过不同方式创建要给对象，所以必须有方法重载，重载的每个方法都保证有一个独一无二的参数列表用于区分，且Java的重载与返回值无关</p>
<p><strong>无参构造器</strong></p>
<p>作用：创建“默认对象”</p>
<p>如果一个类中没有构造器，编译器会自动创建一个无参构造，如果类中有且只有一个带参构造，那么无法使用系统提供的无参构造</p>
<p><strong>this关键字</strong></p>
<p>this关键字只能在非静态方法内部引用。当调用一个对象的方法时，this生成了一个对象引用。主要功能是避免混淆。例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">example</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">example</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="comment">// 这里的语句可以理解为 这个对象.a = a;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this关键字必须使用的场合</p>
<ol>
<li><p>方法形参与本类属性字段重名</p>
</li>
<li><p>在一些方法中，需要返回对象的引用</p>
</li>
<li><p>想在本类调用本类的构造方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">class person &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String id;</span><br><span class="line">    </span><br><span class="line">    public person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public person(String name, <span class="type">int</span> age, String id) &#123;</span><br><span class="line">        this(name);</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>static关键字</strong></p>
<p>static 是不依赖对象，而是依赖类创建的</p>
</li>
</ol>
<p><strong>垃圾回收器</strong></p>
<p>java 使用垃圾回收器来回收无用对象占用的内存，但是只会回收通过 new 关键字分配的内存（对于其他资源，比如网络连接，数据库连接，必须手动关闭），所以 java 允许在类中定义一个名为 finalize()的方法</p>
<p>finalize()方法</p>
<ol>
<li>垃圾回收（Garbage Collection）： Java中的垃圾回收机制负责自动释放不再使用的对象占用的内存。当对象不再被任何引用指向时，Java虚拟机会将其标记为垃圾对象，并在合适的时机进行垃圾回收操作，释放这些对象占用的内存。</li>
<li>finalize()方法的作用： <code>finalize()</code>方法是<strong>在对象被垃圾回收器回收之前，即对象被销毁之前调用的一个方法</strong>。该方法<strong>允许对象执行一些清理操作或资源释放工作</strong>。例如，可以在<code>finalize()</code>方法中关闭文件、释放网络连接、释放系统资源等。但是，由于垃圾回收的时间不确定，不能保证<code>finalize()</code>方法何时被调用。</li>
<li>finalize()方法的用法： 在旧版本的Java中，开发人员可以重写<code>finalize()</code>方法来实现对象的清理操作。但是，由于它不可预测性和垃圾回收的开销，从Java 9开始，<code>finalize()</code>方法被标记为过时。因此，不再推荐使用该方法来执行重要的资源释放操作。</li>
<li>代替方式： 推荐使用<code>try-with-resources</code>或手动调用资源释放方法来代替<code>finalize()</code>方法执行资源释放。<code>try-with-resources</code>是Java 7中引入的一种语法，用于自动关闭实现<code>AutoCloseable</code>接口的资源，例如IO流、数据库连接等。</li>
</ol>
<p>无论是**”垃圾回收”还是”终结”，都不保证一定会发生<strong>。如果 Java 虚拟机（JVM）并未面临内存耗尽的情形，它可能不会浪费时间执行垃圾回收以恢复内存。（这就是我算法题爆空间的原因？？？）</strong>所以如果在不再需要某个对象之前，如果必须执行某些操作，我们的自己去做，比如关闭资源**</p>
<p>Java的垃圾回收器能明显提高对象的创建速度。Java 从堆空间分配的速度可以和其他语言在栈上分配空间的速度相比</p>
<blockquote>
<p>你可以把 C++ 里的堆想象成一个院子，里面每个对象都负责管理自己的地盘。一段时间后，对象可能被销毁，但地盘必须复用。在某些 Java 虚拟机中，堆的实现截然不同：它更像一个传送带，每分配一个新对象，它就向前移动一格。这意味着对象存储空间的分配速度特别快。Java 的”堆指针”只是简单地移动到尚未分配的区域，所以它的效率与 C++ 在栈上分配空间的效率相当。当然实际过程中，在簿记工作方面还有少量额外开销，但是这部分开销比不上查找可用空间开销大。</p>
</blockquote>
<blockquote>
<p>当垃圾回收器工作时，一边回收内存，一边使堆中的对象紧凑排列，这样”堆指针”就可以很容易地移动到更靠近传送带的开始处，也就尽量避免了页面错误。垃圾回收器通过重新排列对象，实现了一种高速的、有无限空间可分配的堆模型。</p>
</blockquote>
<p><strong>垃圾回收机制有哪些</strong></p>
<ol>
<li>引用计数法（Reference Counting）： 引用计数法是一种简单的垃圾回收算法，它通过为每个对象维护一个引用计数器来判断对象是否可回收。当对象被引用时，计数器加1；当引用失效时，计数器减1。当计数器为0时，表示该对象不再被引用，可以被回收。然而，引用计数法容易出现循环引用的问题，导致无法正确回收循环引用的对象。</li>
<li>可达性分析算法（Reachability Analysis）： Java的主要垃圾回收机制是基于可达性分析的。该算法通过从一组称为”GC Roots”的根对象开始，遍历所有与根对象直接或间接可达的对象，将可达的对象视为存活对象，而不可达的对象被标记为垃圾对象，最后进行回收。常见的GC Roots包括静态变量、局部变量表、JNI引用等。Java虚拟机的垃圾回收器会周期性地执行可达性分析来回收无用的对象。</li>
<li>分代垃圾回收： 分代垃圾回收是一种优化策略，将堆内存划分为不同的代（Generation），通常分为新生代（Young Generation）和老年代（Old Generation）。由于新对象的生命周期较短，大部分对象在创建后很快就变得不可达。因此，新生代采用较短的垃圾回收周期和更快的回收算法。而老年代中的对象生命周期较长，因此采用更慢但更全面的垃圾回收算法。</li>
<li>垃圾回收器： Java虚拟机提供了不同类型的垃圾回收器，例如Serial Garbage Collector、Parallel Garbage Collector、CMS (Concurrent Mark-Sweep) Garbage Collector、G1 (Garbage-First) Garbage Collector等。这些回收器有不同的实现策略，适用于不同的应用场景和硬件配置。</li>
<li>System.gc()和Runtime.gc()： Java中可以通过<code>System.gc()</code>或<code>Runtime.gc()</code>方法建议垃圾回收器执行垃圾回收操作。但是，这只是建议，垃圾回收器是否真正执行垃圾回收依然由虚拟机决定，不一定会立即执行。</li>
</ol>
<p><strong>Java垃圾回收</strong></p>
<ol>
<li>垃圾回收机制：Java虚拟机使用可达性分析算法来进行垃圾回收。从一组称为”GC Roots”的根对象开始，遍历所有与根对象直接或间接可达的对象，将不可达的对象标记为垃圾对象，然后进行回收。这种机制解决了循环引用导致的问题。</li>
<li>分代垃圾回收：Java虚拟机将堆内存划分为不同的代，如新生代和老年代。新对象的生命周期较短，大部分对象在创建后很快就变得不可达，因此新生代采用较短的垃圾回收周期和更快的回收算法，而老年代中的对象生命周期较长，采用更慢但更全面的垃圾回收算法。</li>
<li>停止-复制（stop-and-copy）和标记-清扫（mark-and-sweep）：Java虚拟机中的垃圾回收器采用了自适应的垃圾回收技术，其中包括停止-复制和标记-清扫两种方式。停止-复制在回收时会暂停程序运行，将存活对象从当前堆复制到另一个堆，并整理对象排列。标记-清扫在回收时只标记存活对象，然后清理未标记的垃圾对象，但会导致堆空间碎片化。</li>
<li>分块（Chunking）：Java虚拟机中的内存分配以较大的块为单位，其中每个块有年代数来记录对象是否存活。这对处理大量短命的临时对象很有帮助。</li>
<li>即时编译器（JIT）：Java虚拟机中使用即时编译器来将部分或全部代码翻译成本地机器码，以提高运行速度。它可以采用惰性评估的方式，只在必要时才进行编译，避免不必要的编译开销和代码长度增加。</li>
</ol>
<p><strong>成员初始化</strong></p>
<p>Java可以保证所有变量在使用前都能得到恰当的初始化。对于方法的局部变量，这种保证会以编译错误的方式呈现</p>
<p>指定初始化</p>
<p>在定义的地方赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitialValues2</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">bool</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">    <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0xff</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">999</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">lng</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">3.14f</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3.14159</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Depth</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Measurement</span> &#123;</span><br><span class="line">    <span class="type">Depth</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Depth</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用方法来提供初始值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodInit</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> f();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法可以带有参数，但这些参数不能是未初始化的类成员变量。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodInit2</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> f();</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> g(i);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造器初始化</p>
<p>在使用构造器初始化的时候并不会影响编译器自动初始化，这能为“初始化”操作提供保证，他们会在任何方法（包括构造器）被调用之前得到初始化</p>
<p>静态数据的初始化</p>
<blockquote>
<p>无论创建多少个对象，静态数据都只占用一份存储区域。<strong>static</strong> 关键字不能应用于局部变量，所以只能作用于属性（字段、域）。如果一个字段是静态的基本类型，你没有初始化它，那么它就会获得基本类型的标准初值。如果它是对象引用，那么它的默认初值就是 <strong>null</strong>。</p>
</blockquote>
<p>静态初始化只有在有必要的时候才会进行，如果不创建某个对象，也没有引用静态变量，那么它永远不会被创建</p>
<p>对象创建过程，假设有个Dog类</p>
<ol>
<li>即使没有显式地使用 <strong>static</strong> 关键字，构造器实际上也是静态方法。所以，当首次创建 <strong>Dog</strong> 类型的对象或是首次访问 <strong>Dog</strong> 类的静态方法或属性时，Java 解释器必须在类路径中查找，以定位 <strong>Dog.class</strong>。</li>
<li>当加载完 <strong>Dog.class</strong> 后（后面会学到，这将创建一个 <strong>Class</strong> 对象），有关静态初始化的所有动作都会执行。因此，静态初始化只会在首次加载 <strong>Class</strong> 对象时初始化一次。</li>
<li>当用 <code>new Dog()</code> 创建对象时，首先会在堆上为 <strong>Dog</strong> 对象分配足够的存储空间。</li>
<li>分配的存储空间首先会被清零，即会将 <strong>Dog</strong> 对象中的所有基本类型数据设置为默认值（数字会被置为 0，布尔型和字符型也相同），引用被置为 <strong>null</strong>。</li>
<li>执行所有出现在字段定义处的初始化动作。</li>
<li>执行构造器。你将会在”复用”这一章看到，这可能会牵涉到很多动作，尤其当涉及继承的时候。</li>
</ol>
<p>显式静态初始化（使用静态代码块）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态代码块中的内容只执行一次：首次创建这个类的对象或者首次访问这个类的静态成员的时候</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Spoon</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">47</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非静态实例初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mug</span> &#123;</span><br><span class="line">    Mug(<span class="type">int</span> marker) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mug(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mugs</span> &#123;</span><br><span class="line">    Mug mug1;</span><br><span class="line">    Mug mug2;</span><br><span class="line">    &#123; <span class="comment">// [1]</span></span><br><span class="line">        mug1 = <span class="keyword">new</span> <span class="title class_">Mug</span>(<span class="number">1</span>);</span><br><span class="line">        mug2 = <span class="keyword">new</span> <span class="title class_">Mug</span>(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;mug1 &amp; mug2 initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mugs() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mugs()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mugs(<span class="type">int</span> i) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mugs(int)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside main()&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Mugs</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;new Mugs() completed&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Mugs</span>(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;new Mugs(1) completed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inside main</span><br><span class="line">Mug(1)</span><br><span class="line">Mug(2)</span><br><span class="line">mug1 &amp; mug2 initialized</span><br><span class="line">Mugs()</span><br><span class="line">new Mugs() completed</span><br><span class="line">Mug(1)</span><br><span class="line">Mug(2)</span><br><span class="line">mug1 &amp; mug2 initialized</span><br><span class="line">Mugs(int)</span><br><span class="line">new Mugs(1) completed</span><br></pre></td></tr></table></figure>

<p>看起来它很像静态代码块，只不过少了 <strong>static</strong> 关键字。这种语法对于支持”匿名内部类”的初始化是必须的，但是你也可以使用它保证某些操作一定会发生，而不管哪个构造器被调用。从输出看出，实例初始化子句是在两个构造器之前执行的。</p>
<p>数组初始化</p>
<p>Java编译器不允许指定数组大小，我们只有对数组的一个引用（你已经为该引用分配了足够的存储空间），但是还没有给数组对象本身分配任何空间，为了给数组创建相应的存储空间，必须写初始化表达式。</p>
<p>如果在编写程序时，不确定数组中需要多少个元素，可以直接使用new关键字在数组中创建元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line">public class ArrayNew &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        <span class="type">int</span>[] a;</span><br><span class="line">        Random rand = <span class="built_in">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        a = <span class="built_in">new</span> <span class="type">int</span>[rand.nextInt(<span class="number">20</span>)];</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;length of a = &quot;</span> + a.length);</span><br><span class="line">        System.out.<span class="built_in">println</span>(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可变参数列表</p>
<p>可以以一种类似 C 语言中的可变参数列表（C 通常把它称为”varargs”）来创建和调用方法。这可以应用在参数个数或类型未知的场合。由于所有的类都最后继承于 <strong>Object</strong> 类，所以可以创建一个以 Object 数组为参数的方法，并像下面这样调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarArgs</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(Object[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj: args) &#123;</span><br><span class="line">            System.out.print(obj + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        printArray(<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="number">47</span>, (<span class="type">float</span>) <span class="number">3.14</span>, <span class="number">11.11</span>&#125;);</span><br><span class="line">        printArray(<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;);</span><br><span class="line">        printArray(<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="keyword">new</span> <span class="title class_">A</span>(), <span class="keyword">new</span> <span class="title class_">A</span>(), <span class="keyword">new</span> <span class="title class_">A</span>()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">47 3.14 11.11</span><br><span class="line">one two three</span><br><span class="line">A@15db9742 A@6d06d69c A@7852e922</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; 上面方法 过时 最新版 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewVarArgs</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(Object... args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj: args) &#123;</span><br><span class="line">            System.out.print(obj + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Can take individual elements:</span></span><br><span class="line">        printArray(<span class="number">47</span>, (<span class="type">float</span>) <span class="number">3.14</span>, <span class="number">11.11</span>);</span><br><span class="line">        printArray(<span class="number">47</span>, <span class="number">3.14F</span>, <span class="number">11.11</span>);</span><br><span class="line">        printArray(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        printArray(<span class="keyword">new</span> <span class="title class_">A</span>(), <span class="keyword">new</span> <span class="title class_">A</span>(), <span class="keyword">new</span> <span class="title class_">A</span>());</span><br><span class="line">        <span class="comment">// Or an array:</span></span><br><span class="line">        printArray((Object[]) <span class="keyword">new</span> <span class="title class_">Integer</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 当具有可选的尾随参数时，这一特性会有帮助：</span></span><br><span class="line">        printArray(); <span class="comment">// Empty list is OK</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">47 3.14 11.11</span><br><span class="line">47 3.14 11.11</span><br><span class="line">one two three</span><br><span class="line">A@15db9742 A@6d06d69c A@7852e922</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; 可变参数列表会使得重载方法更加复杂，可能很危险</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverloadingVarargs</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Character... args)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Character c: args) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span> + c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Integer... args)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer i: args) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Long... args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;third&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        f(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">        f(<span class="number">1</span>);</span><br><span class="line">        f(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        f(<span class="number">0</span>);</span><br><span class="line">        f(<span class="number">0L</span>);</span><br><span class="line">        <span class="comment">//- f(); // Won&#x27;s compile -- ambiguous</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">first a b c</span><br><span class="line">second 1</span><br><span class="line">second 2 1</span><br><span class="line">second 0</span><br><span class="line">third</span><br></pre></td></tr></table></figure>

<p>在这个代码中，如果我们调用不含参的f()编译器就会感到迷茫，可以通过在参数列表中添加一个非可变参数来解决这个问题</p>
<p>枚举类型enum</p>
<p>在Java中，枚举类型（Enumeration，简称Enum）是一种特殊的数据类型，用于定义一个有限且固定数量的常量集合。枚举类型在Java中是一种预定义的类，它可以包含常量和方法。</p>
<p>Java的枚举类型具有以下特点：</p>
<ol>
<li>定义枚举类型：使用<code>enum</code>关键字来定义枚举类型。枚举类型的定义通常位于类的内部，但也可以单独定义。枚举类型的名称应该以大写字母开头，多个单词使用大写字母和下划线分隔。</li>
<li>常量集合：枚举类型定义了一组常量，这些常量称为枚举常量。每个枚举常量都是枚举类型的一个实例，用逗号分隔，放在括号内部。枚举常量通常以全大写字母表示，多个单词使用大写字母和下划线分隔。</li>
<li>枚举类的实例：枚举类型在运行时只会被实例化一次，每个枚举常量都是枚举类型的实例。</li>
<li>默认方法：Java中的枚举类型可以包含字段、构造方法、方法和内部类。可以在枚举类型中定义普通方法，但不能在枚举类型中定义抽象方法。</li>
</ol>
<p>常搭配switch语句，简单示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Spiciness</span> &#123;</span><br><span class="line">    NOT, MILD, MEDIUM, HOT, FLAMING</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleEnumUse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Spiciness</span> <span class="variable">howHot</span> <span class="operator">=</span> Spiciness.MEDIUM;</span><br><span class="line">        System.out.println(howHot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// MEDIUM</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EnumOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Spiciness s: Spiciness.values()) &#123;</span><br><span class="line">            System.out.println(s + <span class="string">&quot;, ordinal &quot;</span> + s.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NOT, ordinal 0</span></span><br><span class="line"><span class="comment">MILD, ordinal 1</span></span><br><span class="line"><span class="comment">MEDIUM, ordinal 2</span></span><br><span class="line"><span class="comment">HOT, ordinal 3</span></span><br><span class="line"><span class="comment">FLAMING, ordinal 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Burrito</span> &#123;</span><br><span class="line">    Spiciness degree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Burrito</span><span class="params">(Spiciness degree)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.degree = degree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">describe</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;This burrito is &quot;</span>);</span><br><span class="line">        <span class="keyword">switch</span>(degree) &#123;</span><br><span class="line">            <span class="keyword">case</span> NOT:</span><br><span class="line">                System.out.println(<span class="string">&quot;not spicy at all.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MILD:</span><br><span class="line">            <span class="keyword">case</span> MEDIUM:</span><br><span class="line">                System.out.println(<span class="string">&quot;a little hot.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> HOT:</span><br><span class="line">            <span class="keyword">case</span> FLAMING:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;maybe too hot&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Burrito</span> <span class="variable">plain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Burrito</span>(Spiciness.NOT),</span><br><span class="line">        greenChile = <span class="keyword">new</span> <span class="title class_">Burrito</span>(Spiciness.MEDIUM),</span><br><span class="line">        jalapeno = <span class="keyword">new</span> <span class="title class_">Burrito</span>(Spiciness.HOT);</span><br><span class="line">        plain.describe();</span><br><span class="line">        greenChile.describe();</span><br><span class="line">        jalapeno.describe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This burrito is not spicy at all.</span></span><br><span class="line"><span class="comment">This burrito is a little hot.</span></span><br><span class="line"><span class="comment">This burrito is maybe too hot.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">嘟嘟可大骑士</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/posts/37186.html">http://example.com/posts/37186.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">嘟嘟可大骑士的技术日志</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/top_img/10.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/41682.html"><img class="prev-cover" src="/img/top_img/10.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">设计模式</div></div></a></div><div class="next-post pull-right"><a href="/posts/1079.html"><img class="next-cover" src="/img/top_img/10.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">嘟嘟可大骑士</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">66</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">对象入门</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">一切都是对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">流程控制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">初始化和清理</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/2053.html" title="泛型"><img src="/img/top_img/10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="泛型"/></a><div class="content"><a class="title" href="/posts/2053.html" title="泛型">泛型</a><time datetime="2023-07-30T17:37:19.000Z" title="发表于 2023-07-31 01:37:19">2023-07-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/34426.html" title="GO基础进阶"><img src="/img/top_img/10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GO基础进阶"/></a><div class="content"><a class="title" href="/posts/34426.html" title="GO基础进阶">GO基础进阶</a><time datetime="2023-07-27T14:11:00.000Z" title="发表于 2023-07-27 22:11:00">2023-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/42594.html" title="GO文档学习"><img src="/img/top_img/10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GO文档学习"/></a><div class="content"><a class="title" href="/posts/42594.html" title="GO文档学习">GO文档学习</a><time datetime="2023-07-26T07:00:07.000Z" title="发表于 2023-07-26 15:00:07">2023-07-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/9364.html" title="GO基础"><img src="/img/top_img/10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GO基础"/></a><div class="content"><a class="title" href="/posts/9364.html" title="GO基础">GO基础</a><time datetime="2023-07-25T12:02:25.000Z" title="发表于 2023-07-25 20:02:25">2023-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/41682.html" title="设计模式"><img src="/img/top_img/10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式"/></a><div class="content"><a class="title" href="/posts/41682.html" title="设计模式">设计模式</a><time datetime="2023-07-20T18:25:42.000Z" title="发表于 2023-07-21 02:25:42">2023-07-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 嘟嘟可大骑士</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/haru01.model.json"},"display":{"position":"left","width":300,"height":600},"mobile":{"show":false},"rect":"opacity:0.7","log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>